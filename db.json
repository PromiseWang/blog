{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"source/images/day01/image-20230920140818304.png","path":"images/day01/image-20230920140818304.png","modified":0,"renderable":0},{"_id":"source/images/day01/image-20230920152650727.png","path":"images/day01/image-20230920152650727.png","modified":0,"renderable":0},{"_id":"source/images/day01/image-20230920152855240.png","path":"images/day01/image-20230920152855240.png","modified":0,"renderable":0},{"_id":"source/images/day01/image-20230920153829216.png","path":"images/day01/image-20230920153829216.png","modified":0,"renderable":0},{"_id":"source/images/day02/image-20230921130326208.png","path":"images/day02/image-20230921130326208.png","modified":0,"renderable":0},{"_id":"source/images/day04/142_1.jpeg","path":"images/day04/142_1.jpeg","modified":0,"renderable":0},{"_id":"source/images/day04/160_1.png","path":"images/day04/160_1.png","modified":0,"renderable":0},{"_id":"source/images/day04/160_2.png","path":"images/day04/160_2.png","modified":0,"renderable":0},{"_id":"source/images/day04/160_3.png","path":"images/day04/160_3.png","modified":0,"renderable":0},{"_id":"source/images/day04/IMG_1373.PNG","path":"images/day04/IMG_1373.PNG","modified":0,"renderable":0},{"_id":"source/images/day04/IMG_1372.PNG","path":"images/day04/IMG_1372.PNG","modified":0,"renderable":0},{"_id":"source/images/day04/IMG_2D422EDB0DFC-1.jpeg","path":"images/day04/IMG_2D422EDB0DFC-1.jpeg","modified":0,"renderable":0},{"_id":"source/images/day04/QQ20230923-221152.png","path":"images/day04/QQ20230923-221152.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMPnext1.png","path":"images/day09/KMPnext1.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMPnext2.png","path":"images/day09/KMPnext2.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMPnext4.png","path":"images/day09/KMPnext4.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMPnext3.png","path":"images/day09/KMPnext3.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMPnext5.png","path":"images/day09/KMPnext5.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMPnext6.png","path":"images/day09/KMPnext6.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMPnext7.png","path":"images/day09/KMPnext7.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMP匹配10.png","path":"images/day09/KMP匹配10.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMP匹配1.png","path":"images/day09/KMP匹配1.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMP匹配11.png","path":"images/day09/KMP匹配11.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMP匹配12.png","path":"images/day09/KMP匹配12.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMP匹配2.png","path":"images/day09/KMP匹配2.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMP匹配3.png","path":"images/day09/KMP匹配3.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMP匹配4.png","path":"images/day09/KMP匹配4.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMP匹配5.png","path":"images/day09/KMP匹配5.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMP匹配7.png","path":"images/day09/KMP匹配7.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMP匹配9.png","path":"images/day09/KMP匹配9.png","modified":0,"renderable":0},{"_id":"source/images/day09/KMP匹配8.png","path":"images/day09/KMP匹配8.png","modified":0,"renderable":0},{"_id":"source/images/day09/next数组构建.mp4","path":"images/day09/next数组构建.mp4","modified":0,"renderable":0},{"_id":"source/images/day09/匹配.mp4","path":"images/day09/匹配.mp4","modified":0,"renderable":0},{"_id":"source/images/day07/使用全局变量leetcode.png","path":"images/day07/使用全局变量leetcode.png","modified":0,"renderable":0},{"_id":"source/images/day08/反转2(1).png","path":"images/day08/反转2(1).png","modified":0,"renderable":0},{"_id":"source/images/day08/反转字符串.png","path":"images/day08/反转字符串.png","modified":0,"renderable":0},{"_id":"source/images/day08/字符串移位.png","path":"images/day08/字符串移位.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/128卡住.png","path":"images/【debug】Java中的map比较/128卡住.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/26随机字母报错.png","path":"images/【debug】Java中的map比较/26随机字母报错.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/26字母.png","path":"images/【debug】Java中的map比较/26字母.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/3000多长度.png","path":"images/【debug】Java中的map比较/3000多长度.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/6次扩增.png","path":"images/【debug】Java中的map比较/6次扩增.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/hashST.png","path":"images/【debug】Java中的map比较/hashST.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/java_map_debug.jpg","path":"images/【debug】Java中的map比较/java_map_debug.jpg","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/map源码.png","path":"images/【debug】Java中的map比较/map源码.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/初步解决.png","path":"images/【debug】Java中的map比较/初步解决.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/展示代码.png","path":"images/【debug】Java中的map比较/展示代码.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/断点调试.png","path":"images/【debug】Java中的map比较/断点调试.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/最后一个127.png","path":"images/【debug】Java中的map比较/最后一个127.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/短测试用例.png","path":"images/【debug】Java中的map比较/短测试用例.png","modified":0,"renderable":0},{"_id":"source/images/【debug】Java中的map比较/第一个127.png","path":"images/【debug】Java中的map比较/第一个127.png","modified":0,"renderable":0},{"_id":"source/images/【study】Leetcode中Go语言第三方包/Leetcode中的Go.png","path":"images/【study】Leetcode中Go语言第三方包/Leetcode中的Go.png","modified":0,"renderable":0},{"_id":"source/images/【study】Leetcode中Go语言第三方包/Leetcode支持Go的第三方库.png","path":"images/【study】Leetcode中Go语言第三方包/Leetcode支持Go的第三方库.png","modified":0,"renderable":0},{"_id":"source/images/day18/力扣106.mp4","path":"images/day18/力扣106.mp4","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/【debug】Java中的map比较.md","hash":"b5e0fe8b0f2c67dbc03c40e4788cf40bb7c17036","modified":1696419852879},{"_id":"source/.DS_Store","hash":"bd784abea24447d18fbe3a58a8d5277c421664d1","modified":1697034687081},{"_id":"source/_posts/.DS_Store","hash":"bde98af09a43c091aa5a4fb6cd6fe8d053d3442e","modified":1695881832222},{"_id":"source/_posts/代码随想录算法训练营第一天-704-二分查找、27-移除元素。.md","hash":"23069878aedb4d5c4a75cb581877e123d1c5c0dc","modified":1695269866913},{"_id":"source/_posts/代码随想录算法训练营第三天-203-移除链表元素、707-设计链表、206-反转链表。.md","hash":"107f677152d7272d12ba9306625278d2cd1d60c2","modified":1695475875582},{"_id":"source/_posts/代码随想录算法训练营第九天 28. 实现 strStr()。459.重复的子字符串.md","hash":"2cebf02e4eb35723795b59cd4751b2889f1bface","modified":1696078941380},{"_id":"source/_posts/代码随想录算法训练营第二天-977-有序数组的平方、209-长度最小的子数组、59-螺旋矩阵II。.md","hash":"5e6268c1cf99c396590da27107a073a6e7684c8d","modified":1695274072718},{"_id":"source/_posts/代码随想录算法训练营第七天 454.四数相加II、383. 赎金信、15. 三数之和、18. 四数之和。.md","hash":"cdefd3f5891fca95814036fe6263a88490853e97","modified":1696074061176},{"_id":"source/_posts/搭建博客.md","hash":"8c4e1e9bfdcc15d9882e016ace90f1d9c9fd0794","modified":1695197231011},{"_id":"source/_posts/第八天.md","hash":"71a37fdbc5ca6ff5e7c49411bab94a6c9aad8f1c","modified":1696074201123},{"_id":"source/_posts/代码随想录算法训练营第五天 242.有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和 。.md","hash":"9969c22501407cab197da7682922aed8fbd205f6","modified":1695650879806},{"_id":"source/_posts/代码随想录算法训练营第四天 24.两两交换链表中的节点、19.删除链表的倒数第N个节点、面试题02.07.链表相交、142.环形链表II。.md","hash":"a7e5090f52690c26aef0aa0b8c84e0267034eac7","modified":1695482493498},{"_id":"source/images/.DS_Store","hash":"454f9987d7ce0626af1bf5ec4d1b27537a748dcd","modified":1697035203587},{"_id":"source/images/160_2.png","hash":"3d3830ce2c2e0944091fe48b20c24654eb0143d9","modified":1695479155340},{"_id":"source/images/160_1.png","hash":"e9db3e4c052ea224f9a661b699f5bb80de937e3b","modified":1695479126871},{"_id":"source/images/160_3.png","hash":"ef60d0dfdd231db0b81d36ee2e3359340ff7a596","modified":1695479177166},{"_id":"source/images/QQ20230923-221152.png","hash":"110563a2562c75533359dc832bcf71ab1cb7d156","modified":1695478324074},{"_id":"source/images/image-20230920153829216.png","hash":"86f2ec92f9ec6370210701ebd7faa8d1a3db7e4d","modified":1695195509217},{"_id":"source/images/image-20230920152855240.png","hash":"ca5682d47af90699a8c373f0f39c81615458f540","modified":1695194935241},{"_id":"source/images/image-20230920152650727.png","hash":"e826a246f6a13fe01f2bfd7c51d4408b327dcda2","modified":1695194810729},{"_id":"source/images/image-20230920140818304.png","hash":"bdfe8feaf3bda356eff067e271baa909f1d2e03c","modified":1695190098306},{"_id":"source/images/反转2(1).png","hash":"5cf84b548e9b4fc37f13e6ebb68cb972e235b61e","modified":1695882972308},{"_id":"source/images/image-20230921130326208.png","hash":"865d4ca858ce0621a307e8d1dc7f5c25155abee9","modified":1695272606210},{"_id":"source/images/字符串移位.png","hash":"97ac8ffdbe481160cd230c45786c0cd7b4da1c15","modified":1695884398794},{"_id":"source/images/反转字符串.png","hash":"dd585da8af1ae7952560ae93abb2f153892d4bfa","modified":1695882502812},{"_id":"source/images/map源码.png","hash":"75e0f8380b27985024419f58e48b09bc1c246bc6","modified":1695654607151},{"_id":"source/images/KMP/.DS_Store","hash":"5c0a439a3a3d180dc6afde5c18833c65ef36d548","modified":1696075520671},{"_id":"source/images/128卡住.png","hash":"9a61aa70b017f4b7d2d05e42b6cd4da2ab3538f1","modified":1695654120359},{"_id":"source/images/6次扩增.png","hash":"d12c74116de8b3f08908decb8855ea21b0ab9723","modified":1695653740769},{"_id":"source/images/26字母.png","hash":"29271a6f5b3e8ce3c1c52c36e2bca476ab262257","modified":1695653163095},{"_id":"source/images/IMG_1373.PNG","hash":"f19763b2036f15bef073a6779603e43690a006d8","modified":1695477277819},{"_id":"source/images/26随机字母报错.png","hash":"376d09c5dcfd15932ce7a5174c3a16e39e8490fc","modified":1695654391249},{"_id":"source/images/IMG_1372.PNG","hash":"7375e14c158d95e0ec6919f6762fa1c04795dc83","modified":1695477306818},{"_id":"source/images/hashST.png","hash":"92bd46ab15de3ac4a65280be6f4d352bb07a68d4","modified":1695651994489},{"_id":"source/images/初步解决.png","hash":"0ec7279cade8f6a28dea8f547defa86b75b46886","modified":1695652590873},{"_id":"source/images/3000多长度.png","hash":"d5a112b8b3478da1ce432aa6d34943ddfa406400","modified":1695653498712},{"_id":"source/images/展示代码.png","hash":"5a52e895d150af19646cb53503bf0bd1216bf8e6","modified":1695654027396},{"_id":"source/images/最后一个127.png","hash":"1f4a817e01a2978270c6ec4785d685e9f4bd13ae","modified":1695654758436},{"_id":"source/images/使用全局变量leetcode.png","hash":"cece39035fc2f5a143ed2679743df9ed000442b6","modified":1695751048583},{"_id":"source/images/KMP/KMPnext1.png","hash":"df1f9b323464e3a639b1073c0825abadbfcd1ae2","modified":1696075325374},{"_id":"source/images/第一个127.png","hash":"fbf9261d722577f156e02cfd1a124259312840c8","modified":1695654746801},{"_id":"source/images/断点调试.png","hash":"fa347933231e862d859626149f887240b2ebe3ec","modified":1695652276547},{"_id":"source/images/KMP/KMPnext4.png","hash":"6890835e6816803519e160ef000060ee7279bd07","modified":1696076553502},{"_id":"source/images/短测试用例.png","hash":"ae307f3a366450efab4e79c9bcca368729169a1c","modified":1695652929890},{"_id":"source/images/KMP/KMPnext2.png","hash":"59487c8f5a8446f4f1bff2c5bc82f6568fa98c89","modified":1696076916822},{"_id":"source/images/KMP/KMPnext5.png","hash":"465847e8e29a4193709c3fd0de6ef7e0de21d906","modified":1696076514316},{"_id":"source/images/KMP/KMPnext6.png","hash":"6b8f9eb866a9539c52c603c2d38a03c53b8c1b78","modified":1696076459147},{"_id":"source/images/KMP/KMP匹配1.png","hash":"9fc08f5dd0fa81de949461215739845e63b1558f","modified":1696068637418},{"_id":"source/images/KMP/KMP匹配11.png","hash":"04c55c8d7f6d4616a2e243c1546ee71d595f88c6","modified":1696069087698},{"_id":"source/images/KMP/KMP匹配10.png","hash":"435fe4c12333dadf7b8fb0ca31ce267682e0d9ec","modified":1696069060772},{"_id":"source/images/KMP/KMP匹配3.png","hash":"4fbc04fc457cdf91703236f5e757650b916e9711","modified":1696068698487},{"_id":"source/images/KMP/KMP匹配12.png","hash":"4d0ea5345a73ed4b9d90701c068c6316714f6a49","modified":1696069205175},{"_id":"source/images/KMP/KMPnext3.png","hash":"9d39b34a42b26f76d3f80eb74487b0f18606df56","modified":1696075820877},{"_id":"source/images/KMP/KMP匹配2.png","hash":"b1cbeafff7d2c41b478a11055c16599f6335d096","modified":1696068669468},{"_id":"source/images/KMP/KMPnext7.png","hash":"72fbb5086a5bcac111f7a305cd1d46c325eedd62","modified":1696076381354},{"_id":"source/images/KMP/KMP匹配4.png","hash":"b51cd76c1a0ed03a98bf49a9c130fd3c1afccbce","modified":1696068739655},{"_id":"source/images/KMP/KMP匹配5.png","hash":"7b5584c8717897ffe8ac094fc729d33de9f42cae","modified":1696068758470},{"_id":"source/images/KMP/KMP匹配7.png","hash":"b6c47ade642d2e6ae1bc90ac7ae71ecc684cdeb8","modified":1696068954161},{"_id":"source/images/KMP/KMP匹配8.png","hash":"6e7c377b27ef6dcff049860ede38ac664942b1d4","modified":1696069002333},{"_id":"source/images/KMP/KMP匹配9.png","hash":"cad99f271af8817ee1bf3de1c0e245ce243c2b44","modified":1696069029980},{"_id":"source/images/IMG_2D422EDB0DFC-1.jpeg","hash":"bfeb9a29caec870c972de6b0b94c578ac28cb2c5","modified":1695477944000},{"_id":"source/images/142_1.jpeg","hash":"3a06e3ec4e13da1586faa781edc623e7a7269372","modified":1695480741000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1695132290000},{"_id":"themes/fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1695132290000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1695132290000},{"_id":"themes/fluid/.DS_Store","hash":"20927a5b314f8087b31dee66a2c8855201ea8148","modified":1695656565243},{"_id":"themes/fluid/package.json","hash":"41983970c0977b3c626c3f1e3c714cf78ac6a04e","modified":1695132290000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1695132290000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1695132290000},{"_id":"themes/fluid/README.md","hash":"088496f29af0e946055ebd781fa312685335139c","modified":1695132290000},{"_id":"themes/fluid/README_en.md","hash":"49541d4ec48c4b517c5b3fe17a2e92d87090d007","modified":1695132290000},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1695132290000},{"_id":"themes/fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1695132290000},{"_id":"themes/fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1695132290000},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1695132290000},{"_id":"themes/fluid/layout/index.ejs","hash":"9b4c154462ce78de4c9ea7dd15dce4ca8e8c1cf8","modified":1695132290000},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1695132290000},{"_id":"themes/fluid/_config.yml","hash":"17101716317566968f77a20c93a0f224dff1b147","modified":1695136568000},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1695132290000},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1695132290000},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1695132290000},{"_id":"themes/fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1695132290000},{"_id":"themes/fluid/layout/post.ejs","hash":"75ab6958d929e92566ca580d0b8bd0eeae10649a","modified":1695132290000},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1695132290000},{"_id":"themes/fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1695132290000},{"_id":"themes/fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1695132290000},{"_id":"themes/fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1695132290000},{"_id":"themes/fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1695132290000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1695132290000},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1695132290000},{"_id":"themes/fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1695132290000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1695132290000},{"_id":"themes/fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1695132290000},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1695132290000},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1695132290000},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1695132290000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"0047666f996c54017e06668b5242ed8a311ebce0","modified":1695132290000},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1695132290000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1695132290000},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1695132290000},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1695132290000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1695132290000},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1695132290000},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1695132290000},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1695132290000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1695132290000},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1695132290000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1695132290000},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1695132290000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":1695132290000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1695132290000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1695132290000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1695132290000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1695132290000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1695132290000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1695132290000},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1695132290000},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1695132290000},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1695132290000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1695132290000},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1695132290000},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1695132290000},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1695132290000},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1695132290000},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1695132290000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1695132290000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1695132290000},{"_id":"themes/fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1695132290000},{"_id":"themes/fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1695132290000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1695132290000},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1695132290000},{"_id":"themes/fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1695132290000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1695132290000},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1695132290000},{"_id":"themes/fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1695132290000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1695132290000},{"_id":"themes/fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1695132290000},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"4f68c80bd1395e2f6d11e373116e54de11cb62e8","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"529f3069742b3d338c769ba2d836e7f3c342a09d","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1695132290000},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1695132290000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1695132290000},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1695132290000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1695132290000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1695132290000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1695132290000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"8d3ae1ec6660fbb0e563bc08c2f8deefde1f3bf6","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1695132290000},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1695132290000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1695132290000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1695132290000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"e413212e5a667d5b8299c4d2a39c4dfa1378d119","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"ecf3488566b374d564ae985c61e08562ba908023","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1695132290000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1695132290000},{"_id":"source/images/java_map_debug.jpg","hash":"02ea44bee15523d5dbebc1de2ec107a7ed6fce1c","modified":1695645182516},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1695132290000},{"_id":"source/images/KMP/next数组构建.mp4","hash":"18d68ce187ed2ddb3176303d44c66c05e35e4082","modified":1696077080077},{"_id":"source/images/KMP/匹配.mp4","hash":"0ef7ddbd6e5310d1be1764496f354ef77b2aed3c","modified":1696070210540},{"_id":"public/local-search.xml","hash":"4787af9f27a39f66799b364b9c11ce385cf64c23","modified":1697122769139},{"_id":"public/archives/index.html","hash":"8c1662e4cd6cccdce9052b1270a3a555bf96b2b1","modified":1697122769139},{"_id":"public/archives/2023/index.html","hash":"97faac015259f7a0eacb3e8b8e9dc9ac1a57bdeb","modified":1697122769139},{"_id":"public/archives/2023/09/index.html","hash":"b1d4f6b98cd6cc3366c1b66c662a918470fcebb6","modified":1697122769139},{"_id":"public/categories/Debug/index.html","hash":"e953223b7a0a165bbc209bf7c26061dda0da9fe6","modified":1696077706934},{"_id":"public/categories/刷题/index.html","hash":"c09495041f4e4c173c08ac0ae4a56e521f81b807","modified":1697122769139},{"_id":"public/categories/搭建环境/index.html","hash":"983140c1e350f69892ce241e3da0b34d24dea15b","modified":1696077706934},{"_id":"public/tags/Debug/index.html","hash":"dc8c55f2a21f3050fb0ca7666091decd35252fd3","modified":1696077706934},{"_id":"public/tags/LeetCode/index.html","hash":"3ca4da2e6840d10ca21134d4414020f456c73439","modified":1697122769139},{"_id":"public/tags/Java/index.html","hash":"515c9770a0b03e2802bb328e4ba35c6596c2aeb7","modified":1696077706934},{"_id":"public/tags/算法/index.html","hash":"1060f02de99d44845e27600e64f1fa54217e1426","modified":1697122769139},{"_id":"public/tags/代码随想录/index.html","hash":"18e6ad4ade5dfff6c3947e07f8fd042eea06e8b4","modified":1697122769139},{"_id":"public/tags/教程/index.html","hash":"6edf9d11ab8e8cb0f8ad1646cd6a79e75a833a46","modified":1696077706934},{"_id":"public/404.html","hash":"8e2e7fbdad623123f803ba1c7f4bf5d5a2cd632d","modified":1696077706934},{"_id":"public/tags/index.html","hash":"de95fcf966632a1b263063d6400f74281a040537","modified":1696336549884},{"_id":"public/post/369230e4.html","hash":"4ed2541feabae3436ba0062e72834936532f5065","modified":1696867904658},{"_id":"public/post/bc862a56.html","hash":"e7c33278a0f7fbd0b5ab5ef9d0f63008f5188d20","modified":1696867904658},{"_id":"public/post/6416b651.html","hash":"ced35866de4ac9fdfe1873a1191a1eea9a49c1e2","modified":1696867904658},{"_id":"public/post/ad5be9d7.html","hash":"525857208a52e6d02f102b85b37d557f029a165f","modified":1696867904658},{"_id":"public/post/20198d61.html","hash":"6761ea93e69b45fb5e09900a6e9dec8296a43ab6","modified":1696867904658},{"_id":"public/post/b4e3c0b1.html","hash":"145891f09607e55e704f09cbf841a13a0478b90e","modified":1696867904658},{"_id":"public/post/bd069431.html","hash":"d3b79386cfdfc6489c8153abb06ba6b5ebcc5594","modified":1696180712773},{"_id":"public/post/b79a1ea.html","hash":"6d86d94c6153256f81a695fea8bca7ecc8f909e4","modified":1696867904658},{"_id":"public/post/7b6fd36a.html","hash":"2cf907660872b21a6232f5230b013f0924a92bdc","modified":1696867904658},{"_id":"public/post/5c83b0d3.html","hash":"a4d1ac20061c43c5b8d8cf0d01bd1a4758e9b963","modified":1696867904658},{"_id":"public/index.html","hash":"7a7c1fa397739c5f0f8ece3ee8042303abe272b5","modified":1697122769139},{"_id":"public/categories/index.html","hash":"1ae99e0a512294e6c97e3960d3040bc2205393d0","modified":1697122769139},{"_id":"public/links/index.html","hash":"781d2f12eec5a1cadbfe5ba1264eeab6c91f1f61","modified":1696077706934},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1696077706934},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1696077706934},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1696077706934},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1696077706934},{"_id":"public/images/160_1.png","hash":"e9db3e4c052ea224f9a661b699f5bb80de937e3b","modified":1696077706934},{"_id":"public/images/160_2.png","hash":"3d3830ce2c2e0944091fe48b20c24654eb0143d9","modified":1696077706934},{"_id":"public/images/160_3.png","hash":"ef60d0dfdd231db0b81d36ee2e3359340ff7a596","modified":1696077706934},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1696077706934},{"_id":"public/images/QQ20230923-221152.png","hash":"110563a2562c75533359dc832bcf71ab1cb7d156","modified":1696077706934},{"_id":"public/images/image-20230920140818304.png","hash":"bdfe8feaf3bda356eff067e271baa909f1d2e03c","modified":1696077706934},{"_id":"public/images/image-20230920152650727.png","hash":"e826a246f6a13fe01f2bfd7c51d4408b327dcda2","modified":1696077706934},{"_id":"public/images/image-20230920152855240.png","hash":"ca5682d47af90699a8c373f0f39c81615458f540","modified":1696077706934},{"_id":"public/images/image-20230920153829216.png","hash":"86f2ec92f9ec6370210701ebd7faa8d1a3db7e4d","modified":1696077706934},{"_id":"public/images/image-20230921130326208.png","hash":"865d4ca858ce0621a307e8d1dc7f5c25155abee9","modified":1696077706934},{"_id":"public/images/map源码.png","hash":"75e0f8380b27985024419f58e48b09bc1c246bc6","modified":1696077706934},{"_id":"public/images/反转字符串.png","hash":"dd585da8af1ae7952560ae93abb2f153892d4bfa","modified":1696077706934},{"_id":"public/images/字符串移位.png","hash":"97ac8ffdbe481160cd230c45786c0cd7b4da1c15","modified":1696077706934},{"_id":"public/images/反转2(1).png","hash":"5cf84b548e9b4fc37f13e6ebb68cb972e235b61e","modified":1696077706934},{"_id":"public/images/128卡住.png","hash":"9a61aa70b017f4b7d2d05e42b6cd4da2ab3538f1","modified":1696077706934},{"_id":"public/images/26字母.png","hash":"29271a6f5b3e8ce3c1c52c36e2bca476ab262257","modified":1696077706934},{"_id":"public/images/26随机字母报错.png","hash":"376d09c5dcfd15932ce7a5174c3a16e39e8490fc","modified":1696077706934},{"_id":"public/images/3000多长度.png","hash":"d5a112b8b3478da1ce432aa6d34943ddfa406400","modified":1696077706934},{"_id":"public/images/6次扩增.png","hash":"d12c74116de8b3f08908decb8855ea21b0ab9723","modified":1696077706934},{"_id":"public/images/IMG_1372.PNG","hash":"7375e14c158d95e0ec6919f6762fa1c04795dc83","modified":1696077706934},{"_id":"public/images/IMG_1373.PNG","hash":"f19763b2036f15bef073a6779603e43690a006d8","modified":1696077706934},{"_id":"public/images/hashST.png","hash":"92bd46ab15de3ac4a65280be6f4d352bb07a68d4","modified":1696077706934},{"_id":"public/images/使用全局变量leetcode.png","hash":"cece39035fc2f5a143ed2679743df9ed000442b6","modified":1696077706934},{"_id":"public/images/初步解决.png","hash":"0ec7279cade8f6a28dea8f547defa86b75b46886","modified":1696077706934},{"_id":"public/images/断点调试.png","hash":"fa347933231e862d859626149f887240b2ebe3ec","modified":1696077706934},{"_id":"public/images/最后一个127.png","hash":"1f4a817e01a2978270c6ec4785d685e9f4bd13ae","modified":1696077706934},{"_id":"public/images/第一个127.png","hash":"fbf9261d722577f156e02cfd1a124259312840c8","modified":1696077706934},{"_id":"public/images/展示代码.png","hash":"5a52e895d150af19646cb53503bf0bd1216bf8e6","modified":1696077706934},{"_id":"public/images/KMP/KMPnext1.png","hash":"df1f9b323464e3a639b1073c0825abadbfcd1ae2","modified":1696077706934},{"_id":"public/images/KMP/KMPnext2.png","hash":"59487c8f5a8446f4f1bff2c5bc82f6568fa98c89","modified":1696077706934},{"_id":"public/images/KMP/KMPnext3.png","hash":"9d39b34a42b26f76d3f80eb74487b0f18606df56","modified":1696077706934},{"_id":"public/images/KMP/KMPnext4.png","hash":"6890835e6816803519e160ef000060ee7279bd07","modified":1696077706934},{"_id":"public/images/KMP/KMPnext5.png","hash":"465847e8e29a4193709c3fd0de6ef7e0de21d906","modified":1696077706934},{"_id":"public/images/短测试用例.png","hash":"ae307f3a366450efab4e79c9bcca368729169a1c","modified":1696077706934},{"_id":"public/images/KMP/KMPnext6.png","hash":"6b8f9eb866a9539c52c603c2d38a03c53b8c1b78","modified":1696077706934},{"_id":"public/images/KMP/KMP匹配1.png","hash":"9fc08f5dd0fa81de949461215739845e63b1558f","modified":1696077706934},{"_id":"public/images/KMP/KMP匹配11.png","hash":"04c55c8d7f6d4616a2e243c1546ee71d595f88c6","modified":1696077706934},{"_id":"public/images/KMP/KMP匹配10.png","hash":"435fe4c12333dadf7b8fb0ca31ce267682e0d9ec","modified":1696077706934},{"_id":"public/images/KMP/KMP匹配12.png","hash":"4d0ea5345a73ed4b9d90701c068c6316714f6a49","modified":1696077706934},{"_id":"public/images/KMP/KMPnext7.png","hash":"72fbb5086a5bcac111f7a305cd1d46c325eedd62","modified":1696077706934},{"_id":"public/images/KMP/KMP匹配2.png","hash":"b1cbeafff7d2c41b478a11055c16599f6335d096","modified":1696077706934},{"_id":"public/images/KMP/KMP匹配3.png","hash":"4fbc04fc457cdf91703236f5e757650b916e9711","modified":1696077706934},{"_id":"public/images/KMP/KMP匹配4.png","hash":"b51cd76c1a0ed03a98bf49a9c130fd3c1afccbce","modified":1696077706934},{"_id":"public/images/KMP/KMP匹配7.png","hash":"b6c47ade642d2e6ae1bc90ac7ae71ecc684cdeb8","modified":1696077706934},{"_id":"public/images/KMP/KMP匹配8.png","hash":"6e7c377b27ef6dcff049860ede38ac664942b1d4","modified":1696077706934},{"_id":"public/images/KMP/KMP匹配9.png","hash":"cad99f271af8817ee1bf3de1c0e245ce243c2b44","modified":1696077706934},{"_id":"public/images/KMP/KMP匹配5.png","hash":"7b5584c8717897ffe8ac094fc729d33de9f42cae","modified":1696077706934},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1696077706934},{"_id":"public/css/highlight-dark.css","hash":"2b0daa6e5343da9dbb26d617d224b8397e48556b","modified":1696077706934},{"_id":"public/css/highlight.css","hash":"0f9a477d33d3b15ebe7e163e756fb7c54c7ded6b","modified":1696077706934},{"_id":"public/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1696077706934},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1696077706934},{"_id":"public/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1696077706934},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1696077706934},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1696077706934},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1696077706934},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1696077706934},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1696077706934},{"_id":"public/css/main.css","hash":"526a4522eb54bb51772f51fb98295dc4fe03429f","modified":1696077706934},{"_id":"public/images/IMG_2D422EDB0DFC-1.jpeg","hash":"bfeb9a29caec870c972de6b0b94c578ac28cb2c5","modified":1696077706934},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1696077706934},{"_id":"public/images/142_1.jpeg","hash":"3a06e3ec4e13da1586faa781edc623e7a7269372","modified":1696077706934},{"_id":"public/images/java_map_debug.jpg","hash":"02ea44bee15523d5dbebc1de2ec107a7ed6fce1c","modified":1696077706934},{"_id":"public/images/KMP/next数组构建.mp4","hash":"18d68ce187ed2ddb3176303d44c66c05e35e4082","modified":1696077706934},{"_id":"public/images/KMP/匹配.mp4","hash":"0ef7ddbd6e5310d1be1764496f354ef77b2aed3c","modified":1696077706934},{"_id":"source/_posts/day01.md","hash":"88cf39d017cae45f0410bc46eaeedb38d371e311","modified":1696419853087},{"_id":"source/_posts/day02.md","hash":"f5c54125e8f4a410a542e321fbee0f49e884985b","modified":1696419853087},{"_id":"source/_posts/day04.md","hash":"50706fccbf3fbe5da43805de9117d122abd095ee","modified":1696419853086},{"_id":"source/_posts/day06.md","hash":"b490761eaff13678c999ccaeb192da8a9e142b53","modified":1696419853086},{"_id":"source/_posts/day03.md","hash":"107f677152d7272d12ba9306625278d2cd1d60c2","modified":1696178926679},{"_id":"source/_posts/day08.md","hash":"e01def5b3b6ed2e215e3c042ad512fa89bf01afb","modified":1696419853085},{"_id":"source/_posts/day07.md","hash":"d8c38046ef4bd36627d414cc7f4c7cee2b1817cb","modified":1696419853085},{"_id":"source/_posts/day09.md","hash":"3fcb8c0b9c0501ba8f25bb4758d2db1138194e20","modified":1696419853085},{"_id":"source/_posts/day10.md","hash":"3d12d19738491b56d8a9f01ff74f78fac8e19ce4","modified":1696180713392},{"_id":"source/images/day01/image-20230920140818304.png","hash":"bdfe8feaf3bda356eff067e271baa909f1d2e03c","modified":1695398735172},{"_id":"source/images/day01/image-20230920152650727.png","hash":"e826a246f6a13fe01f2bfd7c51d4408b327dcda2","modified":1695398735172},{"_id":"source/images/day01/image-20230920152855240.png","hash":"ca5682d47af90699a8c373f0f39c81615458f540","modified":1695398735173},{"_id":"source/images/day01/image-20230920153829216.png","hash":"86f2ec92f9ec6370210701ebd7faa8d1a3db7e4d","modified":1695398735173},{"_id":"source/images/day02/image-20230921130326208.png","hash":"865d4ca858ce0621a307e8d1dc7f5c25155abee9","modified":1695398735174},{"_id":"source/images/day04/160_1.png","hash":"e9db3e4c052ea224f9a661b699f5bb80de937e3b","modified":1696140957211},{"_id":"source/images/day04/160_2.png","hash":"3d3830ce2c2e0944091fe48b20c24654eb0143d9","modified":1696140957212},{"_id":"source/images/day04/160_3.png","hash":"ef60d0dfdd231db0b81d36ee2e3359340ff7a596","modified":1696140957212},{"_id":"source/images/day04/QQ20230923-221152.png","hash":"110563a2562c75533359dc832bcf71ab1cb7d156","modified":1696140957249},{"_id":"source/images/day08/反转2(1).png","hash":"5cf84b548e9b4fc37f13e6ebb68cb972e235b61e","modified":1696140957258},{"_id":"source/images/day08/反转字符串.png","hash":"dd585da8af1ae7952560ae93abb2f153892d4bfa","modified":1696140957258},{"_id":"source/images/day08/字符串移位.png","hash":"97ac8ffdbe481160cd230c45786c0cd7b4da1c15","modified":1696140957259},{"_id":"source/images/【debug】Java中的map比较/map源码.png","hash":"75e0f8380b27985024419f58e48b09bc1c246bc6","modified":1696140957256},{"_id":"source/images/day04/IMG_1373.PNG","hash":"f19763b2036f15bef073a6779603e43690a006d8","modified":1696140957217},{"_id":"source/images/day04/IMG_1372.PNG","hash":"7375e14c158d95e0ec6919f6762fa1c04795dc83","modified":1696140957216},{"_id":"source/images/day09/KMPnext1.png","hash":"df1f9b323464e3a639b1073c0825abadbfcd1ae2","modified":1696140957220},{"_id":"source/images/day09/KMPnext2.png","hash":"59487c8f5a8446f4f1bff2c5bc82f6568fa98c89","modified":1696140957221},{"_id":"source/images/day09/KMPnext4.png","hash":"6890835e6816803519e160ef000060ee7279bd07","modified":1696140957223},{"_id":"source/images/day09/KMPnext3.png","hash":"9d39b34a42b26f76d3f80eb74487b0f18606df56","modified":1696140957222},{"_id":"source/images/day09/KMPnext6.png","hash":"6b8f9eb866a9539c52c603c2d38a03c53b8c1b78","modified":1696140957224},{"_id":"source/images/day09/KMPnext5.png","hash":"465847e8e29a4193709c3fd0de6ef7e0de21d906","modified":1696140957224},{"_id":"source/images/day09/KMPnext7.png","hash":"72fbb5086a5bcac111f7a305cd1d46c325eedd62","modified":1696140957226},{"_id":"source/images/day09/KMP匹配10.png","hash":"435fe4c12333dadf7b8fb0ca31ce267682e0d9ec","modified":1696140957227},{"_id":"source/images/day09/KMP匹配1.png","hash":"9fc08f5dd0fa81de949461215739845e63b1558f","modified":1696140957227},{"_id":"source/images/day09/KMP匹配11.png","hash":"04c55c8d7f6d4616a2e243c1546ee71d595f88c6","modified":1696140957228},{"_id":"source/images/day09/KMP匹配12.png","hash":"4d0ea5345a73ed4b9d90701c068c6316714f6a49","modified":1696140957229},{"_id":"source/images/day09/KMP匹配2.png","hash":"b1cbeafff7d2c41b478a11055c16599f6335d096","modified":1696140957230},{"_id":"source/images/day09/KMP匹配3.png","hash":"4fbc04fc457cdf91703236f5e757650b916e9711","modified":1696140957231},{"_id":"source/images/day09/KMP匹配4.png","hash":"b51cd76c1a0ed03a98bf49a9c130fd3c1afccbce","modified":1696140957231},{"_id":"source/images/day09/KMP匹配5.png","hash":"7b5584c8717897ffe8ac094fc729d33de9f42cae","modified":1696140957232},{"_id":"source/images/day09/KMP匹配7.png","hash":"b6c47ade642d2e6ae1bc90ac7ae71ecc684cdeb8","modified":1696140957233},{"_id":"source/images/day09/KMP匹配9.png","hash":"cad99f271af8817ee1bf3de1c0e245ce243c2b44","modified":1696140957235},{"_id":"source/images/day09/KMP匹配8.png","hash":"6e7c377b27ef6dcff049860ede38ac664942b1d4","modified":1696140957234},{"_id":"source/images/day07/使用全局变量leetcode.png","hash":"cece39035fc2f5a143ed2679743df9ed000442b6","modified":1696140957257},{"_id":"source/images/【debug】Java中的map比较/128卡住.png","hash":"9a61aa70b017f4b7d2d05e42b6cd4da2ab3538f1","modified":1696140957206},{"_id":"source/images/【debug】Java中的map比较/26随机字母报错.png","hash":"376d09c5dcfd15932ce7a5174c3a16e39e8490fc","modified":1696140957213},{"_id":"source/images/【debug】Java中的map比较/26字母.png","hash":"29271a6f5b3e8ce3c1c52c36e2bca476ab262257","modified":1696140957213},{"_id":"source/images/【debug】Java中的map比较/3000多长度.png","hash":"d5a112b8b3478da1ce432aa6d34943ddfa406400","modified":1696140957214},{"_id":"source/images/【debug】Java中的map比较/hashST.png","hash":"92bd46ab15de3ac4a65280be6f4d352bb07a68d4","modified":1696140957250},{"_id":"source/images/【debug】Java中的map比较/6次扩增.png","hash":"d12c74116de8b3f08908decb8855ea21b0ab9723","modified":1696140957215},{"_id":"source/images/【debug】Java中的map比较/初步解决.png","hash":"0ec7279cade8f6a28dea8f547defa86b75b46886","modified":1696140957258},{"_id":"source/images/【debug】Java中的map比较/展示代码.png","hash":"5a52e895d150af19646cb53503bf0bd1216bf8e6","modified":1696140957260},{"_id":"source/images/【debug】Java中的map比较/断点调试.png","hash":"fa347933231e862d859626149f887240b2ebe3ec","modified":1696140957261},{"_id":"source/images/【debug】Java中的map比较/最后一个127.png","hash":"1f4a817e01a2978270c6ec4785d685e9f4bd13ae","modified":1696140957262},{"_id":"source/images/【debug】Java中的map比较/短测试用例.png","hash":"ae307f3a366450efab4e79c9bcca368729169a1c","modified":1696140957262},{"_id":"source/images/【debug】Java中的map比较/第一个127.png","hash":"fbf9261d722577f156e02cfd1a124259312840c8","modified":1696140957263},{"_id":"source/images/day04/IMG_2D422EDB0DFC-1.jpeg","hash":"bfeb9a29caec870c972de6b0b94c578ac28cb2c5","modified":1696140957219},{"_id":"source/images/day04/142_1.jpeg","hash":"3a06e3ec4e13da1586faa781edc623e7a7269372","modified":1696140957211},{"_id":"source/images/【debug】Java中的map比较/java_map_debug.jpg","hash":"02ea44bee15523d5dbebc1de2ec107a7ed6fce1c","modified":1696140957256},{"_id":"source/images/day09/next数组构建.mp4","hash":"18d68ce187ed2ddb3176303d44c66c05e35e4082","modified":1696140957240},{"_id":"source/images/day09/匹配.mp4","hash":"0ef7ddbd6e5310d1be1764496f354ef77b2aed3c","modified":1696140957249},{"_id":"public/archives/page/2/index.html","hash":"8d945125f86c93af89f04a18e1bdf7fc7bde51ad","modified":1697122769139},{"_id":"public/archives/2023/page/2/index.html","hash":"5ce114528dcf5881d3478148a10ce8aedb114dfe","modified":1697122769139},{"_id":"public/archives/2023/10/index.html","hash":"d806a1b886424e27fd9442d1956586fabe3d2790","modified":1697122769139},{"_id":"public/page/2/index.html","hash":"abeda20ce2c6b63e3803b1e32eb38a5920459eaf","modified":1697122769139},{"_id":"public/post/a8d0ca77.html","hash":"df0e3f03453f356ec6736c679c62d5fde97e68ef","modified":1696335335996},{"_id":"public/images/day01/image-20230920140818304.png","hash":"bdfe8feaf3bda356eff067e271baa909f1d2e03c","modified":1696180712773},{"_id":"public/images/day01/image-20230920152855240.png","hash":"ca5682d47af90699a8c373f0f39c81615458f540","modified":1696180712773},{"_id":"public/images/day01/image-20230920152650727.png","hash":"e826a246f6a13fe01f2bfd7c51d4408b327dcda2","modified":1696180712773},{"_id":"public/images/day01/image-20230920153829216.png","hash":"86f2ec92f9ec6370210701ebd7faa8d1a3db7e4d","modified":1696180712773},{"_id":"public/images/day04/160_2.png","hash":"3d3830ce2c2e0944091fe48b20c24654eb0143d9","modified":1696180712773},{"_id":"public/images/day04/160_1.png","hash":"e9db3e4c052ea224f9a661b699f5bb80de937e3b","modified":1696180712773},{"_id":"public/images/day02/image-20230921130326208.png","hash":"865d4ca858ce0621a307e8d1dc7f5c25155abee9","modified":1696180712773},{"_id":"public/images/day04/160_3.png","hash":"ef60d0dfdd231db0b81d36ee2e3359340ff7a596","modified":1696180712773},{"_id":"public/images/day04/QQ20230923-221152.png","hash":"110563a2562c75533359dc832bcf71ab1cb7d156","modified":1696180712773},{"_id":"public/images/day08/反转字符串.png","hash":"dd585da8af1ae7952560ae93abb2f153892d4bfa","modified":1696180712773},{"_id":"public/images/day08/反转2(1).png","hash":"5cf84b548e9b4fc37f13e6ebb68cb972e235b61e","modified":1696180712773},{"_id":"public/images/day08/字符串移位.png","hash":"97ac8ffdbe481160cd230c45786c0cd7b4da1c15","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/map源码.png","hash":"75e0f8380b27985024419f58e48b09bc1c246bc6","modified":1696180712773},{"_id":"public/images/day04/IMG_1372.PNG","hash":"7375e14c158d95e0ec6919f6762fa1c04795dc83","modified":1696180712773},{"_id":"public/images/day09/KMPnext1.png","hash":"df1f9b323464e3a639b1073c0825abadbfcd1ae2","modified":1696180712773},{"_id":"public/images/day09/KMPnext4.png","hash":"6890835e6816803519e160ef000060ee7279bd07","modified":1696180712773},{"_id":"public/images/day09/KMPnext2.png","hash":"59487c8f5a8446f4f1bff2c5bc82f6568fa98c89","modified":1696180712773},{"_id":"public/images/day04/IMG_1373.PNG","hash":"f19763b2036f15bef073a6779603e43690a006d8","modified":1696180712773},{"_id":"public/images/day09/KMPnext3.png","hash":"9d39b34a42b26f76d3f80eb74487b0f18606df56","modified":1696180712773},{"_id":"public/images/day09/KMPnext5.png","hash":"465847e8e29a4193709c3fd0de6ef7e0de21d906","modified":1696180712773},{"_id":"public/images/day09/KMPnext6.png","hash":"6b8f9eb866a9539c52c603c2d38a03c53b8c1b78","modified":1696180712773},{"_id":"public/images/day09/KMP匹配11.png","hash":"04c55c8d7f6d4616a2e243c1546ee71d595f88c6","modified":1696180712773},{"_id":"public/images/day09/KMP匹配1.png","hash":"9fc08f5dd0fa81de949461215739845e63b1558f","modified":1696180712773},{"_id":"public/images/day09/KMP匹配10.png","hash":"435fe4c12333dadf7b8fb0ca31ce267682e0d9ec","modified":1696180712773},{"_id":"public/images/day09/KMP匹配12.png","hash":"4d0ea5345a73ed4b9d90701c068c6316714f6a49","modified":1696180712773},{"_id":"public/images/day09/KMPnext7.png","hash":"72fbb5086a5bcac111f7a305cd1d46c325eedd62","modified":1696180712773},{"_id":"public/images/day09/KMP匹配4.png","hash":"b51cd76c1a0ed03a98bf49a9c130fd3c1afccbce","modified":1696180712773},{"_id":"public/images/day09/KMP匹配2.png","hash":"b1cbeafff7d2c41b478a11055c16599f6335d096","modified":1696180712773},{"_id":"public/images/day09/KMP匹配3.png","hash":"4fbc04fc457cdf91703236f5e757650b916e9711","modified":1696180712773},{"_id":"public/images/day09/KMP匹配5.png","hash":"7b5584c8717897ffe8ac094fc729d33de9f42cae","modified":1696180712773},{"_id":"public/images/day09/KMP匹配7.png","hash":"b6c47ade642d2e6ae1bc90ac7ae71ecc684cdeb8","modified":1696180712773},{"_id":"public/images/day09/KMP匹配8.png","hash":"6e7c377b27ef6dcff049860ede38ac664942b1d4","modified":1696180712773},{"_id":"public/images/day09/KMP匹配9.png","hash":"cad99f271af8817ee1bf3de1c0e245ce243c2b44","modified":1696180712773},{"_id":"public/images/day07/使用全局变量leetcode.png","hash":"cece39035fc2f5a143ed2679743df9ed000442b6","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/128卡住.png","hash":"9a61aa70b017f4b7d2d05e42b6cd4da2ab3538f1","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/26随机字母报错.png","hash":"376d09c5dcfd15932ce7a5174c3a16e39e8490fc","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/26字母.png","hash":"29271a6f5b3e8ce3c1c52c36e2bca476ab262257","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/hashST.png","hash":"92bd46ab15de3ac4a65280be6f4d352bb07a68d4","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/3000多长度.png","hash":"d5a112b8b3478da1ce432aa6d34943ddfa406400","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/6次扩增.png","hash":"d12c74116de8b3f08908decb8855ea21b0ab9723","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/初步解决.png","hash":"0ec7279cade8f6a28dea8f547defa86b75b46886","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/断点调试.png","hash":"fa347933231e862d859626149f887240b2ebe3ec","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/展示代码.png","hash":"5a52e895d150af19646cb53503bf0bd1216bf8e6","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/最后一个127.png","hash":"1f4a817e01a2978270c6ec4785d685e9f4bd13ae","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/第一个127.png","hash":"fbf9261d722577f156e02cfd1a124259312840c8","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/短测试用例.png","hash":"ae307f3a366450efab4e79c9bcca368729169a1c","modified":1696180712773},{"_id":"public/images/day04/IMG_2D422EDB0DFC-1.jpeg","hash":"bfeb9a29caec870c972de6b0b94c578ac28cb2c5","modified":1696180712773},{"_id":"public/images/day04/142_1.jpeg","hash":"3a06e3ec4e13da1586faa781edc623e7a7269372","modified":1696180712773},{"_id":"public/images/【debug】Java中的map比较/java_map_debug.jpg","hash":"02ea44bee15523d5dbebc1de2ec107a7ed6fce1c","modified":1696180712773},{"_id":"public/images/day09/next数组构建.mp4","hash":"18d68ce187ed2ddb3176303d44c66c05e35e4082","modified":1696180712773},{"_id":"public/images/day09/匹配.mp4","hash":"0ef7ddbd6e5310d1be1764496f354ef77b2aed3c","modified":1696180712773},{"_id":"source/_posts/day11.md","hash":"7890ad73eff3df8fd5a2ccb951b59d1acfc8b3dd","modified":1696335336432},{"_id":"public/tags/LeetCode/page/2/index.html","hash":"1ad81e35a9f1860c573d946ceccfa3aa5aca1f1c","modified":1697122769139},{"_id":"public/post/bdbe1e6e.html","hash":"67f4a6f2f24249f35638ed0bc2c39a2806b49aee","modified":1696336549884},{"_id":"source/_posts/【study】Leetcode中Go语言第三方包.md","hash":"943bae0c6dbc465e3c404987392853a9c43cba0e","modified":1696336550313},{"_id":"source/images/【study】Leetcode中Go语言第三方包/Leetcode中的Go.png","hash":"f7b377f923eec20ff8398061a6c83ca3c90fc66e","modified":1696335778050},{"_id":"source/images/【study】Leetcode中Go语言第三方包/Leetcode支持Go的第三方库.png","hash":"b80cd26fa2d187d573349ee1fa6599add2ae77a1","modified":1696335887692},{"_id":"public/categories/Study/index.html","hash":"d4a42f13f6b6ecbf1f06200dec9862c7c786144d","modified":1696336549884},{"_id":"public/tags/Study/index.html","hash":"1e4e2db25e10a0bda9435f006377b9459e7cd3e5","modified":1696336549884},{"_id":"public/tags/Go/index.html","hash":"0f35d3064025ccec1809ae4e363a5b6ff7e0d9fa","modified":1696336549884},{"_id":"public/post/2360e101.html","hash":"7ba6ae013f1cb5b2be9d85e26cffcf9d80c45407","modified":1696437004676},{"_id":"public/images/【study】Leetcode中Go语言第三方包/Leetcode中的Go.png","hash":"f7b377f923eec20ff8398061a6c83ca3c90fc66e","modified":1696336549884},{"_id":"public/images/【study】Leetcode中Go语言第三方包/Leetcode支持Go的第三方库.png","hash":"b80cd26fa2d187d573349ee1fa6599add2ae77a1","modified":1696336549884},{"_id":"source/_posts/day12.md","hash":"fb008fe0dd3aed2146bfd61ee7022b825a942dca","modified":1696437005000},{"_id":"public/categories/刷题/page/2/index.html","hash":"9197160466b0aa2492ad75933290c99558ad2965","modified":1697122769139},{"_id":"public/tags/算法/page/2/index.html","hash":"07f55d97e08583d5437d3fab017f2122d657c073","modified":1697122769139},{"_id":"public/tags/代码随想录/page/2/index.html","hash":"780b287744d9320e04c9ecc324fd6f99a910dc6d","modified":1697122769139},{"_id":"public/post/9ab3b9d2.html","hash":"b2e20182a44e6c22fbc222035515f3cf22c2f37a","modified":1696867904658},{"_id":"source/_posts/day13.md","hash":"e2c1c7bc877dc5b232cd8e78db7c431f10fa1e42","modified":1696591399009},{"_id":"public/post/5d0ef500.html","hash":"6cf3ea89fb9ae5f091633d9014101db508ec8fa0","modified":1696867904658},{"_id":"source/_posts/day14.md","hash":"62140ac78bbfb27db11169a4cb794027a279611f","modified":1696688890169},{"_id":"source/_posts/day15.md","hash":"4e6e59a209345878fa87151e7af3ef830363770a","modified":1696691616374},{"_id":"public/post/e1408dd4.html","hash":"ec08e4b806e437b6a3e4d5a6111e540e7520a1e7","modified":1696691482674},{"_id":"public/post/e2c426b8.html","hash":"0045dba58b96e731e5a23841e7341d6ded61d359","modified":1696867904658},{"_id":"source/_posts/day17.md","hash":"1d2d9435b05c162955f848d9fa9cf88b59af93c1","modified":1696867904947},{"_id":"public/post/467977b0.html","hash":"8b2d76eb8777af87352f98719963c0c8aca492aa","modified":1697122769139},{"_id":"source/_posts/day18.md","hash":"d7161704f2c9a2d1777c9802f6ade3917539fcda","modified":1697121570845},{"_id":"source/images/day18/.DS_Store","hash":"3035b21efabbc5eb7c539244c50c4b32c5102216","modified":1697036112435},{"_id":"source/images/day18/中序后序建立树.mov","hash":"550ebe936321746f80603b44fff12ff917c7baa6","modified":1697034486221},{"_id":"public/post/de527742.html","hash":"b9defa398ea21887bc89ccc48bc0d44fb4e0aabc","modified":1697122769139},{"_id":"public/images/day18/中序后序建立树.mov","hash":"550ebe936321746f80603b44fff12ff917c7baa6","modified":1697034883857},{"_id":"source/images/day18/力扣106.mp4","hash":"7d574ddab9e644920ca886d9f0cada53285c1330","modified":1697035177340},{"_id":"public/images/day18/力扣106.mp4","hash":"7d574ddab9e644920ca886d9f0cada53285c1330","modified":1697035242031},{"_id":"source/_posts/day19.md","hash":"ea51a7d216d6924f643d2836efb81a8e3e15d033","modified":1697122762077},{"_id":"public/post/38d5093a.html","hash":"9c87d8070f528131bec4a5c802aad0d34ee68e47","modified":1697122769139}],"Category":[{"name":"Debug","_id":"cln60vijy0002wvz81lsohve1"},{"name":"刷题","_id":"cln60vik10007wvz86q5h7fvk"},{"name":"搭建环境","_id":"cln60vik5000swvz8flt6ccdq"},{"name":"Study","_id":"clnaazf5i0001r4whe4qy94nz"}],"Data":[],"Page":[],"Post":[{"title":"【debug】Java中的map比较","abbrlink":"ad5be9d7","date":"2023-09-25T14:10:40.000Z","_content":"\n# 【debug】Java中的map比较\n\n题目链接：[242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)\n\n事情起因：（由于自己对Java了解不深、有表达错误的请指出，感谢！）\n\n<img src=\"../images/【debug】Java中的map比较/java_map_debug.jpg\" alt=\"报错截图\" style=\"zoom:100%;\" />\n\n\n\n群友发了一张代码截图，觉得自己写的代码并没有错，但是不能通过测试用例。\n\n他的算法我简单说一下，有点麻烦，但算法不是这篇博客的重点。\n\n1.   两个Map：`hashS`、`hashT`分别用于存放字符串`s`和`t`中字母出现的频率(19行之前)；\n2.   遍历长的字符串对应的Map，假设是`hashS`，判断`hashS`与`hashT`相同的字母频率是否一样，如果不一样则`return false`\n\n当时我是在外面，看到了这段代码，理解了他的想法之后好像真的没什么问题。\n\n\n\n### 复现Bug与初步解决\n\n回来之后代码放到idea里面跑了一下，发现这个测试用例长度为50000位，而且每个字母出现的频率是一样的\n\n<img src=\"../images/【debug】Java中的map比较/hashST.png\" alt=\"两个Map的内容\" style=\"zoom:67%;\" />\n\n\n\n打上断点继续向下走，看看是哪一步出现了问题。\n\n<img src=\"../images/【debug】Java中的map比较/断点调试.png\" alt=\"断点调试\" style=\"zoom:67%;\" />\n\n\n\n没想到第一次循环就出错了，`hashT.get(c)`与`hashS.get(c)`的值都是1913，但是地址不一样，一个是`{Integer@531}`，一个是`{Integer@587}`。看来这里的`!=`判断的是地址而不是值，使用`equal()`方法即可，如下：\n\n<img src=\"../images/【debug】Java中的map比较/初步解决.png\" alt=\"初步解决\" style=\"zoom:67%;\" />\n\n\n\n### 深层探索\n\n事情并没有真正的解决，既然群友能通过一些测试用例，说明了一些情况使用`!=`是可以用的，那几个测试用例都是用了很短的字符串，我也看下是什么情况，`s=\"anagram\"`，`t=\"nagaram\"`，这是个正确的用例，debug的结果是这样\n\n<img src=\"../images/【debug】Java中的map比较/短测试用例.png\" alt=\"短测试用例\" style=\"zoom:80%;\" />\n\n\n\n这可就是玄学了呀，短的数据不会出现问题，而长的会出现。\n\n#### 猜想一：与Map的大小有关\n\n因为长的测试用例有26个键值对（每个字母均出现），而短的只出现了5个字母。我设置测试用例`s = t = \"abcdefghijklmnopqrstuvwxyz\"`（以下简称字母表），让每个字母都出现一次。\n\n<img src=\"../images/【debug】Java中的map比较/26字母.png\" alt=\"26字母\" style=\"zoom:80%;\" />\n\n\n\n还是正常的，<font color=\"#ff0000\">猜想错误</font>\n\n#### 猜想二：与测试用例的长度有关\n\n接着我就多复制些字母表，出错误的是在50000的长度，我把字母表长度先放到3000多，\n\n``` java\n// 扩增字符串代码代码\nString s = \"abcdefghijklmnopqrstuvwxyz\";\nString t = \"abcdefghijklmnopqrstuvwxyz\";\nfor (int i = 0; i < 7; i++) {\n    s += s;\n    t += t;\n}\n```\n\n\n\n<img src=\"../images/【debug】Java中的map比较/3000多长度.png\" alt=\"长度为3328\" style=\"zoom:80%;\" />\n\n\n\n还是有错误，继续缩短长度，将扩增代码循环6次，减少一次再看看\n\n<img src=\"../images/【debug】Java中的map比较/6次扩增.png\" alt=\"6次扩增\" style=\"zoom:80%;\" />\n\n\n\n这次竟然又不出错了，玄学！妥妥的玄学！\n\n我换了种思路，这次不用字母表了，只是用一个变量看看会不会触发这个BUG，如果依然触发，每次长度增加1，那么很快就会得到到底在多长的时候会出现。25行打上断点，被执行前一定会卡住。\n\n<img src=\"../images/【debug】Java中的map比较/展示代码.png\" alt=\"展示代码\" style=\"zoom:80%;\" />\n\n\n\n<img src=\"../images/【debug】Java中的map比较/128卡住.png\" alt=\"字母a出现了128次时候开始报错\" style=\"zoom:80%;\" />\n\n\n\n最后做一次验证，是不是Map中，只要有val超过128就会发生地址改变的情况。这次的测试用例使用随机字母\n\n``` java\nString s = \"\";\nString t = \"\";\nRandom random = new Random();\nwhile (true) {\n    int temp = random.nextInt(26) + 97;\n    s += (char)temp;\n    t += (char)temp;\n    System.out.println(isAnagram(s, t));\n}\n```\n\n<img src=\"../images/【debug】Java中的map比较/26随机字母报错.png\" alt=\"字母a出现了128次的时候开始报错\" style=\"zoom:80%\"/>\n\n\n\n\n很好！当字母w出现了超过128次时候地址发生了变化。128这个数字相信大家一定很敏感，那么这个范围很可能是[-128, 127]。那么则需要看看底层源码是怎么说的，去看看`Map.java`，搜索`127`，并没有发现相关说明。\n\n<img src=\"../images/【debug】Java中的map比较/map源码.png\" alt=\"map源码\" style=\"zoom:80%;\" />\n\n\n\n`{Integer@***}`这里面经常变得数字就是星号部分，那么去`Ieteger.java`里面看看有什么发现。\n\n<img src=\"../images/【debug】Java中的map比较/第一个127.png\" alt=\"搜索结果1\" style=\"zoom:80%;\" />\n\n\n\n<img src=\"../images/【debug】Java中的map比较/最后一个127.png\" alt=\"搜索结果2\" style=\"zoom:80%;\" />\n\n\n\n### 结论\n\n结合这两段我悟了，果然有这么个范围，在初始化值的时候，[-128, 127]这个范围的数是在缓存里面，所以当`Map`中的`value`小于128时候读取的是缓存中的数，所以他们地址是一样的，也就是`hashS.get(c)==hashT.get(c)`的原因。当超过这个范围，则会在新的地方存放一个值，尽管`hashS.get(c)`和`hashT.get(c)`均为128，但是使用`==`或`!=`判断的时候，判断的是**地址**，得到`hashS.get(c)!=hashT.get(c)`。\n\n#### 所以一定要写equal()方法进行判断\n\n#### 所以一定要写equal()方法进行判断\n\n#### 所以一定要写equal()方法进行判断\n\n`hashS.get(c).equal(hashT.get(c))`，这样判断的才是值而不是地址\n\n\n\n","source":"_posts/【debug】Java中的map比较.md","raw":"---\ntitle: 【debug】Java中的map比较\ntags:\n  - Debug\n  - LeetCode\n  - Java\ncategories: Debug\nabbrlink: ad5be9d7\ndate: 2023-09-25 22:10:40\n---\n\n# 【debug】Java中的map比较\n\n题目链接：[242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)\n\n事情起因：（由于自己对Java了解不深、有表达错误的请指出，感谢！）\n\n<img src=\"../images/【debug】Java中的map比较/java_map_debug.jpg\" alt=\"报错截图\" style=\"zoom:100%;\" />\n\n\n\n群友发了一张代码截图，觉得自己写的代码并没有错，但是不能通过测试用例。\n\n他的算法我简单说一下，有点麻烦，但算法不是这篇博客的重点。\n\n1.   两个Map：`hashS`、`hashT`分别用于存放字符串`s`和`t`中字母出现的频率(19行之前)；\n2.   遍历长的字符串对应的Map，假设是`hashS`，判断`hashS`与`hashT`相同的字母频率是否一样，如果不一样则`return false`\n\n当时我是在外面，看到了这段代码，理解了他的想法之后好像真的没什么问题。\n\n\n\n### 复现Bug与初步解决\n\n回来之后代码放到idea里面跑了一下，发现这个测试用例长度为50000位，而且每个字母出现的频率是一样的\n\n<img src=\"../images/【debug】Java中的map比较/hashST.png\" alt=\"两个Map的内容\" style=\"zoom:67%;\" />\n\n\n\n打上断点继续向下走，看看是哪一步出现了问题。\n\n<img src=\"../images/【debug】Java中的map比较/断点调试.png\" alt=\"断点调试\" style=\"zoom:67%;\" />\n\n\n\n没想到第一次循环就出错了，`hashT.get(c)`与`hashS.get(c)`的值都是1913，但是地址不一样，一个是`{Integer@531}`，一个是`{Integer@587}`。看来这里的`!=`判断的是地址而不是值，使用`equal()`方法即可，如下：\n\n<img src=\"../images/【debug】Java中的map比较/初步解决.png\" alt=\"初步解决\" style=\"zoom:67%;\" />\n\n\n\n### 深层探索\n\n事情并没有真正的解决，既然群友能通过一些测试用例，说明了一些情况使用`!=`是可以用的，那几个测试用例都是用了很短的字符串，我也看下是什么情况，`s=\"anagram\"`，`t=\"nagaram\"`，这是个正确的用例，debug的结果是这样\n\n<img src=\"../images/【debug】Java中的map比较/短测试用例.png\" alt=\"短测试用例\" style=\"zoom:80%;\" />\n\n\n\n这可就是玄学了呀，短的数据不会出现问题，而长的会出现。\n\n#### 猜想一：与Map的大小有关\n\n因为长的测试用例有26个键值对（每个字母均出现），而短的只出现了5个字母。我设置测试用例`s = t = \"abcdefghijklmnopqrstuvwxyz\"`（以下简称字母表），让每个字母都出现一次。\n\n<img src=\"../images/【debug】Java中的map比较/26字母.png\" alt=\"26字母\" style=\"zoom:80%;\" />\n\n\n\n还是正常的，<font color=\"#ff0000\">猜想错误</font>\n\n#### 猜想二：与测试用例的长度有关\n\n接着我就多复制些字母表，出错误的是在50000的长度，我把字母表长度先放到3000多，\n\n``` java\n// 扩增字符串代码代码\nString s = \"abcdefghijklmnopqrstuvwxyz\";\nString t = \"abcdefghijklmnopqrstuvwxyz\";\nfor (int i = 0; i < 7; i++) {\n    s += s;\n    t += t;\n}\n```\n\n\n\n<img src=\"../images/【debug】Java中的map比较/3000多长度.png\" alt=\"长度为3328\" style=\"zoom:80%;\" />\n\n\n\n还是有错误，继续缩短长度，将扩增代码循环6次，减少一次再看看\n\n<img src=\"../images/【debug】Java中的map比较/6次扩增.png\" alt=\"6次扩增\" style=\"zoom:80%;\" />\n\n\n\n这次竟然又不出错了，玄学！妥妥的玄学！\n\n我换了种思路，这次不用字母表了，只是用一个变量看看会不会触发这个BUG，如果依然触发，每次长度增加1，那么很快就会得到到底在多长的时候会出现。25行打上断点，被执行前一定会卡住。\n\n<img src=\"../images/【debug】Java中的map比较/展示代码.png\" alt=\"展示代码\" style=\"zoom:80%;\" />\n\n\n\n<img src=\"../images/【debug】Java中的map比较/128卡住.png\" alt=\"字母a出现了128次时候开始报错\" style=\"zoom:80%;\" />\n\n\n\n最后做一次验证，是不是Map中，只要有val超过128就会发生地址改变的情况。这次的测试用例使用随机字母\n\n``` java\nString s = \"\";\nString t = \"\";\nRandom random = new Random();\nwhile (true) {\n    int temp = random.nextInt(26) + 97;\n    s += (char)temp;\n    t += (char)temp;\n    System.out.println(isAnagram(s, t));\n}\n```\n\n<img src=\"../images/【debug】Java中的map比较/26随机字母报错.png\" alt=\"字母a出现了128次的时候开始报错\" style=\"zoom:80%\"/>\n\n\n\n\n很好！当字母w出现了超过128次时候地址发生了变化。128这个数字相信大家一定很敏感，那么这个范围很可能是[-128, 127]。那么则需要看看底层源码是怎么说的，去看看`Map.java`，搜索`127`，并没有发现相关说明。\n\n<img src=\"../images/【debug】Java中的map比较/map源码.png\" alt=\"map源码\" style=\"zoom:80%;\" />\n\n\n\n`{Integer@***}`这里面经常变得数字就是星号部分，那么去`Ieteger.java`里面看看有什么发现。\n\n<img src=\"../images/【debug】Java中的map比较/第一个127.png\" alt=\"搜索结果1\" style=\"zoom:80%;\" />\n\n\n\n<img src=\"../images/【debug】Java中的map比较/最后一个127.png\" alt=\"搜索结果2\" style=\"zoom:80%;\" />\n\n\n\n### 结论\n\n结合这两段我悟了，果然有这么个范围，在初始化值的时候，[-128, 127]这个范围的数是在缓存里面，所以当`Map`中的`value`小于128时候读取的是缓存中的数，所以他们地址是一样的，也就是`hashS.get(c)==hashT.get(c)`的原因。当超过这个范围，则会在新的地方存放一个值，尽管`hashS.get(c)`和`hashT.get(c)`均为128，但是使用`==`或`!=`判断的时候，判断的是**地址**，得到`hashS.get(c)!=hashT.get(c)`。\n\n#### 所以一定要写equal()方法进行判断\n\n#### 所以一定要写equal()方法进行判断\n\n#### 所以一定要写equal()方法进行判断\n\n`hashS.get(c).equal(hashT.get(c))`，这样判断的才是值而不是地址\n\n\n\n","slug":"【debug】Java中的map比较","published":1,"updated":"2023-10-04T11:44:12.879Z","_id":"cln60vijt0000wvz8e7d7cupe","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"【debug】Java中的map比较\"><a href=\"#【debug】Java中的map比较\" class=\"headerlink\" title=\"【debug】Java中的map比较\"></a>【debug】Java中的map比较</h1><p>题目链接：<a href=\"https://leetcode.cn/problems/valid-anagram/\">242. 有效的字母异位词</a></p>\n<p>事情起因：（由于自己对Java了解不深、有表达错误的请指出，感谢！）</p>\n<img src=\"../images/【debug】Java中的map比较/java_map_debug.jpg\" alt=\"报错截图\" style=\"zoom:100%;\" />\n\n\n\n<p>群友发了一张代码截图，觉得自己写的代码并没有错，但是不能通过测试用例。</p>\n<p>他的算法我简单说一下，有点麻烦，但算法不是这篇博客的重点。</p>\n<ol>\n<li>两个Map：<code>hashS</code>、<code>hashT</code>分别用于存放字符串<code>s</code>和<code>t</code>中字母出现的频率(19行之前)；</li>\n<li>遍历长的字符串对应的Map，假设是<code>hashS</code>，判断<code>hashS</code>与<code>hashT</code>相同的字母频率是否一样，如果不一样则<code>return false</code></li>\n</ol>\n<p>当时我是在外面，看到了这段代码，理解了他的想法之后好像真的没什么问题。</p>\n<h3 id=\"复现Bug与初步解决\"><a href=\"#复现Bug与初步解决\" class=\"headerlink\" title=\"复现Bug与初步解决\"></a>复现Bug与初步解决</h3><p>回来之后代码放到idea里面跑了一下，发现这个测试用例长度为50000位，而且每个字母出现的频率是一样的</p>\n<img src=\"../images/【debug】Java中的map比较/hashST.png\" alt=\"两个Map的内容\" style=\"zoom:67%;\" />\n\n\n\n<p>打上断点继续向下走，看看是哪一步出现了问题。</p>\n<img src=\"../images/【debug】Java中的map比较/断点调试.png\" alt=\"断点调试\" style=\"zoom:67%;\" />\n\n\n\n<p>没想到第一次循环就出错了，<code>hashT.get(c)</code>与<code>hashS.get(c)</code>的值都是1913，但是地址不一样，一个是<code>&#123;Integer@531&#125;</code>，一个是<code>&#123;Integer@587&#125;</code>。看来这里的<code>!=</code>判断的是地址而不是值，使用<code>equal()</code>方法即可，如下：</p>\n<img src=\"../images/【debug】Java中的map比较/初步解决.png\" alt=\"初步解决\" style=\"zoom:67%;\" />\n\n\n\n<h3 id=\"深层探索\"><a href=\"#深层探索\" class=\"headerlink\" title=\"深层探索\"></a>深层探索</h3><p>事情并没有真正的解决，既然群友能通过一些测试用例，说明了一些情况使用<code>!=</code>是可以用的，那几个测试用例都是用了很短的字符串，我也看下是什么情况，<code>s=&quot;anagram&quot;</code>，<code>t=&quot;nagaram&quot;</code>，这是个正确的用例，debug的结果是这样</p>\n<img src=\"../images/【debug】Java中的map比较/短测试用例.png\" alt=\"短测试用例\" style=\"zoom:80%;\" />\n\n\n\n<p>这可就是玄学了呀，短的数据不会出现问题，而长的会出现。</p>\n<h4 id=\"猜想一：与Map的大小有关\"><a href=\"#猜想一：与Map的大小有关\" class=\"headerlink\" title=\"猜想一：与Map的大小有关\"></a>猜想一：与Map的大小有关</h4><p>因为长的测试用例有26个键值对（每个字母均出现），而短的只出现了5个字母。我设置测试用例<code>s = t = &quot;abcdefghijklmnopqrstuvwxyz&quot;</code>（以下简称字母表），让每个字母都出现一次。</p>\n<img src=\"../images/【debug】Java中的map比较/26字母.png\" alt=\"26字母\" style=\"zoom:80%;\" />\n\n\n\n<p>还是正常的，<font color=\"#ff0000\">猜想错误</font></p>\n<h4 id=\"猜想二：与测试用例的长度有关\"><a href=\"#猜想二：与测试用例的长度有关\" class=\"headerlink\" title=\"猜想二：与测试用例的长度有关\"></a>猜想二：与测试用例的长度有关</h4><p>接着我就多复制些字母表，出错误的是在50000的长度，我把字母表长度先放到3000多，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 扩增字符串代码代码</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">t</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">7</span>; i++) &#123;<br>    s += s;<br>    t += t;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<img src=\"../images/【debug】Java中的map比较/3000多长度.png\" alt=\"长度为3328\" style=\"zoom:80%;\" />\n\n\n\n<p>还是有错误，继续缩短长度，将扩增代码循环6次，减少一次再看看</p>\n<img src=\"../images/【debug】Java中的map比较/6次扩增.png\" alt=\"6次扩增\" style=\"zoom:80%;\" />\n\n\n\n<p>这次竟然又不出错了，玄学！妥妥的玄学！</p>\n<p>我换了种思路，这次不用字母表了，只是用一个变量看看会不会触发这个BUG，如果依然触发，每次长度增加1，那么很快就会得到到底在多长的时候会出现。25行打上断点，被执行前一定会卡住。</p>\n<img src=\"../images/【debug】Java中的map比较/展示代码.png\" alt=\"展示代码\" style=\"zoom:80%;\" />\n\n\n\n<img src=\"../images/【debug】Java中的map比较/128卡住.png\" alt=\"字母a出现了128次时候开始报错\" style=\"zoom:80%;\" />\n\n\n\n<p>最后做一次验证，是不是Map中，只要有val超过128就会发生地址改变的情况。这次的测试用例使用随机字母</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">t</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br><span class=\"hljs-type\">Random</span> <span class=\"hljs-variable\">random</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>();<br><span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> random.nextInt(<span class=\"hljs-number\">26</span>) + <span class=\"hljs-number\">97</span>;<br>    s += (<span class=\"hljs-type\">char</span>)temp;<br>    t += (<span class=\"hljs-type\">char</span>)temp;<br>    System.out.println(isAnagram(s, t));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<img src=\"../images/【debug】Java中的map比较/26随机字母报错.png\" alt=\"字母a出现了128次的时候开始报错\" style=\"zoom:80%\"/>\n\n\n\n\n<p>很好！当字母w出现了超过128次时候地址发生了变化。128这个数字相信大家一定很敏感，那么这个范围很可能是[-128, 127]。那么则需要看看底层源码是怎么说的，去看看<code>Map.java</code>，搜索<code>127</code>，并没有发现相关说明。</p>\n<img src=\"../images/【debug】Java中的map比较/map源码.png\" alt=\"map源码\" style=\"zoom:80%;\" />\n\n\n\n<p><code>&#123;Integer@***&#125;</code>这里面经常变得数字就是星号部分，那么去<code>Ieteger.java</code>里面看看有什么发现。</p>\n<img src=\"../images/【debug】Java中的map比较/第一个127.png\" alt=\"搜索结果1\" style=\"zoom:80%;\" />\n\n\n\n<img src=\"../images/【debug】Java中的map比较/最后一个127.png\" alt=\"搜索结果2\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>结合这两段我悟了，果然有这么个范围，在初始化值的时候，[-128, 127]这个范围的数是在缓存里面，所以当<code>Map</code>中的<code>value</code>小于128时候读取的是缓存中的数，所以他们地址是一样的，也就是<code>hashS.get(c)==hashT.get(c)</code>的原因。当超过这个范围，则会在新的地方存放一个值，尽管<code>hashS.get(c)</code>和<code>hashT.get(c)</code>均为128，但是使用<code>==</code>或<code>!=</code>判断的时候，判断的是<strong>地址</strong>，得到<code>hashS.get(c)!=hashT.get(c)</code>。</p>\n<h4 id=\"所以一定要写equal-方法进行判断\"><a href=\"#所以一定要写equal-方法进行判断\" class=\"headerlink\" title=\"所以一定要写equal()方法进行判断\"></a>所以一定要写equal()方法进行判断</h4><h4 id=\"所以一定要写equal-方法进行判断-1\"><a href=\"#所以一定要写equal-方法进行判断-1\" class=\"headerlink\" title=\"所以一定要写equal()方法进行判断\"></a>所以一定要写equal()方法进行判断</h4><h4 id=\"所以一定要写equal-方法进行判断-2\"><a href=\"#所以一定要写equal-方法进行判断-2\" class=\"headerlink\" title=\"所以一定要写equal()方法进行判断\"></a>所以一定要写equal()方法进行判断</h4><p><code>hashS.get(c).equal(hashT.get(c))</code>，这样判断的才是值而不是地址</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"【debug】Java中的map比较\"><a href=\"#【debug】Java中的map比较\" class=\"headerlink\" title=\"【debug】Java中的map比较\"></a>【debug】Java中的map比较</h1><p>题目链接：<a href=\"https://leetcode.cn/problems/valid-anagram/\">242. 有效的字母异位词</a></p>\n<p>事情起因：（由于自己对Java了解不深、有表达错误的请指出，感谢！）</p>\n<img src=\"../images/【debug】Java中的map比较/java_map_debug.jpg\" alt=\"报错截图\" style=\"zoom:100%;\" />\n\n\n\n<p>群友发了一张代码截图，觉得自己写的代码并没有错，但是不能通过测试用例。</p>\n<p>他的算法我简单说一下，有点麻烦，但算法不是这篇博客的重点。</p>\n<ol>\n<li>两个Map：<code>hashS</code>、<code>hashT</code>分别用于存放字符串<code>s</code>和<code>t</code>中字母出现的频率(19行之前)；</li>\n<li>遍历长的字符串对应的Map，假设是<code>hashS</code>，判断<code>hashS</code>与<code>hashT</code>相同的字母频率是否一样，如果不一样则<code>return false</code></li>\n</ol>\n<p>当时我是在外面，看到了这段代码，理解了他的想法之后好像真的没什么问题。</p>\n<h3 id=\"复现Bug与初步解决\"><a href=\"#复现Bug与初步解决\" class=\"headerlink\" title=\"复现Bug与初步解决\"></a>复现Bug与初步解决</h3><p>回来之后代码放到idea里面跑了一下，发现这个测试用例长度为50000位，而且每个字母出现的频率是一样的</p>\n<img src=\"../images/【debug】Java中的map比较/hashST.png\" alt=\"两个Map的内容\" style=\"zoom:67%;\" />\n\n\n\n<p>打上断点继续向下走，看看是哪一步出现了问题。</p>\n<img src=\"../images/【debug】Java中的map比较/断点调试.png\" alt=\"断点调试\" style=\"zoom:67%;\" />\n\n\n\n<p>没想到第一次循环就出错了，<code>hashT.get(c)</code>与<code>hashS.get(c)</code>的值都是1913，但是地址不一样，一个是<code>&#123;Integer@531&#125;</code>，一个是<code>&#123;Integer@587&#125;</code>。看来这里的<code>!=</code>判断的是地址而不是值，使用<code>equal()</code>方法即可，如下：</p>\n<img src=\"../images/【debug】Java中的map比较/初步解决.png\" alt=\"初步解决\" style=\"zoom:67%;\" />\n\n\n\n<h3 id=\"深层探索\"><a href=\"#深层探索\" class=\"headerlink\" title=\"深层探索\"></a>深层探索</h3><p>事情并没有真正的解决，既然群友能通过一些测试用例，说明了一些情况使用<code>!=</code>是可以用的，那几个测试用例都是用了很短的字符串，我也看下是什么情况，<code>s=&quot;anagram&quot;</code>，<code>t=&quot;nagaram&quot;</code>，这是个正确的用例，debug的结果是这样</p>\n<img src=\"../images/【debug】Java中的map比较/短测试用例.png\" alt=\"短测试用例\" style=\"zoom:80%;\" />\n\n\n\n<p>这可就是玄学了呀，短的数据不会出现问题，而长的会出现。</p>\n<h4 id=\"猜想一：与Map的大小有关\"><a href=\"#猜想一：与Map的大小有关\" class=\"headerlink\" title=\"猜想一：与Map的大小有关\"></a>猜想一：与Map的大小有关</h4><p>因为长的测试用例有26个键值对（每个字母均出现），而短的只出现了5个字母。我设置测试用例<code>s = t = &quot;abcdefghijklmnopqrstuvwxyz&quot;</code>（以下简称字母表），让每个字母都出现一次。</p>\n<img src=\"../images/【debug】Java中的map比较/26字母.png\" alt=\"26字母\" style=\"zoom:80%;\" />\n\n\n\n<p>还是正常的，<font color=\"#ff0000\">猜想错误</font></p>\n<h4 id=\"猜想二：与测试用例的长度有关\"><a href=\"#猜想二：与测试用例的长度有关\" class=\"headerlink\" title=\"猜想二：与测试用例的长度有关\"></a>猜想二：与测试用例的长度有关</h4><p>接着我就多复制些字母表，出错误的是在50000的长度，我把字母表长度先放到3000多，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 扩增字符串代码代码</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">t</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">7</span>; i++) &#123;<br>    s += s;<br>    t += t;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<img src=\"../images/【debug】Java中的map比较/3000多长度.png\" alt=\"长度为3328\" style=\"zoom:80%;\" />\n\n\n\n<p>还是有错误，继续缩短长度，将扩增代码循环6次，减少一次再看看</p>\n<img src=\"../images/【debug】Java中的map比较/6次扩增.png\" alt=\"6次扩增\" style=\"zoom:80%;\" />\n\n\n\n<p>这次竟然又不出错了，玄学！妥妥的玄学！</p>\n<p>我换了种思路，这次不用字母表了，只是用一个变量看看会不会触发这个BUG，如果依然触发，每次长度增加1，那么很快就会得到到底在多长的时候会出现。25行打上断点，被执行前一定会卡住。</p>\n<img src=\"../images/【debug】Java中的map比较/展示代码.png\" alt=\"展示代码\" style=\"zoom:80%;\" />\n\n\n\n<img src=\"../images/【debug】Java中的map比较/128卡住.png\" alt=\"字母a出现了128次时候开始报错\" style=\"zoom:80%;\" />\n\n\n\n<p>最后做一次验证，是不是Map中，只要有val超过128就会发生地址改变的情况。这次的测试用例使用随机字母</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">t</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br><span class=\"hljs-type\">Random</span> <span class=\"hljs-variable\">random</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>();<br><span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> random.nextInt(<span class=\"hljs-number\">26</span>) + <span class=\"hljs-number\">97</span>;<br>    s += (<span class=\"hljs-type\">char</span>)temp;<br>    t += (<span class=\"hljs-type\">char</span>)temp;<br>    System.out.println(isAnagram(s, t));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<img src=\"../images/【debug】Java中的map比较/26随机字母报错.png\" alt=\"字母a出现了128次的时候开始报错\" style=\"zoom:80%\"/>\n\n\n\n\n<p>很好！当字母w出现了超过128次时候地址发生了变化。128这个数字相信大家一定很敏感，那么这个范围很可能是[-128, 127]。那么则需要看看底层源码是怎么说的，去看看<code>Map.java</code>，搜索<code>127</code>，并没有发现相关说明。</p>\n<img src=\"../images/【debug】Java中的map比较/map源码.png\" alt=\"map源码\" style=\"zoom:80%;\" />\n\n\n\n<p><code>&#123;Integer@***&#125;</code>这里面经常变得数字就是星号部分，那么去<code>Ieteger.java</code>里面看看有什么发现。</p>\n<img src=\"../images/【debug】Java中的map比较/第一个127.png\" alt=\"搜索结果1\" style=\"zoom:80%;\" />\n\n\n\n<img src=\"../images/【debug】Java中的map比较/最后一个127.png\" alt=\"搜索结果2\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>结合这两段我悟了，果然有这么个范围，在初始化值的时候，[-128, 127]这个范围的数是在缓存里面，所以当<code>Map</code>中的<code>value</code>小于128时候读取的是缓存中的数，所以他们地址是一样的，也就是<code>hashS.get(c)==hashT.get(c)</code>的原因。当超过这个范围，则会在新的地方存放一个值，尽管<code>hashS.get(c)</code>和<code>hashT.get(c)</code>均为128，但是使用<code>==</code>或<code>!=</code>判断的时候，判断的是<strong>地址</strong>，得到<code>hashS.get(c)!=hashT.get(c)</code>。</p>\n<h4 id=\"所以一定要写equal-方法进行判断\"><a href=\"#所以一定要写equal-方法进行判断\" class=\"headerlink\" title=\"所以一定要写equal()方法进行判断\"></a>所以一定要写equal()方法进行判断</h4><h4 id=\"所以一定要写equal-方法进行判断-1\"><a href=\"#所以一定要写equal-方法进行判断-1\" class=\"headerlink\" title=\"所以一定要写equal()方法进行判断\"></a>所以一定要写equal()方法进行判断</h4><h4 id=\"所以一定要写equal-方法进行判断-2\"><a href=\"#所以一定要写equal-方法进行判断-2\" class=\"headerlink\" title=\"所以一定要写equal()方法进行判断\"></a>所以一定要写equal()方法进行判断</h4><p><code>hashS.get(c).equal(hashT.get(c))</code>，这样判断的才是值而不是地址</p>\n"},{"title":"搭建博客","abbrlink":"5c83b0d3","date":"2023-09-19T15:33:25.000Z","_content":"\n# 搭建Hexo博客\n\n根据程序羊的视频搭建而成，整理下步骤和与当时不同之处\n\nhttps://www.bilibili.com/video/BV1Yb411a7ty/\n\n## 1. 安装node.js与npm\n\n略。\n\n有“魔法”的不需要下载`cnpm`包，此后以`npm`为例\n\n## 2. 安装Hexo\n\n`npm install -g hexo-cli`\n\n`hexo -v `查看是否安装成功\n\n## 3. 选址\n\n在合适的地方新建一个专门用于存放博客的文件夹（假设文件夹名为 `blog` ，并且看做根目录），在该路径下开始操作。\n\n- 执行 `hexo init` 初始化，`Linux\\MacOS` 需要 `sudo`权限\n\n- 生成一些文件与文件夹，一些配置在文件 `blog/_config.yml` 中    \n\n## 4. 部署至GitHub的准备工作\n\n1. 在该路径下执行命令: `npm install --save-deployer-git` 安装相关工具\n2. 在GitHub新建仓库，仓库名必须为: `GitHub的用户名.github.io`\n3. 更改`_config.yml`文件中的内容(在最后)：\n\n    ```yaml\n    deploy:\n      type: git\n      repo: git仓库地址\n      branch: master\n    ```\n4. GitHub更新了认证方式，具体操作可以参考这一篇[博客](https://blog.csdn.net/weixin_63031041/article/details/128731242)\n\n## 5. 相关命令\n\n1. 运行(本地预览): `hexo s`\n2. 写新的博客: `hexo n \"文件名\"`\n3. 写好之后生成静态网站: `hexo g`\n4. 清空第三步生成的文件: `hexo clean`\n5. 推送至GitHub(会有一定的延迟): `hexo d`\n\n    使用“魔法”后，GitHub需要设置代理\n\n    `git config --global http.proxy http://127.0.0.1:port`\n\n    `git config --global https.proxy https://127.0.0.1:port`\n\n    \n\n## 6. 更换主题\n\n可以直接在搜索引擎搜索相关关键字，例如`hexo 主题`，以我现在使用的`Fluid`为例\n\nGitHub地址: https://github.com/fluid-dev/hexo-theme-fluid/tree/master\n\n1. 在博客目录下克隆, 至`blog/themes`文件夹下: `git clone https://github.com/fluid-dev/hexo-theme-fluid/tree/master themes/fluid`\n2. 更改`blog/_config.yml` 第100行，将`theme: `后改为`fluid`\n3. 更多具体配置参考官方文档: https://hexo.fluid-dev.com/docs/guide/\n4. 大段文字需要换行需要使用`HTML`语法\n\n## 7. 其他\n\n这里面还有很多有意思的功能没探索、没开发。留给接下来的时间。也慢慢优化这个小网站。\n\n参加“代码随想录”的训练营，虽然有点晚，但是还来得及。搭建了一个博客，主要还是写给自己，记录这一路的成长，当然也不单单的只这一路。\n\n很喜欢郭帆导演的一句话，让我放在了首页开屏\n\n==如果你想再次拥有你从未有过的东西，那么你必须再次去做你从未做过的事情。这还不是结束，这是再次的开始！==\n\n","source":"_posts/搭建博客.md","raw":"---\ntitle: 搭建博客\ntags:\n  - 教程\ncategories: 搭建环境\nabbrlink: 5c83b0d3\ndate: 2023-09-19 23:33:25\n---\n\n# 搭建Hexo博客\n\n根据程序羊的视频搭建而成，整理下步骤和与当时不同之处\n\nhttps://www.bilibili.com/video/BV1Yb411a7ty/\n\n## 1. 安装node.js与npm\n\n略。\n\n有“魔法”的不需要下载`cnpm`包，此后以`npm`为例\n\n## 2. 安装Hexo\n\n`npm install -g hexo-cli`\n\n`hexo -v `查看是否安装成功\n\n## 3. 选址\n\n在合适的地方新建一个专门用于存放博客的文件夹（假设文件夹名为 `blog` ，并且看做根目录），在该路径下开始操作。\n\n- 执行 `hexo init` 初始化，`Linux\\MacOS` 需要 `sudo`权限\n\n- 生成一些文件与文件夹，一些配置在文件 `blog/_config.yml` 中    \n\n## 4. 部署至GitHub的准备工作\n\n1. 在该路径下执行命令: `npm install --save-deployer-git` 安装相关工具\n2. 在GitHub新建仓库，仓库名必须为: `GitHub的用户名.github.io`\n3. 更改`_config.yml`文件中的内容(在最后)：\n\n    ```yaml\n    deploy:\n      type: git\n      repo: git仓库地址\n      branch: master\n    ```\n4. GitHub更新了认证方式，具体操作可以参考这一篇[博客](https://blog.csdn.net/weixin_63031041/article/details/128731242)\n\n## 5. 相关命令\n\n1. 运行(本地预览): `hexo s`\n2. 写新的博客: `hexo n \"文件名\"`\n3. 写好之后生成静态网站: `hexo g`\n4. 清空第三步生成的文件: `hexo clean`\n5. 推送至GitHub(会有一定的延迟): `hexo d`\n\n    使用“魔法”后，GitHub需要设置代理\n\n    `git config --global http.proxy http://127.0.0.1:port`\n\n    `git config --global https.proxy https://127.0.0.1:port`\n\n    \n\n## 6. 更换主题\n\n可以直接在搜索引擎搜索相关关键字，例如`hexo 主题`，以我现在使用的`Fluid`为例\n\nGitHub地址: https://github.com/fluid-dev/hexo-theme-fluid/tree/master\n\n1. 在博客目录下克隆, 至`blog/themes`文件夹下: `git clone https://github.com/fluid-dev/hexo-theme-fluid/tree/master themes/fluid`\n2. 更改`blog/_config.yml` 第100行，将`theme: `后改为`fluid`\n3. 更多具体配置参考官方文档: https://hexo.fluid-dev.com/docs/guide/\n4. 大段文字需要换行需要使用`HTML`语法\n\n## 7. 其他\n\n这里面还有很多有意思的功能没探索、没开发。留给接下来的时间。也慢慢优化这个小网站。\n\n参加“代码随想录”的训练营，虽然有点晚，但是还来得及。搭建了一个博客，主要还是写给自己，记录这一路的成长，当然也不单单的只这一路。\n\n很喜欢郭帆导演的一句话，让我放在了首页开屏\n\n==如果你想再次拥有你从未有过的东西，那么你必须再次去做你从未做过的事情。这还不是结束，这是再次的开始！==\n\n","slug":"搭建博客","published":1,"updated":"2023-09-20T08:07:11.011Z","_id":"cln60vik4000fwvz84nke6dw8","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"搭建Hexo博客\"><a href=\"#搭建Hexo博客\" class=\"headerlink\" title=\"搭建Hexo博客\"></a>搭建Hexo博客</h1><p>根据程序羊的视频搭建而成，整理下步骤和与当时不同之处</p>\n<p><a href=\"https://www.bilibili.com/video/BV1Yb411a7ty/\">https://www.bilibili.com/video/BV1Yb411a7ty/</a></p>\n<h2 id=\"1-安装node-js与npm\"><a href=\"#1-安装node-js与npm\" class=\"headerlink\" title=\"1. 安装node.js与npm\"></a>1. 安装node.js与npm</h2><p>略。</p>\n<p>有“魔法”的不需要下载<code>cnpm</code>包，此后以<code>npm</code>为例</p>\n<h2 id=\"2-安装Hexo\"><a href=\"#2-安装Hexo\" class=\"headerlink\" title=\"2. 安装Hexo\"></a>2. 安装Hexo</h2><p><code>npm install -g hexo-cli</code></p>\n<p><code>hexo -v </code>查看是否安装成功</p>\n<h2 id=\"3-选址\"><a href=\"#3-选址\" class=\"headerlink\" title=\"3. 选址\"></a>3. 选址</h2><p>在合适的地方新建一个专门用于存放博客的文件夹（假设文件夹名为 <code>blog</code> ，并且看做根目录），在该路径下开始操作。</p>\n<ul>\n<li><p>执行 <code>hexo init</code> 初始化，<code>Linux\\MacOS</code> 需要 <code>sudo</code>权限</p>\n</li>\n<li><p>生成一些文件与文件夹，一些配置在文件 <code>blog/_config.yml</code> 中</p>\n</li>\n</ul>\n<h2 id=\"4-部署至GitHub的准备工作\"><a href=\"#4-部署至GitHub的准备工作\" class=\"headerlink\" title=\"4. 部署至GitHub的准备工作\"></a>4. 部署至GitHub的准备工作</h2><ol>\n<li><p>在该路径下执行命令: <code>npm install --save-deployer-git</code> 安装相关工具</p>\n</li>\n<li><p>在GitHub新建仓库，仓库名必须为: <code>GitHub的用户名.github.io</code></p>\n</li>\n<li><p>更改<code>_config.yml</code>文件中的内容(在最后)：</p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">deploy:</span><br>  <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">git</span><br>  <span class=\"hljs-attr\">repo:</span> <span class=\"hljs-string\">git仓库地址</span><br>  <span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">master</span><br></code></pre></td></tr></table></figure></li>\n<li><p>GitHub更新了认证方式，具体操作可以参考这一篇<a href=\"https://blog.csdn.net/weixin_63031041/article/details/128731242\">博客</a></p>\n</li>\n</ol>\n<h2 id=\"5-相关命令\"><a href=\"#5-相关命令\" class=\"headerlink\" title=\"5. 相关命令\"></a>5. 相关命令</h2><ol>\n<li><p>运行(本地预览): <code>hexo s</code></p>\n</li>\n<li><p>写新的博客: <code>hexo n &quot;文件名&quot;</code></p>\n</li>\n<li><p>写好之后生成静态网站: <code>hexo g</code></p>\n</li>\n<li><p>清空第三步生成的文件: <code>hexo clean</code></p>\n</li>\n<li><p>推送至GitHub(会有一定的延迟): <code>hexo d</code></p>\n<p> 使用“魔法”后，GitHub需要设置代理</p>\n<p> <code>git config --global http.proxy http://127.0.0.1:port</code></p>\n<p> <code>git config --global https.proxy https://127.0.0.1:port</code></p>\n</li>\n</ol>\n<h2 id=\"6-更换主题\"><a href=\"#6-更换主题\" class=\"headerlink\" title=\"6. 更换主题\"></a>6. 更换主题</h2><p>可以直接在搜索引擎搜索相关关键字，例如<code>hexo 主题</code>，以我现在使用的<code>Fluid</code>为例</p>\n<p>GitHub地址: <a href=\"https://github.com/fluid-dev/hexo-theme-fluid/tree/master\">https://github.com/fluid-dev/hexo-theme-fluid/tree/master</a></p>\n<ol>\n<li>在博客目录下克隆, 至<code>blog/themes</code>文件夹下: <code>git clone https://github.com/fluid-dev/hexo-theme-fluid/tree/master themes/fluid</code></li>\n<li>更改<code>blog/_config.yml</code> 第100行，将<code>theme: </code>后改为<code>fluid</code></li>\n<li>更多具体配置参考官方文档: <a href=\"https://hexo.fluid-dev.com/docs/guide/\">https://hexo.fluid-dev.com/docs/guide/</a></li>\n<li>大段文字需要换行需要使用<code>HTML</code>语法</li>\n</ol>\n<h2 id=\"7-其他\"><a href=\"#7-其他\" class=\"headerlink\" title=\"7. 其他\"></a>7. 其他</h2><p>这里面还有很多有意思的功能没探索、没开发。留给接下来的时间。也慢慢优化这个小网站。</p>\n<p>参加“代码随想录”的训练营，虽然有点晚，但是还来得及。搭建了一个博客，主要还是写给自己，记录这一路的成长，当然也不单单的只这一路。</p>\n<p>很喜欢郭帆导演的一句话，让我放在了首页开屏</p>\n<p>&#x3D;&#x3D;如果你想再次拥有你从未有过的东西，那么你必须再次去做你从未做过的事情。这还不是结束，这是再次的开始！&#x3D;&#x3D;</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"搭建Hexo博客\"><a href=\"#搭建Hexo博客\" class=\"headerlink\" title=\"搭建Hexo博客\"></a>搭建Hexo博客</h1><p>根据程序羊的视频搭建而成，整理下步骤和与当时不同之处</p>\n<p><a href=\"https://www.bilibili.com/video/BV1Yb411a7ty/\">https://www.bilibili.com/video/BV1Yb411a7ty/</a></p>\n<h2 id=\"1-安装node-js与npm\"><a href=\"#1-安装node-js与npm\" class=\"headerlink\" title=\"1. 安装node.js与npm\"></a>1. 安装node.js与npm</h2><p>略。</p>\n<p>有“魔法”的不需要下载<code>cnpm</code>包，此后以<code>npm</code>为例</p>\n<h2 id=\"2-安装Hexo\"><a href=\"#2-安装Hexo\" class=\"headerlink\" title=\"2. 安装Hexo\"></a>2. 安装Hexo</h2><p><code>npm install -g hexo-cli</code></p>\n<p><code>hexo -v </code>查看是否安装成功</p>\n<h2 id=\"3-选址\"><a href=\"#3-选址\" class=\"headerlink\" title=\"3. 选址\"></a>3. 选址</h2><p>在合适的地方新建一个专门用于存放博客的文件夹（假设文件夹名为 <code>blog</code> ，并且看做根目录），在该路径下开始操作。</p>\n<ul>\n<li><p>执行 <code>hexo init</code> 初始化，<code>Linux\\MacOS</code> 需要 <code>sudo</code>权限</p>\n</li>\n<li><p>生成一些文件与文件夹，一些配置在文件 <code>blog/_config.yml</code> 中</p>\n</li>\n</ul>\n<h2 id=\"4-部署至GitHub的准备工作\"><a href=\"#4-部署至GitHub的准备工作\" class=\"headerlink\" title=\"4. 部署至GitHub的准备工作\"></a>4. 部署至GitHub的准备工作</h2><ol>\n<li><p>在该路径下执行命令: <code>npm install --save-deployer-git</code> 安装相关工具</p>\n</li>\n<li><p>在GitHub新建仓库，仓库名必须为: <code>GitHub的用户名.github.io</code></p>\n</li>\n<li><p>更改<code>_config.yml</code>文件中的内容(在最后)：</p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">deploy:</span><br>  <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">git</span><br>  <span class=\"hljs-attr\">repo:</span> <span class=\"hljs-string\">git仓库地址</span><br>  <span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">master</span><br></code></pre></td></tr></table></figure></li>\n<li><p>GitHub更新了认证方式，具体操作可以参考这一篇<a href=\"https://blog.csdn.net/weixin_63031041/article/details/128731242\">博客</a></p>\n</li>\n</ol>\n<h2 id=\"5-相关命令\"><a href=\"#5-相关命令\" class=\"headerlink\" title=\"5. 相关命令\"></a>5. 相关命令</h2><ol>\n<li><p>运行(本地预览): <code>hexo s</code></p>\n</li>\n<li><p>写新的博客: <code>hexo n &quot;文件名&quot;</code></p>\n</li>\n<li><p>写好之后生成静态网站: <code>hexo g</code></p>\n</li>\n<li><p>清空第三步生成的文件: <code>hexo clean</code></p>\n</li>\n<li><p>推送至GitHub(会有一定的延迟): <code>hexo d</code></p>\n<p> 使用“魔法”后，GitHub需要设置代理</p>\n<p> <code>git config --global http.proxy http://127.0.0.1:port</code></p>\n<p> <code>git config --global https.proxy https://127.0.0.1:port</code></p>\n</li>\n</ol>\n<h2 id=\"6-更换主题\"><a href=\"#6-更换主题\" class=\"headerlink\" title=\"6. 更换主题\"></a>6. 更换主题</h2><p>可以直接在搜索引擎搜索相关关键字，例如<code>hexo 主题</code>，以我现在使用的<code>Fluid</code>为例</p>\n<p>GitHub地址: <a href=\"https://github.com/fluid-dev/hexo-theme-fluid/tree/master\">https://github.com/fluid-dev/hexo-theme-fluid/tree/master</a></p>\n<ol>\n<li>在博客目录下克隆, 至<code>blog/themes</code>文件夹下: <code>git clone https://github.com/fluid-dev/hexo-theme-fluid/tree/master themes/fluid</code></li>\n<li>更改<code>blog/_config.yml</code> 第100行，将<code>theme: </code>后改为<code>fluid</code></li>\n<li>更多具体配置参考官方文档: <a href=\"https://hexo.fluid-dev.com/docs/guide/\">https://hexo.fluid-dev.com/docs/guide/</a></li>\n<li>大段文字需要换行需要使用<code>HTML</code>语法</li>\n</ol>\n<h2 id=\"7-其他\"><a href=\"#7-其他\" class=\"headerlink\" title=\"7. 其他\"></a>7. 其他</h2><p>这里面还有很多有意思的功能没探索、没开发。留给接下来的时间。也慢慢优化这个小网站。</p>\n<p>参加“代码随想录”的训练营，虽然有点晚，但是还来得及。搭建了一个博客，主要还是写给自己，记录这一路的成长，当然也不单单的只这一路。</p>\n<p>很喜欢郭帆导演的一句话，让我放在了首页开屏</p>\n<p>&#x3D;&#x3D;如果你想再次拥有你从未有过的东西，那么你必须再次去做你从未做过的事情。这还不是结束，这是再次的开始！&#x3D;&#x3D;</p>\n"},{"title":"代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。","abbrlink":"7b6fd36a","date":"2023-09-20T07:41:36.000Z","_content":"\n# 代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。\n\n\n\n## 704. 二分查找\n\n>   题目链接：[leetcode链接](https://leetcode.cn/problems/binary-search/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0704.二分查找.html)\n>\n>   视频讲解：[手把手带你撕出正确的二分法 | 二分查找法 | 二分搜索法 | LeetCode：704. 二分查找](https://www.bilibili.com/video/BV1fA4y1o715)\n>\n>   状态：AC\n\n### 思路\n\n看了卡哥的文档，才注意到二分查找也有两种写法。”要**熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法**“。回头看自己的代码是左闭右闭的写法，再改写成左闭右开也不难，只需要更改边界条件即可。\n\n### 代码\n\n``` go\nfunc search(nums []int, target int) int {\n\t// 左闭右闭写法\n\tleft := 0\n\tright := len(nums) - 1\n\tvar mid int\n\tfor left <= right {\n\t\tmid = (left + right) / 2\n\t\tif nums[mid] < target {\n\t\t\tleft = mid + 1\n\t\t} else if nums[mid] > target {\n\t\t\tright = mid - 1\n\t\t} else {\n\t\t\treturn mid\n\t\t}\n\t}\n\treturn -1\n}\n\n```\n\n\n\n``` go\nfunc search1(nums []int, target int) int {\n\t// 左闭右开写法\n\tleft := 0\n\tright := len(nums)\n\tvar mid int\n\tfor left < right {\n\t\tmid = (left + right) / 2\n\t\tif nums[mid] < target {\n\t\t\tleft = mid + 1\n\t\t} else if nums[mid] > target {\n\t\t\tright = mid\n\t\t} else {\n\t\t\treturn mid\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n## 27. 移除元素\n\n>   题目链接：[leetcode链接](https://leetcode.cn/problems/remove-element/ )\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0027.移除元素.html)\n>\n>   视频讲解：[数组中移除元素并不容易！ | LeetCode：27. 移除元素](https://www.bilibili.com/video/BV12A4y1Z7LP )\n>\n>   状态：AC\n\n### 思路\n\n第一眼看到时，题目要求”不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **原地修改输入数组**“。能想到的就是将待删除的后面的元素向前移动达到删除效果，但是时间复杂度为`O(n^2)`。再向下看到了示例：\n\n**示例 1：**\n\n\n> 输入：nums = [3,2,2,3], val = 3\n> 输出：2, nums = [2,2]\n> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n\n\n**示例 2：**\n\n\n> 输入：nums = [0,1,2,2,3,0,4,2], val = 2\n> 输出：5, nums = [0,1,4,0,3]\n> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n看到这里大概理解了，想到的解法是双指针，方法也有两种。\n\n#### 方法一：\n\n1.   左右指针均从头开始，右指针每次向前一步\n2.   若右指针的值为`val`，那么跳过；否则将右指针的值给左指针，左指针++\n3.   返回左指针所在的索引\n\n#### 方法二：\n\n1.   左指针从前开始，右指针从后开始，左指针找`val`，右指针找非`val`\n2.   右指针的值给左指针\n3.   返回左指针所在的索引\n\n### 代码\n\n``` go\n// 方法一\nfunc removeElement(nums []int, val int) int {\n\tn := len(nums)\n\tleft := 0\n\tfor right := 0; right < n; right++ {\n\t\tif nums[right] != val {\n\t\t\tnums[left] = nums[right]\n\t\t\tleft++\n\t\t}\n\t}\n\treturn left\n}\n```\n\n``` go\n// 方法二\nfunc removeElement(nums []int, val int) int {\n\tleft := 0\n\tright := len(nums) - 1\n\tfor left <= right {\n\t\tfor left <= right {\n\t\t\tif nums[left] == val {\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tleft++\n\t\t\t}\n\t\t}\n\t\tfor left <= right {\n\t\t\tif nums[right] != val {\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tright--\n\t\t\t}\n\t\t}\n\t\tif left < right {\n\t\t\tnums[left] = nums[right]\n\t\t\tleft++\n\t\t\tright--\n\t\t}\n\t}\n\treturn left\n}\n```\n\n方法二还是的边界条件有点绕的，自己把自己绕进去了\n\n![绕晕了的边界](../images/day01/image-20230920140818304.png)\n\n\n\n## 附加题 35. 搜索插入位置\n\n>   题目链接：[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)\n>\n>   状态：AC\n\n### 思路\n\n查找，而且是有序，不难想到二分查找。这不过这里不是匹配的情况，而是有可能不匹配。无论是否匹配，只需返回左边界即可。\n\n### 代码\n\n``` go\nfunc searchInsert(nums []int, target int) int {\n\tleft := 0\n\tright := len(nums) - 1\n\tvar mid int\n\tfor left <= right {\n\t\tmid = (left + right) / 2\n\t\tif nums[mid] == target {\n\t\t\treturn mid\n\t\t} else if nums[mid] < target {\n\t\t\tleft = mid + 1\n\t\t} else {\n\t\t\tright = mid - 1\n\t\t}\n\t}\n\treturn left\n}\n```\n\n## 附加题34.在排序数组中查找元素的第一个和最后一个位置\n\n>   题目链接：[34.在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)\n>\n>   状态：AC\n\n### 思路\n\n通过两次二分查找找到`target`在数组中的起始和结束位置，实现了函数`binary`可以两次调用。但是判断起始位置和结束位置需要额外的判断条件：\n\n-   起始：需要判断`num[mid-1]<target`，或者`mid==0`（第0个元素就是起始位置），为了保证不越界，需要先判断`mid==0`的情况\n-   结束：需要判断`mid == len(nums)-1`（最后一个元素是结束位置），或者`nums[mid+1] > target`\n\n如果没有找到该元素，则返回`-1`。由于起始和介绍条件判断有些不同，`binary`函数中使用了`flag`来区分是进行起始元素查找还是结束元素查找的条件。若是`true`则为查找起始元素\n\n### 代码\n\n``` go\nfunc searchRange(nums []int, target int) []int {\n\tresult := []int{}\n    var temp int\n    temp = binary(nums, target, true)\n    if temp == -1 {  // 如果查找开始元素为-1，说明该数不存在，第二次二分不需要进行\n        return []int{-1, -1}\n    } else {\n\t\tresult = append(result, temp)\n        result = append(result, binary(nums, target, false))\n        return result\n    }\n}\nfunc binary(nums []int, target int, flag bool) int {\n\tleft := 0\n\tright := len(nums) - 1\n\tfor left <= right {\n\t\tmid := left + (right-left)/2\n\t\tif flag {\n\t\t\tif nums[mid] == target && (mid == 0 || nums[mid-1] < target) {\n\t\t\t\treturn mid\n\t\t\t} else if nums[mid] < target {\n\t\t\t\tleft = mid + 1\n\t\t\t} else {\n\t\t\t\tright = mid - 1\n\t\t\t}\n\t\t} else {\n\t\t\tif nums[mid] == target && (mid == len(nums)-1 || nums[mid+1] > target) {\n\t\t\t\treturn mid\n\t\t\t} else if nums[mid] <= target {\n\t\t\t\tleft = mid + 1\n\t\t\t} else {\n\t\t\t\tright = mid - 1\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n![AC！](../images/day01/image-20230920152650727.png)\n\n### 官方解法\n\n#### Go语言版本\n\n``` go\nfunc searchRange(nums []int, target int) []int {\n    leftmost := sort.SearchInts(nums, target)\n    if leftmost == len(nums) || nums[leftmost] != target {\n        return []int{-1, -1}\n    }\n    rightmost := sort.SearchInts(nums, target + 1) - 1\n    return []int{leftmost, rightmost}\n}\n\n作者：力扣官方题解\n链接：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n`sort.SearchInts()`函数没有接触过，看看源码\n\n<img src=\"../images/day01/image-20230920152855240.png\" alt=\"sort.SearchInts()源码\" style=\"zoom:67%;\" />\n\n>   SearchInts在整型数组的有序切片中搜索x，并返回由Search指定的索引。如果x不存在，返回值是插入x的索引(可以是len(a))。\n>   切片必须按升序排序。\n\n#### C++版本\n\n``` c++\nclass Solution { \npublic:\n    int binarySearch(vector<int>& nums, int target, bool lower) {\n        int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] > target || (lower && nums[mid] >= target)) {\n                right = mid - 1;\n                ans = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int leftIdx = binarySearch(nums, target, true);\n        int rightIdx = binarySearch(nums, target, false) - 1;\n        if (leftIdx <= rightIdx && rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target) {\n            return vector<int>{leftIdx, rightIdx};\n        } \n        return vector<int>{-1, -1};\n    }\n};\n\n作者：力扣官方题解\n链接：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n官方题解在找结束元素是找到了下一位，可以通过减一操作得到正确答案。但是他们实现的二分函数的`true`和`false`对条件控制的很巧妙。\n\n## 小结\n\n-   在二分查找时又学到了一种思路，”左闭右开“\n\n-   群里面有位同学说到了这个事情，之前从未注意过：\n\n    <img src=\"../images/day01/image-20230920153829216.png\" alt=\"群友聊天\" style=\"zoom:80%;\" />\n\n    看别人的二分确实发现了第一种写法，但是并不是很理解，也没有很在意。\n\n今天总用时三个小时多一些，做了四道题，感觉良好。第一天结束！！\n\n","source":"_posts/day01.md","raw":"---\ntitle: 代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: 7b6fd36a\ndate: 2023-09-20 15:41:36\n---\n\n# 代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。\n\n\n\n## 704. 二分查找\n\n>   题目链接：[leetcode链接](https://leetcode.cn/problems/binary-search/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0704.二分查找.html)\n>\n>   视频讲解：[手把手带你撕出正确的二分法 | 二分查找法 | 二分搜索法 | LeetCode：704. 二分查找](https://www.bilibili.com/video/BV1fA4y1o715)\n>\n>   状态：AC\n\n### 思路\n\n看了卡哥的文档，才注意到二分查找也有两种写法。”要**熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法**“。回头看自己的代码是左闭右闭的写法，再改写成左闭右开也不难，只需要更改边界条件即可。\n\n### 代码\n\n``` go\nfunc search(nums []int, target int) int {\n\t// 左闭右闭写法\n\tleft := 0\n\tright := len(nums) - 1\n\tvar mid int\n\tfor left <= right {\n\t\tmid = (left + right) / 2\n\t\tif nums[mid] < target {\n\t\t\tleft = mid + 1\n\t\t} else if nums[mid] > target {\n\t\t\tright = mid - 1\n\t\t} else {\n\t\t\treturn mid\n\t\t}\n\t}\n\treturn -1\n}\n\n```\n\n\n\n``` go\nfunc search1(nums []int, target int) int {\n\t// 左闭右开写法\n\tleft := 0\n\tright := len(nums)\n\tvar mid int\n\tfor left < right {\n\t\tmid = (left + right) / 2\n\t\tif nums[mid] < target {\n\t\t\tleft = mid + 1\n\t\t} else if nums[mid] > target {\n\t\t\tright = mid\n\t\t} else {\n\t\t\treturn mid\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n## 27. 移除元素\n\n>   题目链接：[leetcode链接](https://leetcode.cn/problems/remove-element/ )\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0027.移除元素.html)\n>\n>   视频讲解：[数组中移除元素并不容易！ | LeetCode：27. 移除元素](https://www.bilibili.com/video/BV12A4y1Z7LP )\n>\n>   状态：AC\n\n### 思路\n\n第一眼看到时，题目要求”不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **原地修改输入数组**“。能想到的就是将待删除的后面的元素向前移动达到删除效果，但是时间复杂度为`O(n^2)`。再向下看到了示例：\n\n**示例 1：**\n\n\n> 输入：nums = [3,2,2,3], val = 3\n> 输出：2, nums = [2,2]\n> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n\n\n**示例 2：**\n\n\n> 输入：nums = [0,1,2,2,3,0,4,2], val = 2\n> 输出：5, nums = [0,1,4,0,3]\n> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n看到这里大概理解了，想到的解法是双指针，方法也有两种。\n\n#### 方法一：\n\n1.   左右指针均从头开始，右指针每次向前一步\n2.   若右指针的值为`val`，那么跳过；否则将右指针的值给左指针，左指针++\n3.   返回左指针所在的索引\n\n#### 方法二：\n\n1.   左指针从前开始，右指针从后开始，左指针找`val`，右指针找非`val`\n2.   右指针的值给左指针\n3.   返回左指针所在的索引\n\n### 代码\n\n``` go\n// 方法一\nfunc removeElement(nums []int, val int) int {\n\tn := len(nums)\n\tleft := 0\n\tfor right := 0; right < n; right++ {\n\t\tif nums[right] != val {\n\t\t\tnums[left] = nums[right]\n\t\t\tleft++\n\t\t}\n\t}\n\treturn left\n}\n```\n\n``` go\n// 方法二\nfunc removeElement(nums []int, val int) int {\n\tleft := 0\n\tright := len(nums) - 1\n\tfor left <= right {\n\t\tfor left <= right {\n\t\t\tif nums[left] == val {\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tleft++\n\t\t\t}\n\t\t}\n\t\tfor left <= right {\n\t\t\tif nums[right] != val {\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tright--\n\t\t\t}\n\t\t}\n\t\tif left < right {\n\t\t\tnums[left] = nums[right]\n\t\t\tleft++\n\t\t\tright--\n\t\t}\n\t}\n\treturn left\n}\n```\n\n方法二还是的边界条件有点绕的，自己把自己绕进去了\n\n![绕晕了的边界](../images/day01/image-20230920140818304.png)\n\n\n\n## 附加题 35. 搜索插入位置\n\n>   题目链接：[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)\n>\n>   状态：AC\n\n### 思路\n\n查找，而且是有序，不难想到二分查找。这不过这里不是匹配的情况，而是有可能不匹配。无论是否匹配，只需返回左边界即可。\n\n### 代码\n\n``` go\nfunc searchInsert(nums []int, target int) int {\n\tleft := 0\n\tright := len(nums) - 1\n\tvar mid int\n\tfor left <= right {\n\t\tmid = (left + right) / 2\n\t\tif nums[mid] == target {\n\t\t\treturn mid\n\t\t} else if nums[mid] < target {\n\t\t\tleft = mid + 1\n\t\t} else {\n\t\t\tright = mid - 1\n\t\t}\n\t}\n\treturn left\n}\n```\n\n## 附加题34.在排序数组中查找元素的第一个和最后一个位置\n\n>   题目链接：[34.在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)\n>\n>   状态：AC\n\n### 思路\n\n通过两次二分查找找到`target`在数组中的起始和结束位置，实现了函数`binary`可以两次调用。但是判断起始位置和结束位置需要额外的判断条件：\n\n-   起始：需要判断`num[mid-1]<target`，或者`mid==0`（第0个元素就是起始位置），为了保证不越界，需要先判断`mid==0`的情况\n-   结束：需要判断`mid == len(nums)-1`（最后一个元素是结束位置），或者`nums[mid+1] > target`\n\n如果没有找到该元素，则返回`-1`。由于起始和介绍条件判断有些不同，`binary`函数中使用了`flag`来区分是进行起始元素查找还是结束元素查找的条件。若是`true`则为查找起始元素\n\n### 代码\n\n``` go\nfunc searchRange(nums []int, target int) []int {\n\tresult := []int{}\n    var temp int\n    temp = binary(nums, target, true)\n    if temp == -1 {  // 如果查找开始元素为-1，说明该数不存在，第二次二分不需要进行\n        return []int{-1, -1}\n    } else {\n\t\tresult = append(result, temp)\n        result = append(result, binary(nums, target, false))\n        return result\n    }\n}\nfunc binary(nums []int, target int, flag bool) int {\n\tleft := 0\n\tright := len(nums) - 1\n\tfor left <= right {\n\t\tmid := left + (right-left)/2\n\t\tif flag {\n\t\t\tif nums[mid] == target && (mid == 0 || nums[mid-1] < target) {\n\t\t\t\treturn mid\n\t\t\t} else if nums[mid] < target {\n\t\t\t\tleft = mid + 1\n\t\t\t} else {\n\t\t\t\tright = mid - 1\n\t\t\t}\n\t\t} else {\n\t\t\tif nums[mid] == target && (mid == len(nums)-1 || nums[mid+1] > target) {\n\t\t\t\treturn mid\n\t\t\t} else if nums[mid] <= target {\n\t\t\t\tleft = mid + 1\n\t\t\t} else {\n\t\t\t\tright = mid - 1\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n![AC！](../images/day01/image-20230920152650727.png)\n\n### 官方解法\n\n#### Go语言版本\n\n``` go\nfunc searchRange(nums []int, target int) []int {\n    leftmost := sort.SearchInts(nums, target)\n    if leftmost == len(nums) || nums[leftmost] != target {\n        return []int{-1, -1}\n    }\n    rightmost := sort.SearchInts(nums, target + 1) - 1\n    return []int{leftmost, rightmost}\n}\n\n作者：力扣官方题解\n链接：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n`sort.SearchInts()`函数没有接触过，看看源码\n\n<img src=\"../images/day01/image-20230920152855240.png\" alt=\"sort.SearchInts()源码\" style=\"zoom:67%;\" />\n\n>   SearchInts在整型数组的有序切片中搜索x，并返回由Search指定的索引。如果x不存在，返回值是插入x的索引(可以是len(a))。\n>   切片必须按升序排序。\n\n#### C++版本\n\n``` c++\nclass Solution { \npublic:\n    int binarySearch(vector<int>& nums, int target, bool lower) {\n        int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] > target || (lower && nums[mid] >= target)) {\n                right = mid - 1;\n                ans = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int leftIdx = binarySearch(nums, target, true);\n        int rightIdx = binarySearch(nums, target, false) - 1;\n        if (leftIdx <= rightIdx && rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target) {\n            return vector<int>{leftIdx, rightIdx};\n        } \n        return vector<int>{-1, -1};\n    }\n};\n\n作者：力扣官方题解\n链接：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n官方题解在找结束元素是找到了下一位，可以通过减一操作得到正确答案。但是他们实现的二分函数的`true`和`false`对条件控制的很巧妙。\n\n## 小结\n\n-   在二分查找时又学到了一种思路，”左闭右开“\n\n-   群里面有位同学说到了这个事情，之前从未注意过：\n\n    <img src=\"../images/day01/image-20230920153829216.png\" alt=\"群友聊天\" style=\"zoom:80%;\" />\n\n    看别人的二分确实发现了第一种写法，但是并不是很理解，也没有很在意。\n\n今天总用时三个小时多一些，做了四道题，感觉良好。第一天结束！！\n\n","slug":"day01","published":1,"updated":"2023-10-04T11:44:13.087Z","_id":"cln7q7aln0000vswhdo94d4i6","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第一天-704-二分查找、27-移除元素。\"><a href=\"#代码随想录算法训练营第一天-704-二分查找、27-移除元素。\" class=\"headerlink\" title=\"代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。\"></a>代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。</h1><h2 id=\"704-二分查找\"><a href=\"#704-二分查找\" class=\"headerlink\" title=\"704. 二分查找\"></a>704. 二分查找</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/binary-search/\">leetcode链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1fA4y1o715\">手把手带你撕出正确的二分法 | 二分查找法 | 二分搜索法 | LeetCode：704. 二分查找</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>看了卡哥的文档，才注意到二分查找也有两种写法。”要<strong>熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法</strong>“。回头看自己的代码是左闭右闭的写法，再改写成左闭右开也不难，只需要更改边界条件即可。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-comment\">// 左闭右闭写法</span><br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">var</span> mid <span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>\t\tmid = (left + right) / <span class=\"hljs-number\">2</span><br>\t\t<span class=\"hljs-keyword\">if</span> nums[mid] &lt; target &#123;<br>\t\t\tleft = mid + <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[mid] &gt; target &#123;<br>\t\t\tright = mid - <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> mid<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">search1</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-comment\">// 左闭右开写法</span><br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-built_in\">len</span>(nums)<br>\t<span class=\"hljs-keyword\">var</span> mid <span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>\t\tmid = (left + right) / <span class=\"hljs-number\">2</span><br>\t\t<span class=\"hljs-keyword\">if</span> nums[mid] &lt; target &#123;<br>\t\t\tleft = mid + <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[mid] &gt; target &#123;<br>\t\t\tright = mid<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> mid<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a>27. 移除元素</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/remove-element/\">leetcode链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV12A4y1Z7LP\">数组中移除元素并不容易！ | LeetCode：27. 移除元素</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>第一眼看到时，题目要求”不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong>原地修改输入数组</strong>“。能想到的就是将待删除的后面的元素向前移动达到删除效果，但是时间复杂度为<code>O(n^2)</code>。再向下看到了示例：</p>\n<p><strong>示例 1：</strong></p>\n<blockquote>\n<p>输入：nums &#x3D; [3,2,2,3], val &#x3D; 3<br>输出：2, nums &#x3D; [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</p>\n</blockquote>\n<p><strong>示例 2：</strong></p>\n<blockquote>\n<p>输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2<br>输出：5, nums &#x3D; [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<p>看到这里大概理解了，想到的解法是双指针，方法也有两种。</p>\n<h4 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h4><ol>\n<li>左右指针均从头开始，右指针每次向前一步</li>\n<li>若右指针的值为<code>val</code>，那么跳过；否则将右指针的值给左指针，左指针++</li>\n<li>返回左指针所在的索引</li>\n</ol>\n<h4 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h4><ol>\n<li>左指针从前开始，右指针从后开始，左指针找<code>val</code>，右指针找非<code>val</code></li>\n<li>右指针的值给左指针</li>\n<li>返回左指针所在的索引</li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 方法一</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">removeElement</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, val <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tn := <span class=\"hljs-built_in\">len</span>(nums)<br>\tleft := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> right := <span class=\"hljs-number\">0</span>; right &lt; n; right++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> nums[right] != val &#123;<br>\t\t\tnums[left] = nums[right]<br>\t\t\tleft++<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 方法二</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">removeElement</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, val <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> nums[left] == val &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tleft++<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> nums[right] != val &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tright--<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> left &lt; right &#123;<br>\t\t\tnums[left] = nums[right]<br>\t\t\tleft++<br>\t\t\tright--<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>方法二还是的边界条件有点绕的，自己把自己绕进去了</p>\n<p><img src=\"/../images/day01/image-20230920140818304.png\" alt=\"绕晕了的边界\"></p>\n<h2 id=\"附加题-35-搜索插入位置\"><a href=\"#附加题-35-搜索插入位置\" class=\"headerlink\" title=\"附加题 35. 搜索插入位置\"></a>附加题 35. 搜索插入位置</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/search-insert-position/\">35. 搜索插入位置</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>查找，而且是有序，不难想到二分查找。这不过这里不是匹配的情况，而是有可能不匹配。无论是否匹配，只需返回左边界即可。</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">searchInsert</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">var</span> mid <span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>\t\tmid = (left + right) / <span class=\"hljs-number\">2</span><br>\t\t<span class=\"hljs-keyword\">if</span> nums[mid] == target &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> mid<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[mid] &lt; target &#123;<br>\t\t\tleft = mid + <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tright = mid - <span class=\"hljs-number\">1</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"附加题34-在排序数组中查找元素的第一个和最后一个位置\"><a href=\"#附加题34-在排序数组中查找元素的第一个和最后一个位置\" class=\"headerlink\" title=\"附加题34.在排序数组中查找元素的第一个和最后一个位置\"></a>附加题34.在排序数组中查找元素的第一个和最后一个位置</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\">34.在排序数组中查找元素的第一个和最后一个位置</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>通过两次二分查找找到<code>target</code>在数组中的起始和结束位置，实现了函数<code>binary</code>可以两次调用。但是判断起始位置和结束位置需要额外的判断条件：</p>\n<ul>\n<li>起始：需要判断<code>num[mid-1]&lt;target</code>，或者<code>mid==0</code>（第0个元素就是起始位置），为了保证不越界，需要先判断<code>mid==0</code>的情况</li>\n<li>结束：需要判断<code>mid == len(nums)-1</code>（最后一个元素是结束位置），或者<code>nums[mid+1] &gt; target</code></li>\n</ul>\n<p>如果没有找到该元素，则返回<code>-1</code>。由于起始和介绍条件判断有些不同，<code>binary</code>函数中使用了<code>flag</code>来区分是进行起始元素查找还是结束元素查找的条件。若是<code>true</code>则为查找起始元素</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">searchRange</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tresult := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">var</span> temp <span class=\"hljs-type\">int</span><br>    temp = binary(nums, target, <span class=\"hljs-literal\">true</span>)<br>    <span class=\"hljs-keyword\">if</span> temp == <span class=\"hljs-number\">-1</span> &#123;  <span class=\"hljs-comment\">// 如果查找开始元素为-1，说明该数不存在，第二次二分不需要进行</span><br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>        result = <span class=\"hljs-built_in\">append</span>(result, binary(nums, target, <span class=\"hljs-literal\">false</span>))<br>        <span class=\"hljs-keyword\">return</span> result<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">binary</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>, flag <span class=\"hljs-type\">bool</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>\t\tmid := left + (right-left)/<span class=\"hljs-number\">2</span><br>\t\t<span class=\"hljs-keyword\">if</span> flag &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> nums[mid] == target &amp;&amp; (mid == <span class=\"hljs-number\">0</span> || nums[mid<span class=\"hljs-number\">-1</span>] &lt; target) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> mid<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[mid] &lt; target &#123;<br>\t\t\t\tleft = mid + <span class=\"hljs-number\">1</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tright = mid - <span class=\"hljs-number\">1</span><br>\t\t\t&#125;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> nums[mid] == target &amp;&amp; (mid == <span class=\"hljs-built_in\">len</span>(nums)<span class=\"hljs-number\">-1</span> || nums[mid+<span class=\"hljs-number\">1</span>] &gt; target) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> mid<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[mid] &lt;= target &#123;<br>\t\t\t\tleft = mid + <span class=\"hljs-number\">1</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tright = mid - <span class=\"hljs-number\">1</span><br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/day01/image-20230920152650727.png\" alt=\"AC！\"></p>\n<h3 id=\"官方解法\"><a href=\"#官方解法\" class=\"headerlink\" title=\"官方解法\"></a>官方解法</h3><h4 id=\"Go语言版本\"><a href=\"#Go语言版本\" class=\"headerlink\" title=\"Go语言版本\"></a>Go语言版本</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">searchRange</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>    leftmost := sort.SearchInts(nums, target)<br>    <span class=\"hljs-keyword\">if</span> leftmost == <span class=\"hljs-built_in\">len</span>(nums) || nums[leftmost] != target &#123;<br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;<br>    &#125;<br>    rightmost := sort.SearchInts(nums, target + <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;leftmost, rightmost&#125;<br>&#125;<br><br>作者：力扣官方题解<br>链接：https:<span class=\"hljs-comment\">//leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>\n\n<p><code>sort.SearchInts()</code>函数没有接触过，看看源码</p>\n<img src=\"../images/day01/image-20230920152855240.png\" alt=\"sort.SearchInts()源码\" style=\"zoom:67%;\" />\n\n<blockquote>\n<p>  SearchInts在整型数组的有序切片中搜索x，并返回由Search指定的索引。如果x不存在，返回值是插入x的索引(可以是len(a))。<br>  切片必须按升序排序。</p>\n</blockquote>\n<h4 id=\"C-版本\"><a href=\"#C-版本\" class=\"headerlink\" title=\"C++版本\"></a>C++版本</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123; <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">binarySearch</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> target, <span class=\"hljs-type\">bool</span> lower)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> left = <span class=\"hljs-number\">0</span>, right = (<span class=\"hljs-type\">int</span>)nums.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>, ans = (<span class=\"hljs-type\">int</span>)nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">while</span> (left &lt;= right) &#123;<br>            <span class=\"hljs-type\">int</span> mid = (left + right) / <span class=\"hljs-number\">2</span>;<br>            <span class=\"hljs-keyword\">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;<br>                right = mid - <span class=\"hljs-number\">1</span>;<br>                ans = mid;<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                left = mid + <span class=\"hljs-number\">1</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> ans;<br>    &#125;<br><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">searchRange</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> target)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> leftIdx = <span class=\"hljs-built_in\">binarySearch</span>(nums, target, <span class=\"hljs-literal\">true</span>);<br>        <span class=\"hljs-type\">int</span> rightIdx = <span class=\"hljs-built_in\">binarySearch</span>(nums, target, <span class=\"hljs-literal\">false</span>) - <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.<span class=\"hljs-built_in\">size</span>() &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;<br>            <span class=\"hljs-keyword\">return</span> vector&lt;<span class=\"hljs-type\">int</span>&gt;&#123;leftIdx, rightIdx&#125;;<br>        &#125; <br>        <span class=\"hljs-keyword\">return</span> vector&lt;<span class=\"hljs-type\">int</span>&gt;&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;;<br>    &#125;<br>&#125;;<br><br>作者：力扣官方题解<br>链接：https:<span class=\"hljs-comment\">//leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>\n\n<p>官方题解在找结束元素是找到了下一位，可以通过减一操作得到正确答案。但是他们实现的二分函数的<code>true</code>和<code>false</code>对条件控制的很巧妙。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li><p>在二分查找时又学到了一种思路，”左闭右开“</p>\n</li>\n<li><p>群里面有位同学说到了这个事情，之前从未注意过：</p>\n<img src=\"../images/day01/image-20230920153829216.png\" alt=\"群友聊天\" style=\"zoom:80%;\" />\n\n<p>看别人的二分确实发现了第一种写法，但是并不是很理解，也没有很在意。</p>\n</li>\n</ul>\n<p>今天总用时三个小时多一些，做了四道题，感觉良好。第一天结束！！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第一天-704-二分查找、27-移除元素。\"><a href=\"#代码随想录算法训练营第一天-704-二分查找、27-移除元素。\" class=\"headerlink\" title=\"代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。\"></a>代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。</h1><h2 id=\"704-二分查找\"><a href=\"#704-二分查找\" class=\"headerlink\" title=\"704. 二分查找\"></a>704. 二分查找</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/binary-search/\">leetcode链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1fA4y1o715\">手把手带你撕出正确的二分法 | 二分查找法 | 二分搜索法 | LeetCode：704. 二分查找</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>看了卡哥的文档，才注意到二分查找也有两种写法。”要<strong>熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法</strong>“。回头看自己的代码是左闭右闭的写法，再改写成左闭右开也不难，只需要更改边界条件即可。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-comment\">// 左闭右闭写法</span><br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">var</span> mid <span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>\t\tmid = (left + right) / <span class=\"hljs-number\">2</span><br>\t\t<span class=\"hljs-keyword\">if</span> nums[mid] &lt; target &#123;<br>\t\t\tleft = mid + <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[mid] &gt; target &#123;<br>\t\t\tright = mid - <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> mid<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">search1</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-comment\">// 左闭右开写法</span><br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-built_in\">len</span>(nums)<br>\t<span class=\"hljs-keyword\">var</span> mid <span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>\t\tmid = (left + right) / <span class=\"hljs-number\">2</span><br>\t\t<span class=\"hljs-keyword\">if</span> nums[mid] &lt; target &#123;<br>\t\t\tleft = mid + <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[mid] &gt; target &#123;<br>\t\t\tright = mid<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> mid<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a>27. 移除元素</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/remove-element/\">leetcode链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV12A4y1Z7LP\">数组中移除元素并不容易！ | LeetCode：27. 移除元素</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>第一眼看到时，题目要求”不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong>原地修改输入数组</strong>“。能想到的就是将待删除的后面的元素向前移动达到删除效果，但是时间复杂度为<code>O(n^2)</code>。再向下看到了示例：</p>\n<p><strong>示例 1：</strong></p>\n<blockquote>\n<p>输入：nums &#x3D; [3,2,2,3], val &#x3D; 3<br>输出：2, nums &#x3D; [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</p>\n</blockquote>\n<p><strong>示例 2：</strong></p>\n<blockquote>\n<p>输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2<br>输出：5, nums &#x3D; [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<p>看到这里大概理解了，想到的解法是双指针，方法也有两种。</p>\n<h4 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h4><ol>\n<li>左右指针均从头开始，右指针每次向前一步</li>\n<li>若右指针的值为<code>val</code>，那么跳过；否则将右指针的值给左指针，左指针++</li>\n<li>返回左指针所在的索引</li>\n</ol>\n<h4 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h4><ol>\n<li>左指针从前开始，右指针从后开始，左指针找<code>val</code>，右指针找非<code>val</code></li>\n<li>右指针的值给左指针</li>\n<li>返回左指针所在的索引</li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 方法一</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">removeElement</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, val <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tn := <span class=\"hljs-built_in\">len</span>(nums)<br>\tleft := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> right := <span class=\"hljs-number\">0</span>; right &lt; n; right++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> nums[right] != val &#123;<br>\t\t\tnums[left] = nums[right]<br>\t\t\tleft++<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 方法二</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">removeElement</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, val <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> nums[left] == val &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tleft++<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> nums[right] != val &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tright--<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> left &lt; right &#123;<br>\t\t\tnums[left] = nums[right]<br>\t\t\tleft++<br>\t\t\tright--<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>方法二还是的边界条件有点绕的，自己把自己绕进去了</p>\n<p><img src=\"/../images/day01/image-20230920140818304.png\" alt=\"绕晕了的边界\"></p>\n<h2 id=\"附加题-35-搜索插入位置\"><a href=\"#附加题-35-搜索插入位置\" class=\"headerlink\" title=\"附加题 35. 搜索插入位置\"></a>附加题 35. 搜索插入位置</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/search-insert-position/\">35. 搜索插入位置</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>查找，而且是有序，不难想到二分查找。这不过这里不是匹配的情况，而是有可能不匹配。无论是否匹配，只需返回左边界即可。</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">searchInsert</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">var</span> mid <span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>\t\tmid = (left + right) / <span class=\"hljs-number\">2</span><br>\t\t<span class=\"hljs-keyword\">if</span> nums[mid] == target &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> mid<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[mid] &lt; target &#123;<br>\t\t\tleft = mid + <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tright = mid - <span class=\"hljs-number\">1</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"附加题34-在排序数组中查找元素的第一个和最后一个位置\"><a href=\"#附加题34-在排序数组中查找元素的第一个和最后一个位置\" class=\"headerlink\" title=\"附加题34.在排序数组中查找元素的第一个和最后一个位置\"></a>附加题34.在排序数组中查找元素的第一个和最后一个位置</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\">34.在排序数组中查找元素的第一个和最后一个位置</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>通过两次二分查找找到<code>target</code>在数组中的起始和结束位置，实现了函数<code>binary</code>可以两次调用。但是判断起始位置和结束位置需要额外的判断条件：</p>\n<ul>\n<li>起始：需要判断<code>num[mid-1]&lt;target</code>，或者<code>mid==0</code>（第0个元素就是起始位置），为了保证不越界，需要先判断<code>mid==0</code>的情况</li>\n<li>结束：需要判断<code>mid == len(nums)-1</code>（最后一个元素是结束位置），或者<code>nums[mid+1] &gt; target</code></li>\n</ul>\n<p>如果没有找到该元素，则返回<code>-1</code>。由于起始和介绍条件判断有些不同，<code>binary</code>函数中使用了<code>flag</code>来区分是进行起始元素查找还是结束元素查找的条件。若是<code>true</code>则为查找起始元素</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">searchRange</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tresult := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">var</span> temp <span class=\"hljs-type\">int</span><br>    temp = binary(nums, target, <span class=\"hljs-literal\">true</span>)<br>    <span class=\"hljs-keyword\">if</span> temp == <span class=\"hljs-number\">-1</span> &#123;  <span class=\"hljs-comment\">// 如果查找开始元素为-1，说明该数不存在，第二次二分不需要进行</span><br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>        result = <span class=\"hljs-built_in\">append</span>(result, binary(nums, target, <span class=\"hljs-literal\">false</span>))<br>        <span class=\"hljs-keyword\">return</span> result<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">binary</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>, flag <span class=\"hljs-type\">bool</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> left &lt;= right &#123;<br>\t\tmid := left + (right-left)/<span class=\"hljs-number\">2</span><br>\t\t<span class=\"hljs-keyword\">if</span> flag &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> nums[mid] == target &amp;&amp; (mid == <span class=\"hljs-number\">0</span> || nums[mid<span class=\"hljs-number\">-1</span>] &lt; target) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> mid<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[mid] &lt; target &#123;<br>\t\t\t\tleft = mid + <span class=\"hljs-number\">1</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tright = mid - <span class=\"hljs-number\">1</span><br>\t\t\t&#125;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> nums[mid] == target &amp;&amp; (mid == <span class=\"hljs-built_in\">len</span>(nums)<span class=\"hljs-number\">-1</span> || nums[mid+<span class=\"hljs-number\">1</span>] &gt; target) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> mid<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[mid] &lt;= target &#123;<br>\t\t\t\tleft = mid + <span class=\"hljs-number\">1</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tright = mid - <span class=\"hljs-number\">1</span><br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/day01/image-20230920152650727.png\" alt=\"AC！\"></p>\n<h3 id=\"官方解法\"><a href=\"#官方解法\" class=\"headerlink\" title=\"官方解法\"></a>官方解法</h3><h4 id=\"Go语言版本\"><a href=\"#Go语言版本\" class=\"headerlink\" title=\"Go语言版本\"></a>Go语言版本</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">searchRange</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>    leftmost := sort.SearchInts(nums, target)<br>    <span class=\"hljs-keyword\">if</span> leftmost == <span class=\"hljs-built_in\">len</span>(nums) || nums[leftmost] != target &#123;<br>        <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;<br>    &#125;<br>    rightmost := sort.SearchInts(nums, target + <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;leftmost, rightmost&#125;<br>&#125;<br><br>作者：力扣官方题解<br>链接：https:<span class=\"hljs-comment\">//leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>\n\n<p><code>sort.SearchInts()</code>函数没有接触过，看看源码</p>\n<img src=\"../images/day01/image-20230920152855240.png\" alt=\"sort.SearchInts()源码\" style=\"zoom:67%;\" />\n\n<blockquote>\n<p>  SearchInts在整型数组的有序切片中搜索x，并返回由Search指定的索引。如果x不存在，返回值是插入x的索引(可以是len(a))。<br>  切片必须按升序排序。</p>\n</blockquote>\n<h4 id=\"C-版本\"><a href=\"#C-版本\" class=\"headerlink\" title=\"C++版本\"></a>C++版本</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123; <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">binarySearch</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> target, <span class=\"hljs-type\">bool</span> lower)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> left = <span class=\"hljs-number\">0</span>, right = (<span class=\"hljs-type\">int</span>)nums.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>, ans = (<span class=\"hljs-type\">int</span>)nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">while</span> (left &lt;= right) &#123;<br>            <span class=\"hljs-type\">int</span> mid = (left + right) / <span class=\"hljs-number\">2</span>;<br>            <span class=\"hljs-keyword\">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;<br>                right = mid - <span class=\"hljs-number\">1</span>;<br>                ans = mid;<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                left = mid + <span class=\"hljs-number\">1</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> ans;<br>    &#125;<br><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">searchRange</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> target)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> leftIdx = <span class=\"hljs-built_in\">binarySearch</span>(nums, target, <span class=\"hljs-literal\">true</span>);<br>        <span class=\"hljs-type\">int</span> rightIdx = <span class=\"hljs-built_in\">binarySearch</span>(nums, target, <span class=\"hljs-literal\">false</span>) - <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.<span class=\"hljs-built_in\">size</span>() &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;<br>            <span class=\"hljs-keyword\">return</span> vector&lt;<span class=\"hljs-type\">int</span>&gt;&#123;leftIdx, rightIdx&#125;;<br>        &#125; <br>        <span class=\"hljs-keyword\">return</span> vector&lt;<span class=\"hljs-type\">int</span>&gt;&#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>&#125;;<br>    &#125;<br>&#125;;<br><br>作者：力扣官方题解<br>链接：https:<span class=\"hljs-comment\">//leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>\n\n<p>官方题解在找结束元素是找到了下一位，可以通过减一操作得到正确答案。但是他们实现的二分函数的<code>true</code>和<code>false</code>对条件控制的很巧妙。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li><p>在二分查找时又学到了一种思路，”左闭右开“</p>\n</li>\n<li><p>群里面有位同学说到了这个事情，之前从未注意过：</p>\n<img src=\"../images/day01/image-20230920153829216.png\" alt=\"群友聊天\" style=\"zoom:80%;\" />\n\n<p>看别人的二分确实发现了第一种写法，但是并不是很理解，也没有很在意。</p>\n</li>\n</ul>\n<p>今天总用时三个小时多一些，做了四道题，感觉良好。第一天结束！！</p>\n"},{"title":"代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。","abbrlink":"b79a1ea","date":"2023-09-21T04:15:07.000Z","_content":"\n# 代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。\n\n## 977. 有序数组的平方\n\n>   题目链接：[leetcode链接](https://leetcode.cn/problems/squares-of-a-sorted-array/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0977.有序数组的平方.html)\n>\n>   视频讲解：[双指针法经典题目 | LeetCode：977.有序数组的平方](https://www.bilibili.com/video/BV1QB4y1D7ep )\n>\n>   状态：AC\n\n### 思路\n\n首先想到的是暴力算法，将每个元素计算平方，之后再将数组进行排序，此时的时间复杂度为`O(nlog n)`。但是并不满足题目中要求的`O(n)`，因为有一个条件我们还没有用上：**非递减顺序数组**。看了题解之后才清楚更好的方法：**双指针算法**。\n\n由于是非递减的数组，而且会有负数，那么在平方之后，得到的新数组的最后一位一定会在原数组的起始或者末尾位置。那么使用双指针算法相向遍历即可，得到最大的值放入到新数组的末尾。\n\n### 代码\n\n``` go\nfunc sortedSquares(nums []int) []int {\n\tn := len(nums)\n\tresult := make([]int, n)\n\tleft := 0\n\tright := len(nums) - 1\n\tfor i := right; i >= 0; i-- {  // i为result的索引\n\t\tif nums[left]*nums[left] < nums[right]*nums[right] {  // right侧更大\n\t\t\tresult[i] = nums[right] * nums[right]\n\t\t\tright--\n\t\t} else {  // left侧更大\n\t\t\tresult[i] = nums[left] * nums[left]\n\t\t\tleft++\n\t\t}\n\t}\n\treturn result\n}\n```\n\n## 209.长度最小的子数组\n\n>   题目链接：[leetcode链接](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html)\n>\n>   视频讲解：[拿下滑动窗口！ | LeetCode 209 长度最小的子数组](https://www.bilibili.com/video/BV1tZ4y1q7XE)\n>\n>   状态：AC\n\n### 思路\n\n此题需要找最短连续的一子数组，能想到的是 **滑动窗口** 算法。\n\n1.   设最短子数组长度`minLength`为无穷大，题目规定长度最大为100000，`minLength=100001`即可。\n2.   右侧不断向前，直至这一子数组的和大于 `target`\n3.   子序列和大于target之后，左侧也不断向前，直至子数组和小于 `target`，记录下此刻的序列长度，并与 `minLength` 进行比较。\n4.   循环条件：当右侧到头，并且此时的子数组的和小于`target`\n5.   退出循环后，如果`minLength`依旧等于100001，说明不存在满足要求的子数组，则返回`0`\n\n### 代码\n\n``` go\nfunc minSubArrayLen(target int, nums []int) int {\n\tleft := 0\n\tright := 0\n\tsum := 0\n\tminLength := 100001\n\tlength := len(nums)\n\tfor left <= right && right <= length {\n\t\tif sum < target {\n\t\t\tif right < length {\n\t\t\t\tsum += nums[right]\n\t\t\t\tright++\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tif minLength > right-left {\n\t\t\t\tminLength = right - left\n\t\t\t}\n\t\t\tsum -= nums[left]\n\t\t\tleft++\n\t\t}\n\t}\n\tif minLength == 100001 {\n\t\treturn 0\n\t}\n\treturn minLength\n}\n```\n\n## 59.螺旋矩阵II\n\n> 题目链接：[leetcode链接](https://leetcode.cn/problems/spiral-matrix-ii/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0059.螺旋矩阵II.html)\n>\n> 视频讲解：[一入循环深似海 | LeetCode：59.螺旋矩阵II](https://www.bilibili.com/video/BV1SL4y1N7mV/)\n>\n> 状态：AC\n\n### 思路\n\n![image-20230921130326208](../images/day02/image-20230921130326208.png)\n\n1.   循环次数是`n/2`\n\n2.   每次循环时候按照<font color=\"#4664b9\">蓝色</font>、<font color=\"#4f7633\">绿色</font>、<font color=\"#b0871e\">黄色</font>、<font color=\"#622a93\">紫色</font>的顺序填数字， 数字保持自增，保存结果的数组为`results`\n\n3.   各个颜色的范围，注意是从大到小还是从小到大：\n\n     <font color=\"#4664b9\">蓝色的范围：results\\[top\\][left ~ right - 1]</font>\n     <font color=\"#4f7633\">绿色的范围：results\\[top ~ bottom - 1\\][right]</font>\n\n     <font color=\"#b0871e\">黄色的范围：results\\[bottom\\][right ~ left + 1]</font>\n\n     <font color=\"#622a93\">紫色的范围：results[bottom ~ top + 1]\\[left\\]</font>\n\n4.   每一轮过后，`top++`、`bottom--`、`left++`、`right--`\n\n5.   额外的，如果n为基数，最中心的数字是在循环条件之外的，需要额外加上。\n\n### 代码\n\n``` go\nfunc generateMatrix(n int) [][]int {\n\ttop := 0\n\tbottom := n - 1\n\tleft := 0\n\tright := n - 1\n\tresult := make([][]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tresult[i] = make([]int, n)\n\t}\n\tnum := 1\n\tfor i := 0; i < n/2; i++ {\n\t\tfor j := left; j < right; j++ {\n\t\t\tresult[top][j] = num\n\t\t\tnum++\n\t\t}\n\n\t\tfor j := top; j < bottom; j++ {\n\t\t\tresult[j][right] = num\n\t\t\tnum++\n\t\t}\n\n\t\tfor j := right; j > left; j-- {\n\t\t\tresult[bottom][j] = num\n\t\t\tnum++\n\t\t}\n\t\tfor j := bottom; j > top; j-- {\n\t\t\tresult[j][left] = num\n\t\t\tnum++\n\t\t}\n\t\ttop++\n\t\tleft++\n\t\tright--\n\t\tbottom--\n\t}\n\tif n%2 == 1 {\n\t\tresult[n/2][n/2] = num\n\t}\n\treturn result\n}\n```\n\n## 小结\n\n-   帮助了群里一些录友解决了些问题，能看出来他们也比较萌新，想起了自己最开始大一学的时候，但是自己并没有坚持下去，很可惜。\n\n-   Go语言在初始化数组时候还不是很熟练，写的时候一直在思考int类型二维数组怎么初始化，但是用切片写起来还是简单一些吧\n\n    ``` go\n    result := make([][]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = make([]int, n)\n    }\n    ```\n\n    \n\n-   今天还有点别的事情，先写这么多，扩展题先不写了\n-   打卡第二天！\n","source":"_posts/day02.md","raw":"---\ntitle: 代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: b79a1ea\ndate: 2023-09-21 12:15:07\n---\n\n# 代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。\n\n## 977. 有序数组的平方\n\n>   题目链接：[leetcode链接](https://leetcode.cn/problems/squares-of-a-sorted-array/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0977.有序数组的平方.html)\n>\n>   视频讲解：[双指针法经典题目 | LeetCode：977.有序数组的平方](https://www.bilibili.com/video/BV1QB4y1D7ep )\n>\n>   状态：AC\n\n### 思路\n\n首先想到的是暴力算法，将每个元素计算平方，之后再将数组进行排序，此时的时间复杂度为`O(nlog n)`。但是并不满足题目中要求的`O(n)`，因为有一个条件我们还没有用上：**非递减顺序数组**。看了题解之后才清楚更好的方法：**双指针算法**。\n\n由于是非递减的数组，而且会有负数，那么在平方之后，得到的新数组的最后一位一定会在原数组的起始或者末尾位置。那么使用双指针算法相向遍历即可，得到最大的值放入到新数组的末尾。\n\n### 代码\n\n``` go\nfunc sortedSquares(nums []int) []int {\n\tn := len(nums)\n\tresult := make([]int, n)\n\tleft := 0\n\tright := len(nums) - 1\n\tfor i := right; i >= 0; i-- {  // i为result的索引\n\t\tif nums[left]*nums[left] < nums[right]*nums[right] {  // right侧更大\n\t\t\tresult[i] = nums[right] * nums[right]\n\t\t\tright--\n\t\t} else {  // left侧更大\n\t\t\tresult[i] = nums[left] * nums[left]\n\t\t\tleft++\n\t\t}\n\t}\n\treturn result\n}\n```\n\n## 209.长度最小的子数组\n\n>   题目链接：[leetcode链接](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html)\n>\n>   视频讲解：[拿下滑动窗口！ | LeetCode 209 长度最小的子数组](https://www.bilibili.com/video/BV1tZ4y1q7XE)\n>\n>   状态：AC\n\n### 思路\n\n此题需要找最短连续的一子数组，能想到的是 **滑动窗口** 算法。\n\n1.   设最短子数组长度`minLength`为无穷大，题目规定长度最大为100000，`minLength=100001`即可。\n2.   右侧不断向前，直至这一子数组的和大于 `target`\n3.   子序列和大于target之后，左侧也不断向前，直至子数组和小于 `target`，记录下此刻的序列长度，并与 `minLength` 进行比较。\n4.   循环条件：当右侧到头，并且此时的子数组的和小于`target`\n5.   退出循环后，如果`minLength`依旧等于100001，说明不存在满足要求的子数组，则返回`0`\n\n### 代码\n\n``` go\nfunc minSubArrayLen(target int, nums []int) int {\n\tleft := 0\n\tright := 0\n\tsum := 0\n\tminLength := 100001\n\tlength := len(nums)\n\tfor left <= right && right <= length {\n\t\tif sum < target {\n\t\t\tif right < length {\n\t\t\t\tsum += nums[right]\n\t\t\t\tright++\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tif minLength > right-left {\n\t\t\t\tminLength = right - left\n\t\t\t}\n\t\t\tsum -= nums[left]\n\t\t\tleft++\n\t\t}\n\t}\n\tif minLength == 100001 {\n\t\treturn 0\n\t}\n\treturn minLength\n}\n```\n\n## 59.螺旋矩阵II\n\n> 题目链接：[leetcode链接](https://leetcode.cn/problems/spiral-matrix-ii/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0059.螺旋矩阵II.html)\n>\n> 视频讲解：[一入循环深似海 | LeetCode：59.螺旋矩阵II](https://www.bilibili.com/video/BV1SL4y1N7mV/)\n>\n> 状态：AC\n\n### 思路\n\n![image-20230921130326208](../images/day02/image-20230921130326208.png)\n\n1.   循环次数是`n/2`\n\n2.   每次循环时候按照<font color=\"#4664b9\">蓝色</font>、<font color=\"#4f7633\">绿色</font>、<font color=\"#b0871e\">黄色</font>、<font color=\"#622a93\">紫色</font>的顺序填数字， 数字保持自增，保存结果的数组为`results`\n\n3.   各个颜色的范围，注意是从大到小还是从小到大：\n\n     <font color=\"#4664b9\">蓝色的范围：results\\[top\\][left ~ right - 1]</font>\n     <font color=\"#4f7633\">绿色的范围：results\\[top ~ bottom - 1\\][right]</font>\n\n     <font color=\"#b0871e\">黄色的范围：results\\[bottom\\][right ~ left + 1]</font>\n\n     <font color=\"#622a93\">紫色的范围：results[bottom ~ top + 1]\\[left\\]</font>\n\n4.   每一轮过后，`top++`、`bottom--`、`left++`、`right--`\n\n5.   额外的，如果n为基数，最中心的数字是在循环条件之外的，需要额外加上。\n\n### 代码\n\n``` go\nfunc generateMatrix(n int) [][]int {\n\ttop := 0\n\tbottom := n - 1\n\tleft := 0\n\tright := n - 1\n\tresult := make([][]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tresult[i] = make([]int, n)\n\t}\n\tnum := 1\n\tfor i := 0; i < n/2; i++ {\n\t\tfor j := left; j < right; j++ {\n\t\t\tresult[top][j] = num\n\t\t\tnum++\n\t\t}\n\n\t\tfor j := top; j < bottom; j++ {\n\t\t\tresult[j][right] = num\n\t\t\tnum++\n\t\t}\n\n\t\tfor j := right; j > left; j-- {\n\t\t\tresult[bottom][j] = num\n\t\t\tnum++\n\t\t}\n\t\tfor j := bottom; j > top; j-- {\n\t\t\tresult[j][left] = num\n\t\t\tnum++\n\t\t}\n\t\ttop++\n\t\tleft++\n\t\tright--\n\t\tbottom--\n\t}\n\tif n%2 == 1 {\n\t\tresult[n/2][n/2] = num\n\t}\n\treturn result\n}\n```\n\n## 小结\n\n-   帮助了群里一些录友解决了些问题，能看出来他们也比较萌新，想起了自己最开始大一学的时候，但是自己并没有坚持下去，很可惜。\n\n-   Go语言在初始化数组时候还不是很熟练，写的时候一直在思考int类型二维数组怎么初始化，但是用切片写起来还是简单一些吧\n\n    ``` go\n    result := make([][]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = make([]int, n)\n    }\n    ```\n\n    \n\n-   今天还有点别的事情，先写这么多，扩展题先不写了\n-   打卡第二天！\n","slug":"day02","published":1,"updated":"2023-10-04T11:44:13.087Z","_id":"cln7q7als0001vswhejetbqe1","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第二天-977-有序数组的平方、209-长度最小的子数组、59-螺旋矩阵II。\"><a href=\"#代码随想录算法训练营第二天-977-有序数组的平方、209-长度最小的子数组、59-螺旋矩阵II。\" class=\"headerlink\" title=\"代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。\"></a>代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。</h1><h2 id=\"977-有序数组的平方\"><a href=\"#977-有序数组的平方\" class=\"headerlink\" title=\"977. 有序数组的平方\"></a>977. 有序数组的平方</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/squares-of-a-sorted-array/\">leetcode链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1QB4y1D7ep\">双指针法经典题目 | LeetCode：977.有序数组的平方</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>首先想到的是暴力算法，将每个元素计算平方，之后再将数组进行排序，此时的时间复杂度为<code>O(nlog n)</code>。但是并不满足题目中要求的<code>O(n)</code>，因为有一个条件我们还没有用上：<strong>非递减顺序数组</strong>。看了题解之后才清楚更好的方法：<strong>双指针算法</strong>。</p>\n<p>由于是非递减的数组，而且会有负数，那么在平方之后，得到的新数组的最后一位一定会在原数组的起始或者末尾位置。那么使用双指针算法相向遍历即可，得到最大的值放入到新数组的末尾。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sortedSquares</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tn := <span class=\"hljs-built_in\">len</span>(nums)<br>\tresult := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n)<br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> i := right; i &gt;= <span class=\"hljs-number\">0</span>; i-- &#123;  <span class=\"hljs-comment\">// i为result的索引</span><br>\t\t<span class=\"hljs-keyword\">if</span> nums[left]*nums[left] &lt; nums[right]*nums[right] &#123;  <span class=\"hljs-comment\">// right侧更大</span><br>\t\t\tresult[i] = nums[right] * nums[right]<br>\t\t\tright--<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;  <span class=\"hljs-comment\">// left侧更大</span><br>\t\t\tresult[i] = nums[left] * nums[left]<br>\t\t\tleft++<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"209-长度最小的子数组\"><a href=\"#209-长度最小的子数组\" class=\"headerlink\" title=\"209.长度最小的子数组\"></a>209.长度最小的子数组</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/minimum-size-subarray-sum/\">leetcode链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1tZ4y1q7XE\">拿下滑动窗口！ | LeetCode 209 长度最小的子数组</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>此题需要找最短连续的一子数组，能想到的是 <strong>滑动窗口</strong> 算法。</p>\n<ol>\n<li>设最短子数组长度<code>minLength</code>为无穷大，题目规定长度最大为100000，<code>minLength=100001</code>即可。</li>\n<li>右侧不断向前，直至这一子数组的和大于 <code>target</code></li>\n<li>子序列和大于target之后，左侧也不断向前，直至子数组和小于 <code>target</code>，记录下此刻的序列长度，并与 <code>minLength</code> 进行比较。</li>\n<li>循环条件：当右侧到头，并且此时的子数组的和小于<code>target</code></li>\n<li>退出循环后，如果<code>minLength</code>依旧等于100001，说明不存在满足要求的子数组，则返回<code>0</code></li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minSubArrayLen</span><span class=\"hljs-params\">(target <span class=\"hljs-type\">int</span>, nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-number\">0</span><br>\tsum := <span class=\"hljs-number\">0</span><br>\tminLength := <span class=\"hljs-number\">100001</span><br>\tlength := <span class=\"hljs-built_in\">len</span>(nums)<br>\t<span class=\"hljs-keyword\">for</span> left &lt;= right &amp;&amp; right &lt;= length &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> sum &lt; target &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> right &lt; length &#123;<br>\t\t\t\tsum += nums[right]<br>\t\t\t\tright++<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t\t&#125;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> minLength &gt; right-left &#123;<br>\t\t\t\tminLength = right - left<br>\t\t\t&#125;<br>\t\t\tsum -= nums[left]<br>\t\t\tleft++<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> minLength == <span class=\"hljs-number\">100001</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> minLength<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"59-螺旋矩阵II\"><a href=\"#59-螺旋矩阵II\" class=\"headerlink\" title=\"59.螺旋矩阵II\"></a>59.螺旋矩阵II</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/spiral-matrix-ii/\">leetcode链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1SL4y1N7mV/\">一入循环深似海 | LeetCode：59.螺旋矩阵II</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p><img src=\"/../images/day02/image-20230921130326208.png\" alt=\"image-20230921130326208\"></p>\n<ol>\n<li><p>循环次数是<code>n/2</code></p>\n</li>\n<li><p>每次循环时候按照<font color=\"#4664b9\">蓝色</font>、<font color=\"#4f7633\">绿色</font>、<font color=\"#b0871e\">黄色</font>、<font color=\"#622a93\">紫色</font>的顺序填数字， 数字保持自增，保存结果的数组为<code>results</code></p>\n</li>\n<li><p>各个颜色的范围，注意是从大到小还是从小到大：</p>\n<p><font color=\"#4664b9\">蓝色的范围：results[top][left ~ right - 1]</font><br><font color=\"#4f7633\">绿色的范围：results[top ~ bottom - 1][right]</font></p>\n<p><font color=\"#b0871e\">黄色的范围：results[bottom][right ~ left + 1]</font></p>\n<p><font color=\"#622a93\">紫色的范围：results[bottom ~ top + 1][left]</font></p>\n</li>\n<li><p>每一轮过后，<code>top++</code>、<code>bottom--</code>、<code>left++</code>、<code>right--</code></p>\n</li>\n<li><p>额外的，如果n为基数，最中心的数字是在循环条件之外的，需要额外加上。</p>\n</li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">generateMatrix</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\ttop := <span class=\"hljs-number\">0</span><br>\tbottom := n - <span class=\"hljs-number\">1</span><br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := n - <span class=\"hljs-number\">1</span><br>\tresult := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, n)<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>\t\tresult[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n)<br>\t&#125;<br>\tnum := <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n/<span class=\"hljs-number\">2</span>; i++ &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> j := left; j &lt; right; j++ &#123;<br>\t\t\tresult[top][j] = num<br>\t\t\tnum++<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">for</span> j := top; j &lt; bottom; j++ &#123;<br>\t\t\tresult[j][right] = num<br>\t\t\tnum++<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">for</span> j := right; j &gt; left; j-- &#123;<br>\t\t\tresult[bottom][j] = num<br>\t\t\tnum++<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> j := bottom; j &gt; top; j-- &#123;<br>\t\t\tresult[j][left] = num<br>\t\t\tnum++<br>\t\t&#125;<br>\t\ttop++<br>\t\tleft++<br>\t\tright--<br>\t\tbottom--<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> n%<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span> &#123;<br>\t\tresult[n/<span class=\"hljs-number\">2</span>][n/<span class=\"hljs-number\">2</span>] = num<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li><p>帮助了群里一些录友解决了些问题，能看出来他们也比较萌新，想起了自己最开始大一学的时候，但是自己并没有坚持下去，很可惜。</p>\n</li>\n<li><p>Go语言在初始化数组时候还不是很熟练，写的时候一直在思考int类型二维数组怎么初始化，但是用切片写起来还是简单一些吧</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">result := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, n)<br><span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>    result[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>今天还有点别的事情，先写这么多，扩展题先不写了</p>\n</li>\n<li><p>打卡第二天！</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第二天-977-有序数组的平方、209-长度最小的子数组、59-螺旋矩阵II。\"><a href=\"#代码随想录算法训练营第二天-977-有序数组的平方、209-长度最小的子数组、59-螺旋矩阵II。\" class=\"headerlink\" title=\"代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。\"></a>代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。</h1><h2 id=\"977-有序数组的平方\"><a href=\"#977-有序数组的平方\" class=\"headerlink\" title=\"977. 有序数组的平方\"></a>977. 有序数组的平方</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/squares-of-a-sorted-array/\">leetcode链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1QB4y1D7ep\">双指针法经典题目 | LeetCode：977.有序数组的平方</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>首先想到的是暴力算法，将每个元素计算平方，之后再将数组进行排序，此时的时间复杂度为<code>O(nlog n)</code>。但是并不满足题目中要求的<code>O(n)</code>，因为有一个条件我们还没有用上：<strong>非递减顺序数组</strong>。看了题解之后才清楚更好的方法：<strong>双指针算法</strong>。</p>\n<p>由于是非递减的数组，而且会有负数，那么在平方之后，得到的新数组的最后一位一定会在原数组的起始或者末尾位置。那么使用双指针算法相向遍历即可，得到最大的值放入到新数组的末尾。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sortedSquares</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tn := <span class=\"hljs-built_in\">len</span>(nums)<br>\tresult := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n)<br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> i := right; i &gt;= <span class=\"hljs-number\">0</span>; i-- &#123;  <span class=\"hljs-comment\">// i为result的索引</span><br>\t\t<span class=\"hljs-keyword\">if</span> nums[left]*nums[left] &lt; nums[right]*nums[right] &#123;  <span class=\"hljs-comment\">// right侧更大</span><br>\t\t\tresult[i] = nums[right] * nums[right]<br>\t\t\tright--<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;  <span class=\"hljs-comment\">// left侧更大</span><br>\t\t\tresult[i] = nums[left] * nums[left]<br>\t\t\tleft++<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"209-长度最小的子数组\"><a href=\"#209-长度最小的子数组\" class=\"headerlink\" title=\"209.长度最小的子数组\"></a>209.长度最小的子数组</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/minimum-size-subarray-sum/\">leetcode链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1tZ4y1q7XE\">拿下滑动窗口！ | LeetCode 209 长度最小的子数组</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>此题需要找最短连续的一子数组，能想到的是 <strong>滑动窗口</strong> 算法。</p>\n<ol>\n<li>设最短子数组长度<code>minLength</code>为无穷大，题目规定长度最大为100000，<code>minLength=100001</code>即可。</li>\n<li>右侧不断向前，直至这一子数组的和大于 <code>target</code></li>\n<li>子序列和大于target之后，左侧也不断向前，直至子数组和小于 <code>target</code>，记录下此刻的序列长度，并与 <code>minLength</code> 进行比较。</li>\n<li>循环条件：当右侧到头，并且此时的子数组的和小于<code>target</code></li>\n<li>退出循环后，如果<code>minLength</code>依旧等于100001，说明不存在满足要求的子数组，则返回<code>0</code></li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minSubArrayLen</span><span class=\"hljs-params\">(target <span class=\"hljs-type\">int</span>, nums []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := <span class=\"hljs-number\">0</span><br>\tsum := <span class=\"hljs-number\">0</span><br>\tminLength := <span class=\"hljs-number\">100001</span><br>\tlength := <span class=\"hljs-built_in\">len</span>(nums)<br>\t<span class=\"hljs-keyword\">for</span> left &lt;= right &amp;&amp; right &lt;= length &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> sum &lt; target &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> right &lt; length &#123;<br>\t\t\t\tsum += nums[right]<br>\t\t\t\tright++<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t\t&#125;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> minLength &gt; right-left &#123;<br>\t\t\t\tminLength = right - left<br>\t\t\t&#125;<br>\t\t\tsum -= nums[left]<br>\t\t\tleft++<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> minLength == <span class=\"hljs-number\">100001</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> minLength<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"59-螺旋矩阵II\"><a href=\"#59-螺旋矩阵II\" class=\"headerlink\" title=\"59.螺旋矩阵II\"></a>59.螺旋矩阵II</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/spiral-matrix-ii/\">leetcode链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1SL4y1N7mV/\">一入循环深似海 | LeetCode：59.螺旋矩阵II</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p><img src=\"/../images/day02/image-20230921130326208.png\" alt=\"image-20230921130326208\"></p>\n<ol>\n<li><p>循环次数是<code>n/2</code></p>\n</li>\n<li><p>每次循环时候按照<font color=\"#4664b9\">蓝色</font>、<font color=\"#4f7633\">绿色</font>、<font color=\"#b0871e\">黄色</font>、<font color=\"#622a93\">紫色</font>的顺序填数字， 数字保持自增，保存结果的数组为<code>results</code></p>\n</li>\n<li><p>各个颜色的范围，注意是从大到小还是从小到大：</p>\n<p><font color=\"#4664b9\">蓝色的范围：results[top][left ~ right - 1]</font><br><font color=\"#4f7633\">绿色的范围：results[top ~ bottom - 1][right]</font></p>\n<p><font color=\"#b0871e\">黄色的范围：results[bottom][right ~ left + 1]</font></p>\n<p><font color=\"#622a93\">紫色的范围：results[bottom ~ top + 1][left]</font></p>\n</li>\n<li><p>每一轮过后，<code>top++</code>、<code>bottom--</code>、<code>left++</code>、<code>right--</code></p>\n</li>\n<li><p>额外的，如果n为基数，最中心的数字是在循环条件之外的，需要额外加上。</p>\n</li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">generateMatrix</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\ttop := <span class=\"hljs-number\">0</span><br>\tbottom := n - <span class=\"hljs-number\">1</span><br>\tleft := <span class=\"hljs-number\">0</span><br>\tright := n - <span class=\"hljs-number\">1</span><br>\tresult := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, n)<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>\t\tresult[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n)<br>\t&#125;<br>\tnum := <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n/<span class=\"hljs-number\">2</span>; i++ &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> j := left; j &lt; right; j++ &#123;<br>\t\t\tresult[top][j] = num<br>\t\t\tnum++<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">for</span> j := top; j &lt; bottom; j++ &#123;<br>\t\t\tresult[j][right] = num<br>\t\t\tnum++<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">for</span> j := right; j &gt; left; j-- &#123;<br>\t\t\tresult[bottom][j] = num<br>\t\t\tnum++<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> j := bottom; j &gt; top; j-- &#123;<br>\t\t\tresult[j][left] = num<br>\t\t\tnum++<br>\t\t&#125;<br>\t\ttop++<br>\t\tleft++<br>\t\tright--<br>\t\tbottom--<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> n%<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span> &#123;<br>\t\tresult[n/<span class=\"hljs-number\">2</span>][n/<span class=\"hljs-number\">2</span>] = num<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li><p>帮助了群里一些录友解决了些问题，能看出来他们也比较萌新，想起了自己最开始大一学的时候，但是自己并没有坚持下去，很可惜。</p>\n</li>\n<li><p>Go语言在初始化数组时候还不是很熟练，写的时候一直在思考int类型二维数组怎么初始化，但是用切片写起来还是简单一些吧</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">result := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, n)<br><span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>    result[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, n)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>今天还有点别的事情，先写这么多，扩展题先不写了</p>\n</li>\n<li><p>打卡第二天！</p>\n</li>\n</ul>\n"},{"title":"代码随想录算法训练营第四天| 24.两两交换链表中的节点、19.删除链表的倒数第N个节点、面试题02.07.链表相交、142.环形链表II。","abbrlink":"b4e3c0b1","date":"2023-09-23T13:32:23.000Z","_content":"\n# 代码随想录算法训练营第四天| 24.两两交换链表中的节点、19.删除链表的倒数第N个节点、面试题02.07.链表相交、142.环形链表II。\n\n## 24.两两交换链表中的节点\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0024.两两交换链表中的节点.html)\n>\n>   视频讲解：[帮你把链表细节学清楚！ | LeetCode：24. 两两交换链表中的节点](https://www.bilibili.com/video/BV1YT411g7br)\n>\n>   状态：AC\n\n### 思路\n\n1.   定义新的头结点，定义指针`p = newHead`，定义两个新的结点`tempNode1.Val = 2`，`tempNode2.Val = 1`（这里的值`1`和`2`是为了简化描述）\n\n<img src=\"../images/day04/IMG_1372.PNG\" alt=\"链表相关指针（变量说明）\" style=\"zoom:80%;\" />\n\n2.   使用新的结点重新进行连接，并且`p`前进到下一个位置（注意连接顺序，防止断链）\n     -   `tempNode2.Next = p.Next.Next.Next`\n     -   `tempNode1.Next = tempNode2`\n     -   `p.Next = tempNode1`\n     -   `p = p.Next.Next`\n\n<img src=\"../images/day04/IMG_1373.PNG\" alt=\"IMG_1373\" style=\"zoom:80%;\" />\n\n### 代码\n\n``` go\nfunc swapPairs(head *ListNode) *ListNode {\n\tnewHead := &ListNode{\n\t\tVal:  0,\n\t\tNext: head,\n\t}\n\tp := newHead\n\tfor p.Next != nil && p.Next.Next != nil {\n\t\ttempNode1 := &ListNode{\n\t\t\tVal:  p.Next.Next.Val,\n\t\t\tNext: nil,\n\t\t}\n\t\ttempNode2 := &ListNode{\n\t\t\tVal:  p.Next.Val,\n\t\t\tNext: p.Next.Next.Next,\n\t\t}\n\t\ttempNode1.Next = tempNode2\n\t\tp.Next = tempNode1\n\t\tp = p.Next.Next\n\t}\n\treturn newHead.Next\n}\n```\n\n\n\n## 19.删除链表的倒数第N个节点\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html#%E6%80%9D%E8%B7%AF)\n>\n>   视频讲解：[链表遍历学清楚！ | LeetCode：19.删除链表倒数第N个节点](https://www.bilibili.com/video/BV1vW4y1U7Gf)\n>\n>   状态：AC\n\n### 思路\n\n定义两个指针`p`和`q`，指针`p`先出发，指针`q`保持与`p`距离为`n`之后再出发，这样`q.Next`则是待删除的元素。\n\n>   会不会出现`n`大于链表长度的情况（例如链表长度为5，删除倒数第8个元素）：不会，leetcode题解中给出。\n>\n>   <img src=\"../images/day04/QQ20230923-221152.png\" alt=\"题目说明\" style=\"zoom:80%;\" />\n\n<img src=\"../images/day04/IMG_2D422EDB0DFC-1.jpeg\" alt=\"图解\" style=\"zoom:80%;\" />\n\n### 代码\n\n``` go\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil {\n\t\treturn head\n\t}\n\tnewHead := &ListNode{\n\t\tVal:  0,\n\t\tNext: head,\n\t}\n\tp := newHead\n\tfor i := 0; i <= n; i++ {\n\t\tp = p.Next\n\t}\n\tq := newHead\n\tfor p != nil {\n\t\tp = p.Next\n\t\tq = q.Next\n\t}\n\tif q.Next.Next != nil {\n\t\tq.Next = q.Next.Next\n\t} else {\n\t\tq.Next = nil\n\t}\n\n\treturn newHead.Next\n}\n```\n\n## 面试题02.07.链表相交\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html)\n>\n>   状态：AC\n\n### 思路\n\n假设是两个一维数组（只是为了方便逻辑上描述），查看是否相交，那么需要“尾部对齐”。假设长的链表开始的索引为0，我们需要从短的数组的开始。大意如下图\n\n<img src=\"../images/day04/160_1.png\" alt=\"判断第一组结点\" style=\"zoom:80%;\" />\n\n<img src=\"../images/day04/160_2.png\" alt=\"判断第二组结点\" style=\"zoom:80%;\" />\n\n<img src=\"../images/day04/160_3.png\" alt=\"判断第三组结点\" style=\"zoom:80%;\" />\n\n走到末尾都没发现有相同地址的节点则不存在相交的情况。\n\n-   尾部对齐操作：遍历两个链表（一组指针`p = newHeadA.Next`和`q = newHeadB.Next`），求各自的长度。\n-   重新定义一组指针（`p1 = newHeadA.Next`和`q1 = newHeadB.Next`），让其中更长的链表的指针移动到和短的同步位置<font color=\"#bdbdbd\">（这里可能是Go语言的特性？C语言不需要此操作，不重新定义指针p和q回不到起始位置）</font>\n-   同时向前移动，判断是否地址相同\n\n### 代码\n\n``` go\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    // 定义两个新的头，指向传参的头\n    newHeadA := &ListNode {\n        Val: 0,\n        Next: headA,\n    }\n    newHeadB := &ListNode {\n        Val: 0,\n        Next: headB,\n    }\n    // 求两个链表各自的长度\n    p := newHeadA.Next\n    lenA := 0\n    q := newHeadB.Next\n    lenB := 0\n    for p != nil {\n        p = p.Next\n        lenA++\n    }\n    for q != nil {\n        q = q.Next\n        lenB++\n    }\n    \n    // 定义两个新的指针，进行“对齐”操作\n    p1 := newHeadA.Next\n    q1 := newHeadB.Next\n    if lenA < lenB {\n        for i := 0; i < lenB - lenA; i++ {\n            q1 = q1.Next\n        }\n    } else {\n        for i := 0; i < lenA - lenB; i++ {\n            p1 = p1.Next\n        }\n    }\n    // 对齐后向前查找，找到了返回结点，否则为nil\n    for p1 != nil && q1 != nil {\n        if p1 == q1 {\n            return p1\n        } else {\n            p1 = p1.Next\n            q1 = q1.Next\n        }\n    }\n    return nil\n}\n```\n\n## 142. 环形链表II\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/linked-list-cycle-ii/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html)\n>\n>   视频讲解：[把环形链表讲清楚！| LeetCode:142.环形链表II](https://www.bilibili.com/video/BV1if4y1d7ob)\n>\n>   状态：想不出思路后看了卡哥的讲解恍然大悟，AC！\n\n### 思路\n\n<s><font color=\"#FF0000\">最开始没有审题，当成了这道题是在问是否存在环，后来发现这只是第一问</font></s>\n\n这道题需要返回的是：如果链表有环，那么返回最后一个结点链接到了哪个结点上。\n\n1.   首先要找到，链表是否有环，这里使用的是快慢指针的算法，快指针速度为2，慢指针速度为1。若快指针走到了终点说明没有环；如果两个指针相遇说明有环。\n\n     >   因为相对速度差1，所以二者必相遇\n\n2.   找到入口：（卡哥视频讲的很好，如果有疑问一定**看完视频**再提问）\n\n<img src=\"../images/day04/142_1.jpeg\" alt=\"142_1\" style=\"zoom:80%;\" />\n\n为什么一圈必定会追上：假设他们同时进入入口（整个链表就是个环），慢指针走一圈后，快指针走两圈。如果快指针先进入，那么追上慢指针必定走不到一圈。\n\n最后推出来x=z，意味着此时的快指针降速（速度变为1），同时新定义的指针从头开始运动，两者必定在入口处相遇\n\n### 代码\n\n``` go\nfunc detectCycle(head *ListNode) *ListNode {\n    fast := head\n    slow := head\n    p := head\n    // 这层for寻找环\n    for fast != nil {\n        slow = slow.Next\n        fast = fast.Next\n        if fast != nil {\n            fast = fast.Next\n            if slow == fast {  // 两指针相遇说明有环\n            for p != fast {  // 这层for执行的是公式中x=z的一步\n                p = p.Next\n                fast = fast.Next\n            }\n            return p\n            }\n        } else {\n            break\n        }        \n    }\n    return nil\n}\n```\n\n## 小结\n\n-   今天重新写了下链表的实现（主要是vscode没有装调试leetcode插件），部分题都是自己在GoLand中自己写函数构造的链表，最后单独写了个文件保存这部分代码（主要就是新建链表和打印链表），新建链表是通过一个数组传要初始化的值。当然了，今天的也只有两道题可以用，后两道直接在leetcode的网页上写了，看起来挺复杂的还担心不好debug，理清思路之后写起来很快，也不会出错。\n\n    ``` go\n    package InitLinkList\n    \n    import \"fmt\"\n    \n    type ListNode struct {\n    \tVal  int\n    \tNext *ListNode\n    }\n    \n    func InsertElem(head *ListNode, nums []int) *ListNode {\n    \tnewHead := &ListNode{\n    \t\tVal:  0,\n    \t\tNext: head,\n    \t}\n    \tp := newHead\n    \tfor _, v := range nums {\n    \t\tp.Next = &ListNode{\n    \t\t\tVal:  v,\n    \t\t\tNext: nil,\n    \t\t}\n    \t\tp = p.Next\n    \t}\n    \treturn newHead.Next\n    }\n    \n    func PrintList(head *ListNode) {\n    \tp := head\n    \tfor p != nil {\n    \t\tfmt.Printf(\"%d\\t\", p.Val)\n    \t\tp = p.Next\n    \t}\n    \tfmt.Println()\n    }\n    \n    ```\n\n-   Go有些语法还不是很了解，今天发现了跨文件调用需要将`变量名`和`函数名`首字母大写，也叫作导出。从一些语法来看Go现在给我的感觉他就不想Java那种强面向对象编程。这点还挺好的（对我个人而言），很灵活，调用的时候也不需要实例化（也没这一种说法）。\n\n-   后三道题（最后一道题指的求是否存在环的过程）考研复习408的时候已经见过，只不过这次的身份发生了变化，面对这道题状态也不同。考研复习时候遇到手撕代码的题首先想到的是如何拿分，没思路就暴力算法。有额外时间再考虑优化。如果再试卷上我可能会使用空间复杂度更大的算法，空间换时间。但是现在在求职中，要好好的理解每一道题，每一种优化的思路，题干加以限制：`空间复杂度为O(1)`。真的需要认真思考，链表相交没有想出来，看了卡哥的讲解理解了。\n-   现在的刷题状态是这样的：多给自己思考的时间争取想到最优的解法。无论是否解出来再去看看卡哥的讲解和代码，看看别人写的和自己写的差距在哪。我的代码现在经常出现这种逻辑，对于个别情况需要单独判断，而别人的则不需要，因为自己在边界情况考虑的欠妥。明天周日休息一天。但是事情还是挺多的。\n\n<font color=\"#3914a5\">第一周打卡结束！4天结束！</font>\n","source":"_posts/day04.md","raw":"---\ntitle: 代码随想录算法训练营第四天| 24.两两交换链表中的节点、19.删除链表的倒数第N个节点、面试题02.07.链表相交、142.环形链表II。\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: b4e3c0b1\ndate: 2023-09-23 21:32:23\n---\n\n# 代码随想录算法训练营第四天| 24.两两交换链表中的节点、19.删除链表的倒数第N个节点、面试题02.07.链表相交、142.环形链表II。\n\n## 24.两两交换链表中的节点\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0024.两两交换链表中的节点.html)\n>\n>   视频讲解：[帮你把链表细节学清楚！ | LeetCode：24. 两两交换链表中的节点](https://www.bilibili.com/video/BV1YT411g7br)\n>\n>   状态：AC\n\n### 思路\n\n1.   定义新的头结点，定义指针`p = newHead`，定义两个新的结点`tempNode1.Val = 2`，`tempNode2.Val = 1`（这里的值`1`和`2`是为了简化描述）\n\n<img src=\"../images/day04/IMG_1372.PNG\" alt=\"链表相关指针（变量说明）\" style=\"zoom:80%;\" />\n\n2.   使用新的结点重新进行连接，并且`p`前进到下一个位置（注意连接顺序，防止断链）\n     -   `tempNode2.Next = p.Next.Next.Next`\n     -   `tempNode1.Next = tempNode2`\n     -   `p.Next = tempNode1`\n     -   `p = p.Next.Next`\n\n<img src=\"../images/day04/IMG_1373.PNG\" alt=\"IMG_1373\" style=\"zoom:80%;\" />\n\n### 代码\n\n``` go\nfunc swapPairs(head *ListNode) *ListNode {\n\tnewHead := &ListNode{\n\t\tVal:  0,\n\t\tNext: head,\n\t}\n\tp := newHead\n\tfor p.Next != nil && p.Next.Next != nil {\n\t\ttempNode1 := &ListNode{\n\t\t\tVal:  p.Next.Next.Val,\n\t\t\tNext: nil,\n\t\t}\n\t\ttempNode2 := &ListNode{\n\t\t\tVal:  p.Next.Val,\n\t\t\tNext: p.Next.Next.Next,\n\t\t}\n\t\ttempNode1.Next = tempNode2\n\t\tp.Next = tempNode1\n\t\tp = p.Next.Next\n\t}\n\treturn newHead.Next\n}\n```\n\n\n\n## 19.删除链表的倒数第N个节点\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html#%E6%80%9D%E8%B7%AF)\n>\n>   视频讲解：[链表遍历学清楚！ | LeetCode：19.删除链表倒数第N个节点](https://www.bilibili.com/video/BV1vW4y1U7Gf)\n>\n>   状态：AC\n\n### 思路\n\n定义两个指针`p`和`q`，指针`p`先出发，指针`q`保持与`p`距离为`n`之后再出发，这样`q.Next`则是待删除的元素。\n\n>   会不会出现`n`大于链表长度的情况（例如链表长度为5，删除倒数第8个元素）：不会，leetcode题解中给出。\n>\n>   <img src=\"../images/day04/QQ20230923-221152.png\" alt=\"题目说明\" style=\"zoom:80%;\" />\n\n<img src=\"../images/day04/IMG_2D422EDB0DFC-1.jpeg\" alt=\"图解\" style=\"zoom:80%;\" />\n\n### 代码\n\n``` go\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil {\n\t\treturn head\n\t}\n\tnewHead := &ListNode{\n\t\tVal:  0,\n\t\tNext: head,\n\t}\n\tp := newHead\n\tfor i := 0; i <= n; i++ {\n\t\tp = p.Next\n\t}\n\tq := newHead\n\tfor p != nil {\n\t\tp = p.Next\n\t\tq = q.Next\n\t}\n\tif q.Next.Next != nil {\n\t\tq.Next = q.Next.Next\n\t} else {\n\t\tq.Next = nil\n\t}\n\n\treturn newHead.Next\n}\n```\n\n## 面试题02.07.链表相交\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html)\n>\n>   状态：AC\n\n### 思路\n\n假设是两个一维数组（只是为了方便逻辑上描述），查看是否相交，那么需要“尾部对齐”。假设长的链表开始的索引为0，我们需要从短的数组的开始。大意如下图\n\n<img src=\"../images/day04/160_1.png\" alt=\"判断第一组结点\" style=\"zoom:80%;\" />\n\n<img src=\"../images/day04/160_2.png\" alt=\"判断第二组结点\" style=\"zoom:80%;\" />\n\n<img src=\"../images/day04/160_3.png\" alt=\"判断第三组结点\" style=\"zoom:80%;\" />\n\n走到末尾都没发现有相同地址的节点则不存在相交的情况。\n\n-   尾部对齐操作：遍历两个链表（一组指针`p = newHeadA.Next`和`q = newHeadB.Next`），求各自的长度。\n-   重新定义一组指针（`p1 = newHeadA.Next`和`q1 = newHeadB.Next`），让其中更长的链表的指针移动到和短的同步位置<font color=\"#bdbdbd\">（这里可能是Go语言的特性？C语言不需要此操作，不重新定义指针p和q回不到起始位置）</font>\n-   同时向前移动，判断是否地址相同\n\n### 代码\n\n``` go\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    // 定义两个新的头，指向传参的头\n    newHeadA := &ListNode {\n        Val: 0,\n        Next: headA,\n    }\n    newHeadB := &ListNode {\n        Val: 0,\n        Next: headB,\n    }\n    // 求两个链表各自的长度\n    p := newHeadA.Next\n    lenA := 0\n    q := newHeadB.Next\n    lenB := 0\n    for p != nil {\n        p = p.Next\n        lenA++\n    }\n    for q != nil {\n        q = q.Next\n        lenB++\n    }\n    \n    // 定义两个新的指针，进行“对齐”操作\n    p1 := newHeadA.Next\n    q1 := newHeadB.Next\n    if lenA < lenB {\n        for i := 0; i < lenB - lenA; i++ {\n            q1 = q1.Next\n        }\n    } else {\n        for i := 0; i < lenA - lenB; i++ {\n            p1 = p1.Next\n        }\n    }\n    // 对齐后向前查找，找到了返回结点，否则为nil\n    for p1 != nil && q1 != nil {\n        if p1 == q1 {\n            return p1\n        } else {\n            p1 = p1.Next\n            q1 = q1.Next\n        }\n    }\n    return nil\n}\n```\n\n## 142. 环形链表II\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/linked-list-cycle-ii/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html)\n>\n>   视频讲解：[把环形链表讲清楚！| LeetCode:142.环形链表II](https://www.bilibili.com/video/BV1if4y1d7ob)\n>\n>   状态：想不出思路后看了卡哥的讲解恍然大悟，AC！\n\n### 思路\n\n<s><font color=\"#FF0000\">最开始没有审题，当成了这道题是在问是否存在环，后来发现这只是第一问</font></s>\n\n这道题需要返回的是：如果链表有环，那么返回最后一个结点链接到了哪个结点上。\n\n1.   首先要找到，链表是否有环，这里使用的是快慢指针的算法，快指针速度为2，慢指针速度为1。若快指针走到了终点说明没有环；如果两个指针相遇说明有环。\n\n     >   因为相对速度差1，所以二者必相遇\n\n2.   找到入口：（卡哥视频讲的很好，如果有疑问一定**看完视频**再提问）\n\n<img src=\"../images/day04/142_1.jpeg\" alt=\"142_1\" style=\"zoom:80%;\" />\n\n为什么一圈必定会追上：假设他们同时进入入口（整个链表就是个环），慢指针走一圈后，快指针走两圈。如果快指针先进入，那么追上慢指针必定走不到一圈。\n\n最后推出来x=z，意味着此时的快指针降速（速度变为1），同时新定义的指针从头开始运动，两者必定在入口处相遇\n\n### 代码\n\n``` go\nfunc detectCycle(head *ListNode) *ListNode {\n    fast := head\n    slow := head\n    p := head\n    // 这层for寻找环\n    for fast != nil {\n        slow = slow.Next\n        fast = fast.Next\n        if fast != nil {\n            fast = fast.Next\n            if slow == fast {  // 两指针相遇说明有环\n            for p != fast {  // 这层for执行的是公式中x=z的一步\n                p = p.Next\n                fast = fast.Next\n            }\n            return p\n            }\n        } else {\n            break\n        }        \n    }\n    return nil\n}\n```\n\n## 小结\n\n-   今天重新写了下链表的实现（主要是vscode没有装调试leetcode插件），部分题都是自己在GoLand中自己写函数构造的链表，最后单独写了个文件保存这部分代码（主要就是新建链表和打印链表），新建链表是通过一个数组传要初始化的值。当然了，今天的也只有两道题可以用，后两道直接在leetcode的网页上写了，看起来挺复杂的还担心不好debug，理清思路之后写起来很快，也不会出错。\n\n    ``` go\n    package InitLinkList\n    \n    import \"fmt\"\n    \n    type ListNode struct {\n    \tVal  int\n    \tNext *ListNode\n    }\n    \n    func InsertElem(head *ListNode, nums []int) *ListNode {\n    \tnewHead := &ListNode{\n    \t\tVal:  0,\n    \t\tNext: head,\n    \t}\n    \tp := newHead\n    \tfor _, v := range nums {\n    \t\tp.Next = &ListNode{\n    \t\t\tVal:  v,\n    \t\t\tNext: nil,\n    \t\t}\n    \t\tp = p.Next\n    \t}\n    \treturn newHead.Next\n    }\n    \n    func PrintList(head *ListNode) {\n    \tp := head\n    \tfor p != nil {\n    \t\tfmt.Printf(\"%d\\t\", p.Val)\n    \t\tp = p.Next\n    \t}\n    \tfmt.Println()\n    }\n    \n    ```\n\n-   Go有些语法还不是很了解，今天发现了跨文件调用需要将`变量名`和`函数名`首字母大写，也叫作导出。从一些语法来看Go现在给我的感觉他就不想Java那种强面向对象编程。这点还挺好的（对我个人而言），很灵活，调用的时候也不需要实例化（也没这一种说法）。\n\n-   后三道题（最后一道题指的求是否存在环的过程）考研复习408的时候已经见过，只不过这次的身份发生了变化，面对这道题状态也不同。考研复习时候遇到手撕代码的题首先想到的是如何拿分，没思路就暴力算法。有额外时间再考虑优化。如果再试卷上我可能会使用空间复杂度更大的算法，空间换时间。但是现在在求职中，要好好的理解每一道题，每一种优化的思路，题干加以限制：`空间复杂度为O(1)`。真的需要认真思考，链表相交没有想出来，看了卡哥的讲解理解了。\n-   现在的刷题状态是这样的：多给自己思考的时间争取想到最优的解法。无论是否解出来再去看看卡哥的讲解和代码，看看别人写的和自己写的差距在哪。我的代码现在经常出现这种逻辑，对于个别情况需要单独判断，而别人的则不需要，因为自己在边界情况考虑的欠妥。明天周日休息一天。但是事情还是挺多的。\n\n<font color=\"#3914a5\">第一周打卡结束！4天结束！</font>\n","slug":"day04","published":1,"updated":"2023-10-04T11:44:13.086Z","_id":"cln7q7alt0003vswh2kd6gmmb","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第四天-24-两两交换链表中的节点、19-删除链表的倒数第N个节点、面试题02-07-链表相交、142-环形链表II。\"><a href=\"#代码随想录算法训练营第四天-24-两两交换链表中的节点、19-删除链表的倒数第N个节点、面试题02-07-链表相交、142-环形链表II。\" class=\"headerlink\" title=\"代码随想录算法训练营第四天| 24.两两交换链表中的节点、19.删除链表的倒数第N个节点、面试题02.07.链表相交、142.环形链表II。\"></a>代码随想录算法训练营第四天| 24.两两交换链表中的节点、19.删除链表的倒数第N个节点、面试题02.07.链表相交、142.环形链表II。</h1><h2 id=\"24-两两交换链表中的节点\"><a href=\"#24-两两交换链表中的节点\" class=\"headerlink\" title=\"24.两两交换链表中的节点\"></a>24.两两交换链表中的节点</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/swap-nodes-in-pairs/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1YT411g7br\">帮你把链表细节学清楚！ | LeetCode：24. 两两交换链表中的节点</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>定义新的头结点，定义指针<code>p = newHead</code>，定义两个新的结点<code>tempNode1.Val = 2</code>，<code>tempNode2.Val = 1</code>（这里的值<code>1</code>和<code>2</code>是为了简化描述）</li>\n</ol>\n<img src=\"../images/day04/IMG_1372.PNG\" alt=\"链表相关指针（变量说明）\" style=\"zoom:80%;\" />\n\n<ol start=\"2\">\n<li>使用新的结点重新进行连接，并且<code>p</code>前进到下一个位置（注意连接顺序，防止断链）<ul>\n<li><code>tempNode2.Next = p.Next.Next.Next</code></li>\n<li><code>tempNode1.Next = tempNode2</code></li>\n<li><code>p.Next = tempNode1</code></li>\n<li><code>p = p.Next.Next</code></li>\n</ul>\n</li>\n</ol>\n<img src=\"../images/day04/IMG_1373.PNG\" alt=\"IMG_1373\" style=\"zoom:80%;\" />\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">swapPairs</span><span class=\"hljs-params\">(head *ListNode)</span></span> *ListNode &#123;<br>\tnewHead := &amp;ListNode&#123;<br>\t\tVal:  <span class=\"hljs-number\">0</span>,<br>\t\tNext: head,<br>\t&#125;<br>\tp := newHead<br>\t<span class=\"hljs-keyword\">for</span> p.Next != <span class=\"hljs-literal\">nil</span> &amp;&amp; p.Next.Next != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\ttempNode1 := &amp;ListNode&#123;<br>\t\t\tVal:  p.Next.Next.Val,<br>\t\t\tNext: <span class=\"hljs-literal\">nil</span>,<br>\t\t&#125;<br>\t\ttempNode2 := &amp;ListNode&#123;<br>\t\t\tVal:  p.Next.Val,<br>\t\t\tNext: p.Next.Next.Next,<br>\t\t&#125;<br>\t\ttempNode1.Next = tempNode2<br>\t\tp.Next = tempNode1<br>\t\tp = p.Next.Next<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> newHead.Next<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"19-删除链表的倒数第N个节点\"><a href=\"#19-删除链表的倒数第N个节点\" class=\"headerlink\" title=\"19.删除链表的倒数第N个节点\"></a>19.删除链表的倒数第N个节点</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html#%E6%80%9D%E8%B7%AF\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1vW4y1U7Gf\">链表遍历学清楚！ | LeetCode：19.删除链表倒数第N个节点</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>定义两个指针<code>p</code>和<code>q</code>，指针<code>p</code>先出发，指针<code>q</code>保持与<code>p</code>距离为<code>n</code>之后再出发，这样<code>q.Next</code>则是待删除的元素。</p>\n<blockquote>\n<p>  会不会出现<code>n</code>大于链表长度的情况（例如链表长度为5，删除倒数第8个元素）：不会，leetcode题解中给出。</p>\n  <img src=\"../images/day04/QQ20230923-221152.png\" alt=\"题目说明\" style=\"zoom:80%;\" />\n</blockquote>\n<img src=\"../images/day04/IMG_2D422EDB0DFC-1.jpeg\" alt=\"图解\" style=\"zoom:80%;\" />\n\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">removeNthFromEnd</span><span class=\"hljs-params\">(head *ListNode, n <span class=\"hljs-type\">int</span>)</span></span> *ListNode &#123;<br>\t<span class=\"hljs-keyword\">if</span> head == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> head<br>\t&#125;<br>\tnewHead := &amp;ListNode&#123;<br>\t\tVal:  <span class=\"hljs-number\">0</span>,<br>\t\tNext: head,<br>\t&#125;<br>\tp := newHead<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt;= n; i++ &#123;<br>\t\tp = p.Next<br>\t&#125;<br>\tq := newHead<br>\t<span class=\"hljs-keyword\">for</span> p != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tp = p.Next<br>\t\tq = q.Next<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> q.Next.Next != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tq.Next = q.Next.Next<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\tq.Next = <span class=\"hljs-literal\">nil</span><br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> newHead.Next<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"面试题02-07-链表相交\"><a href=\"#面试题02-07-链表相交\" class=\"headerlink\" title=\"面试题02.07.链表相交\"></a>面试题02.07.链表相交</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html\">代码随想录(programmercarl.com)</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>假设是两个一维数组（只是为了方便逻辑上描述），查看是否相交，那么需要“尾部对齐”。假设长的链表开始的索引为0，我们需要从短的数组的开始。大意如下图</p>\n<img src=\"../images/day04/160_1.png\" alt=\"判断第一组结点\" style=\"zoom:80%;\" />\n\n<img src=\"../images/day04/160_2.png\" alt=\"判断第二组结点\" style=\"zoom:80%;\" />\n\n<img src=\"../images/day04/160_3.png\" alt=\"判断第三组结点\" style=\"zoom:80%;\" />\n\n<p>走到末尾都没发现有相同地址的节点则不存在相交的情况。</p>\n<ul>\n<li>尾部对齐操作：遍历两个链表（一组指针<code>p = newHeadA.Next</code>和<code>q = newHeadB.Next</code>），求各自的长度。</li>\n<li>重新定义一组指针（<code>p1 = newHeadA.Next</code>和<code>q1 = newHeadB.Next</code>），让其中更长的链表的指针移动到和短的同步位置<font color=\"#bdbdbd\">（这里可能是Go语言的特性？C语言不需要此操作，不重新定义指针p和q回不到起始位置）</font></li>\n<li>同时向前移动，判断是否地址相同</li>\n</ul>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getIntersectionNode</span><span class=\"hljs-params\">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    <span class=\"hljs-comment\">// 定义两个新的头，指向传参的头</span><br>    newHeadA := &amp;ListNode &#123;<br>        Val: <span class=\"hljs-number\">0</span>,<br>        Next: headA,<br>    &#125;<br>    newHeadB := &amp;ListNode &#123;<br>        Val: <span class=\"hljs-number\">0</span>,<br>        Next: headB,<br>    &#125;<br>    <span class=\"hljs-comment\">// 求两个链表各自的长度</span><br>    p := newHeadA.Next<br>    lenA := <span class=\"hljs-number\">0</span><br>    q := newHeadB.Next<br>    lenB := <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">for</span> p != <span class=\"hljs-literal\">nil</span> &#123;<br>        p = p.Next<br>        lenA++<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> q != <span class=\"hljs-literal\">nil</span> &#123;<br>        q = q.Next<br>        lenB++<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 定义两个新的指针，进行“对齐”操作</span><br>    p1 := newHeadA.Next<br>    q1 := newHeadB.Next<br>    <span class=\"hljs-keyword\">if</span> lenA &lt; lenB &#123;<br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; lenB - lenA; i++ &#123;<br>            q1 = q1.Next<br>        &#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; lenA - lenB; i++ &#123;<br>            p1 = p1.Next<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">// 对齐后向前查找，找到了返回结点，否则为nil</span><br>    <span class=\"hljs-keyword\">for</span> p1 != <span class=\"hljs-literal\">nil</span> &amp;&amp; q1 != <span class=\"hljs-literal\">nil</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> p1 == q1 &#123;<br>            <span class=\"hljs-keyword\">return</span> p1<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            p1 = p1.Next<br>            q1 = q1.Next<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"142-环形链表II\"><a href=\"#142-环形链表II\" class=\"headerlink\" title=\"142. 环形链表II\"></a>142. 环形链表II</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/linked-list-cycle-ii/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1if4y1d7ob\">把环形链表讲清楚！| LeetCode:142.环形链表II</a></p>\n<p>  状态：想不出思路后看了卡哥的讲解恍然大悟，AC！</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p><s><font color=\"#FF0000\">最开始没有审题，当成了这道题是在问是否存在环，后来发现这只是第一问</font></s></p>\n<p>这道题需要返回的是：如果链表有环，那么返回最后一个结点链接到了哪个结点上。</p>\n<ol>\n<li><p>首先要找到，链表是否有环，这里使用的是快慢指针的算法，快指针速度为2，慢指针速度为1。若快指针走到了终点说明没有环；如果两个指针相遇说明有环。</p>\n<blockquote>\n<p>  因为相对速度差1，所以二者必相遇</p>\n</blockquote>\n</li>\n<li><p>找到入口：（卡哥视频讲的很好，如果有疑问一定<strong>看完视频</strong>再提问）</p>\n</li>\n</ol>\n<img src=\"../images/day04/142_1.jpeg\" alt=\"142_1\" style=\"zoom:80%;\" />\n\n<p>为什么一圈必定会追上：假设他们同时进入入口（整个链表就是个环），慢指针走一圈后，快指针走两圈。如果快指针先进入，那么追上慢指针必定走不到一圈。</p>\n<p>最后推出来x&#x3D;z，意味着此时的快指针降速（速度变为1），同时新定义的指针从头开始运动，两者必定在入口处相遇</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">detectCycle</span><span class=\"hljs-params\">(head *ListNode)</span></span> *ListNode &#123;<br>    fast := head<br>    slow := head<br>    p := head<br>    <span class=\"hljs-comment\">// 这层for寻找环</span><br>    <span class=\"hljs-keyword\">for</span> fast != <span class=\"hljs-literal\">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next<br>        <span class=\"hljs-keyword\">if</span> fast != <span class=\"hljs-literal\">nil</span> &#123;<br>            fast = fast.Next<br>            <span class=\"hljs-keyword\">if</span> slow == fast &#123;  <span class=\"hljs-comment\">// 两指针相遇说明有环</span><br>            <span class=\"hljs-keyword\">for</span> p != fast &#123;  <span class=\"hljs-comment\">// 这层for执行的是公式中x=z的一步</span><br>                p = p.Next<br>                fast = fast.Next<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> p<br>            &#125;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">break</span><br>        &#125;        <br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li><p>今天重新写了下链表的实现（主要是vscode没有装调试leetcode插件），部分题都是自己在GoLand中自己写函数构造的链表，最后单独写了个文件保存这部分代码（主要就是新建链表和打印链表），新建链表是通过一个数组传要初始化的值。当然了，今天的也只有两道题可以用，后两道直接在leetcode的网页上写了，看起来挺复杂的还担心不好debug，理清思路之后写起来很快，也不会出错。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> InitLinkList<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><br><span class=\"hljs-keyword\">type</span> ListNode <span class=\"hljs-keyword\">struct</span> &#123;<br>\tVal  <span class=\"hljs-type\">int</span><br>\tNext *ListNode<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">InsertElem</span><span class=\"hljs-params\">(head *ListNode, nums []<span class=\"hljs-type\">int</span>)</span></span> *ListNode &#123;<br>\tnewHead := &amp;ListNode&#123;<br>\t\tVal:  <span class=\"hljs-number\">0</span>,<br>\t\tNext: head,<br>\t&#125;<br>\tp := newHead<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>\t\tp.Next = &amp;ListNode&#123;<br>\t\t\tVal:  v,<br>\t\t\tNext: <span class=\"hljs-literal\">nil</span>,<br>\t\t&#125;<br>\t\tp = p.Next<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> newHead.Next<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">PrintList</span><span class=\"hljs-params\">(head *ListNode)</span></span> &#123;<br>\tp := head<br>\t<span class=\"hljs-keyword\">for</span> p != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tfmt.Printf(<span class=\"hljs-string\">&quot;%d\\t&quot;</span>, p.Val)<br>\t\tp = p.Next<br>\t&#125;<br>\tfmt.Println()<br>&#125;<br><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>Go有些语法还不是很了解，今天发现了跨文件调用需要将<code>变量名</code>和<code>函数名</code>首字母大写，也叫作导出。从一些语法来看Go现在给我的感觉他就不想Java那种强面向对象编程。这点还挺好的（对我个人而言），很灵活，调用的时候也不需要实例化（也没这一种说法）。</p>\n</li>\n<li><p>后三道题（最后一道题指的求是否存在环的过程）考研复习408的时候已经见过，只不过这次的身份发生了变化，面对这道题状态也不同。考研复习时候遇到手撕代码的题首先想到的是如何拿分，没思路就暴力算法。有额外时间再考虑优化。如果再试卷上我可能会使用空间复杂度更大的算法，空间换时间。但是现在在求职中，要好好的理解每一道题，每一种优化的思路，题干加以限制：<code>空间复杂度为O(1)</code>。真的需要认真思考，链表相交没有想出来，看了卡哥的讲解理解了。</p>\n</li>\n<li><p>现在的刷题状态是这样的：多给自己思考的时间争取想到最优的解法。无论是否解出来再去看看卡哥的讲解和代码，看看别人写的和自己写的差距在哪。我的代码现在经常出现这种逻辑，对于个别情况需要单独判断，而别人的则不需要，因为自己在边界情况考虑的欠妥。明天周日休息一天。但是事情还是挺多的。</p>\n</li>\n</ul>\n<p><font color=\"#3914a5\">第一周打卡结束！4天结束！</font></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第四天-24-两两交换链表中的节点、19-删除链表的倒数第N个节点、面试题02-07-链表相交、142-环形链表II。\"><a href=\"#代码随想录算法训练营第四天-24-两两交换链表中的节点、19-删除链表的倒数第N个节点、面试题02-07-链表相交、142-环形链表II。\" class=\"headerlink\" title=\"代码随想录算法训练营第四天| 24.两两交换链表中的节点、19.删除链表的倒数第N个节点、面试题02.07.链表相交、142.环形链表II。\"></a>代码随想录算法训练营第四天| 24.两两交换链表中的节点、19.删除链表的倒数第N个节点、面试题02.07.链表相交、142.环形链表II。</h1><h2 id=\"24-两两交换链表中的节点\"><a href=\"#24-两两交换链表中的节点\" class=\"headerlink\" title=\"24.两两交换链表中的节点\"></a>24.两两交换链表中的节点</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/swap-nodes-in-pairs/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1YT411g7br\">帮你把链表细节学清楚！ | LeetCode：24. 两两交换链表中的节点</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>定义新的头结点，定义指针<code>p = newHead</code>，定义两个新的结点<code>tempNode1.Val = 2</code>，<code>tempNode2.Val = 1</code>（这里的值<code>1</code>和<code>2</code>是为了简化描述）</li>\n</ol>\n<img src=\"../images/day04/IMG_1372.PNG\" alt=\"链表相关指针（变量说明）\" style=\"zoom:80%;\" />\n\n<ol start=\"2\">\n<li>使用新的结点重新进行连接，并且<code>p</code>前进到下一个位置（注意连接顺序，防止断链）<ul>\n<li><code>tempNode2.Next = p.Next.Next.Next</code></li>\n<li><code>tempNode1.Next = tempNode2</code></li>\n<li><code>p.Next = tempNode1</code></li>\n<li><code>p = p.Next.Next</code></li>\n</ul>\n</li>\n</ol>\n<img src=\"../images/day04/IMG_1373.PNG\" alt=\"IMG_1373\" style=\"zoom:80%;\" />\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">swapPairs</span><span class=\"hljs-params\">(head *ListNode)</span></span> *ListNode &#123;<br>\tnewHead := &amp;ListNode&#123;<br>\t\tVal:  <span class=\"hljs-number\">0</span>,<br>\t\tNext: head,<br>\t&#125;<br>\tp := newHead<br>\t<span class=\"hljs-keyword\">for</span> p.Next != <span class=\"hljs-literal\">nil</span> &amp;&amp; p.Next.Next != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\ttempNode1 := &amp;ListNode&#123;<br>\t\t\tVal:  p.Next.Next.Val,<br>\t\t\tNext: <span class=\"hljs-literal\">nil</span>,<br>\t\t&#125;<br>\t\ttempNode2 := &amp;ListNode&#123;<br>\t\t\tVal:  p.Next.Val,<br>\t\t\tNext: p.Next.Next.Next,<br>\t\t&#125;<br>\t\ttempNode1.Next = tempNode2<br>\t\tp.Next = tempNode1<br>\t\tp = p.Next.Next<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> newHead.Next<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"19-删除链表的倒数第N个节点\"><a href=\"#19-删除链表的倒数第N个节点\" class=\"headerlink\" title=\"19.删除链表的倒数第N个节点\"></a>19.删除链表的倒数第N个节点</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html#%E6%80%9D%E8%B7%AF\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1vW4y1U7Gf\">链表遍历学清楚！ | LeetCode：19.删除链表倒数第N个节点</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>定义两个指针<code>p</code>和<code>q</code>，指针<code>p</code>先出发，指针<code>q</code>保持与<code>p</code>距离为<code>n</code>之后再出发，这样<code>q.Next</code>则是待删除的元素。</p>\n<blockquote>\n<p>  会不会出现<code>n</code>大于链表长度的情况（例如链表长度为5，删除倒数第8个元素）：不会，leetcode题解中给出。</p>\n  <img src=\"../images/day04/QQ20230923-221152.png\" alt=\"题目说明\" style=\"zoom:80%;\" />\n</blockquote>\n<img src=\"../images/day04/IMG_2D422EDB0DFC-1.jpeg\" alt=\"图解\" style=\"zoom:80%;\" />\n\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">removeNthFromEnd</span><span class=\"hljs-params\">(head *ListNode, n <span class=\"hljs-type\">int</span>)</span></span> *ListNode &#123;<br>\t<span class=\"hljs-keyword\">if</span> head == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> head<br>\t&#125;<br>\tnewHead := &amp;ListNode&#123;<br>\t\tVal:  <span class=\"hljs-number\">0</span>,<br>\t\tNext: head,<br>\t&#125;<br>\tp := newHead<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt;= n; i++ &#123;<br>\t\tp = p.Next<br>\t&#125;<br>\tq := newHead<br>\t<span class=\"hljs-keyword\">for</span> p != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tp = p.Next<br>\t\tq = q.Next<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> q.Next.Next != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tq.Next = q.Next.Next<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\tq.Next = <span class=\"hljs-literal\">nil</span><br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> newHead.Next<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"面试题02-07-链表相交\"><a href=\"#面试题02-07-链表相交\" class=\"headerlink\" title=\"面试题02.07.链表相交\"></a>面试题02.07.链表相交</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html\">代码随想录(programmercarl.com)</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>假设是两个一维数组（只是为了方便逻辑上描述），查看是否相交，那么需要“尾部对齐”。假设长的链表开始的索引为0，我们需要从短的数组的开始。大意如下图</p>\n<img src=\"../images/day04/160_1.png\" alt=\"判断第一组结点\" style=\"zoom:80%;\" />\n\n<img src=\"../images/day04/160_2.png\" alt=\"判断第二组结点\" style=\"zoom:80%;\" />\n\n<img src=\"../images/day04/160_3.png\" alt=\"判断第三组结点\" style=\"zoom:80%;\" />\n\n<p>走到末尾都没发现有相同地址的节点则不存在相交的情况。</p>\n<ul>\n<li>尾部对齐操作：遍历两个链表（一组指针<code>p = newHeadA.Next</code>和<code>q = newHeadB.Next</code>），求各自的长度。</li>\n<li>重新定义一组指针（<code>p1 = newHeadA.Next</code>和<code>q1 = newHeadB.Next</code>），让其中更长的链表的指针移动到和短的同步位置<font color=\"#bdbdbd\">（这里可能是Go语言的特性？C语言不需要此操作，不重新定义指针p和q回不到起始位置）</font></li>\n<li>同时向前移动，判断是否地址相同</li>\n</ul>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getIntersectionNode</span><span class=\"hljs-params\">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    <span class=\"hljs-comment\">// 定义两个新的头，指向传参的头</span><br>    newHeadA := &amp;ListNode &#123;<br>        Val: <span class=\"hljs-number\">0</span>,<br>        Next: headA,<br>    &#125;<br>    newHeadB := &amp;ListNode &#123;<br>        Val: <span class=\"hljs-number\">0</span>,<br>        Next: headB,<br>    &#125;<br>    <span class=\"hljs-comment\">// 求两个链表各自的长度</span><br>    p := newHeadA.Next<br>    lenA := <span class=\"hljs-number\">0</span><br>    q := newHeadB.Next<br>    lenB := <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">for</span> p != <span class=\"hljs-literal\">nil</span> &#123;<br>        p = p.Next<br>        lenA++<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> q != <span class=\"hljs-literal\">nil</span> &#123;<br>        q = q.Next<br>        lenB++<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 定义两个新的指针，进行“对齐”操作</span><br>    p1 := newHeadA.Next<br>    q1 := newHeadB.Next<br>    <span class=\"hljs-keyword\">if</span> lenA &lt; lenB &#123;<br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; lenB - lenA; i++ &#123;<br>            q1 = q1.Next<br>        &#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; lenA - lenB; i++ &#123;<br>            p1 = p1.Next<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">// 对齐后向前查找，找到了返回结点，否则为nil</span><br>    <span class=\"hljs-keyword\">for</span> p1 != <span class=\"hljs-literal\">nil</span> &amp;&amp; q1 != <span class=\"hljs-literal\">nil</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> p1 == q1 &#123;<br>            <span class=\"hljs-keyword\">return</span> p1<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            p1 = p1.Next<br>            q1 = q1.Next<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"142-环形链表II\"><a href=\"#142-环形链表II\" class=\"headerlink\" title=\"142. 环形链表II\"></a>142. 环形链表II</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/linked-list-cycle-ii/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1if4y1d7ob\">把环形链表讲清楚！| LeetCode:142.环形链表II</a></p>\n<p>  状态：想不出思路后看了卡哥的讲解恍然大悟，AC！</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p><s><font color=\"#FF0000\">最开始没有审题，当成了这道题是在问是否存在环，后来发现这只是第一问</font></s></p>\n<p>这道题需要返回的是：如果链表有环，那么返回最后一个结点链接到了哪个结点上。</p>\n<ol>\n<li><p>首先要找到，链表是否有环，这里使用的是快慢指针的算法，快指针速度为2，慢指针速度为1。若快指针走到了终点说明没有环；如果两个指针相遇说明有环。</p>\n<blockquote>\n<p>  因为相对速度差1，所以二者必相遇</p>\n</blockquote>\n</li>\n<li><p>找到入口：（卡哥视频讲的很好，如果有疑问一定<strong>看完视频</strong>再提问）</p>\n</li>\n</ol>\n<img src=\"../images/day04/142_1.jpeg\" alt=\"142_1\" style=\"zoom:80%;\" />\n\n<p>为什么一圈必定会追上：假设他们同时进入入口（整个链表就是个环），慢指针走一圈后，快指针走两圈。如果快指针先进入，那么追上慢指针必定走不到一圈。</p>\n<p>最后推出来x&#x3D;z，意味着此时的快指针降速（速度变为1），同时新定义的指针从头开始运动，两者必定在入口处相遇</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">detectCycle</span><span class=\"hljs-params\">(head *ListNode)</span></span> *ListNode &#123;<br>    fast := head<br>    slow := head<br>    p := head<br>    <span class=\"hljs-comment\">// 这层for寻找环</span><br>    <span class=\"hljs-keyword\">for</span> fast != <span class=\"hljs-literal\">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next<br>        <span class=\"hljs-keyword\">if</span> fast != <span class=\"hljs-literal\">nil</span> &#123;<br>            fast = fast.Next<br>            <span class=\"hljs-keyword\">if</span> slow == fast &#123;  <span class=\"hljs-comment\">// 两指针相遇说明有环</span><br>            <span class=\"hljs-keyword\">for</span> p != fast &#123;  <span class=\"hljs-comment\">// 这层for执行的是公式中x=z的一步</span><br>                p = p.Next<br>                fast = fast.Next<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> p<br>            &#125;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">break</span><br>        &#125;        <br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li><p>今天重新写了下链表的实现（主要是vscode没有装调试leetcode插件），部分题都是自己在GoLand中自己写函数构造的链表，最后单独写了个文件保存这部分代码（主要就是新建链表和打印链表），新建链表是通过一个数组传要初始化的值。当然了，今天的也只有两道题可以用，后两道直接在leetcode的网页上写了，看起来挺复杂的还担心不好debug，理清思路之后写起来很快，也不会出错。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> InitLinkList<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><br><span class=\"hljs-keyword\">type</span> ListNode <span class=\"hljs-keyword\">struct</span> &#123;<br>\tVal  <span class=\"hljs-type\">int</span><br>\tNext *ListNode<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">InsertElem</span><span class=\"hljs-params\">(head *ListNode, nums []<span class=\"hljs-type\">int</span>)</span></span> *ListNode &#123;<br>\tnewHead := &amp;ListNode&#123;<br>\t\tVal:  <span class=\"hljs-number\">0</span>,<br>\t\tNext: head,<br>\t&#125;<br>\tp := newHead<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>\t\tp.Next = &amp;ListNode&#123;<br>\t\t\tVal:  v,<br>\t\t\tNext: <span class=\"hljs-literal\">nil</span>,<br>\t\t&#125;<br>\t\tp = p.Next<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> newHead.Next<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">PrintList</span><span class=\"hljs-params\">(head *ListNode)</span></span> &#123;<br>\tp := head<br>\t<span class=\"hljs-keyword\">for</span> p != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tfmt.Printf(<span class=\"hljs-string\">&quot;%d\\t&quot;</span>, p.Val)<br>\t\tp = p.Next<br>\t&#125;<br>\tfmt.Println()<br>&#125;<br><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>Go有些语法还不是很了解，今天发现了跨文件调用需要将<code>变量名</code>和<code>函数名</code>首字母大写，也叫作导出。从一些语法来看Go现在给我的感觉他就不想Java那种强面向对象编程。这点还挺好的（对我个人而言），很灵活，调用的时候也不需要实例化（也没这一种说法）。</p>\n</li>\n<li><p>后三道题（最后一道题指的求是否存在环的过程）考研复习408的时候已经见过，只不过这次的身份发生了变化，面对这道题状态也不同。考研复习时候遇到手撕代码的题首先想到的是如何拿分，没思路就暴力算法。有额外时间再考虑优化。如果再试卷上我可能会使用空间复杂度更大的算法，空间换时间。但是现在在求职中，要好好的理解每一道题，每一种优化的思路，题干加以限制：<code>空间复杂度为O(1)</code>。真的需要认真思考，链表相交没有想出来，看了卡哥的讲解理解了。</p>\n</li>\n<li><p>现在的刷题状态是这样的：多给自己思考的时间争取想到最优的解法。无论是否解出来再去看看卡哥的讲解和代码，看看别人写的和自己写的差距在哪。我的代码现在经常出现这种逻辑，对于个别情况需要单独判断，而别人的则不需要，因为自己在边界情况考虑的欠妥。明天周日休息一天。但是事情还是挺多的。</p>\n</li>\n</ul>\n<p><font color=\"#3914a5\">第一周打卡结束！4天结束！</font></p>\n"},{"title":"代码随想录算法训练营第三天| 203.移除链表元素、707.设计链表、206.反转链表。","abbrlink":"bd069431","date":"2023-09-22T16:08:21.000Z","_content":"\n# 代码随想录算法训练营第三天| 203.移除链表元素、707.设计链表、206.反转链表。\n\n## 203. 移除链表元素\n\n> 题目链接：[leetcode题目链接](https://leetcode.cn/problems/remove-linked-list-elements/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html)\n>\n> 视频讲解：[链表基础操作| LeetCode：203.移除链表元素](https://www.bilibili.com/video/BV18B4y1s7R9)\n>\n> 状态：AC\n\n### 思路\n\n删除元素还是比较简单的，假设`q = p.Next`，如果删除`q`则是`p.Next = p.Next.Next`，考虑下`p.Next.Next`是否存在即可\n\n### 代码\n\n``` go\nfunc removeElements(head *ListNode, val int) *ListNode {\n\tnewHead := new(ListNode)\n\tnewHead.Next = head\n\tp := newHead\n\tfor p.Next != nil {\n\t\tif p.Next.Val == val {\n\t\t\tp.Next = p.Next.Next\n\t\t} else {\n\t\t\tp = p.Next\n\t\t}\n\t}\n\treturn newHead.Next\n}\n```\n\n\n\n## 707. 设计链表\n\n> 题目链接：[leetcode题目链接](https://leetcode.cn/problems/design-linked-list/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html)\n>\n> 视频讲解：[帮你把链表操作学个通透！LeetCode：707.设计链表](https://www.bilibili.com/video/BV1FU4y1X7WD)\n>\n> 状态：半AC（AC了但是也没完全AC）\n\n### 思路\n\n- `(this *MyLinkedList)get(index int) int`: 先判断index是否合法，所以需要引入一个新的成员对象`size`在`MyLinkedList`中\n- `(this *MyLinkedList)AddAtHead(val int)`: 头插法只需要在新的头之后接入一个新的节点，然后`size++`\n- `(this *MyLinkedList)AddAtTail(val int)`: 尾插法只需要在整个链表之后接入一个新的节点，然后`size++`\n- `(this *MyLinkedList)DeleteAtIndex(index int)`: 删除一个元素类似上一题，只不过要判断index是否合法\n- `(this *MyLinkedList)AddAtIndex(index int, val)`: 先判断index是否合法，找到正确位置进行插入\n\n### 代码\n\n``` go\n\ntype LinkList struct {\n\tVal  int\n\tNext *LinkList\n}\n\ntype MyLinkedList struct {\n\tsize    int\n\tnewHead *LinkList\n}\n\nfunc Constructor() MyLinkedList {\n\t//return MyLinkedList{}\n\tnode := &LinkList{\n\t\tVal:  0,\n\t\tNext: nil,\n\t}\n\treturn MyLinkedList{\n\t\tnewHead: node,\n\t\tsize:    0,\n\t}\n}\n\nfunc (this *MyLinkedList) Get(index int) int {\n\tif index < 0 || index >= this.size || this == nil {\n\t\treturn -1\n\t}\n\tp := this.newHead.Next\n\tfor i := 0; i < index; i++ {\n\t\tp = p.Next\n\t}\n\treturn p.Val\n}\n\nfunc (this *MyLinkedList) AddAtHead(val int) {\n\tnewNode := &LinkList{\n\t\tVal:  val,\n\t\tNext: this.newHead.Next,\n\t}\n\tthis.newHead.Next = newNode\n\tthis.size++\n}\n\nfunc (this *MyLinkedList) AddAtTail(val int) {\n\tnewNode := &LinkList{\n\t\tVal:  val,\n\t\tNext: nil,\n\t}\n\tp := this.newHead\n\tfor p.Next != nil {\n\t\tp = p.Next\n\t}\n\tp.Next = newNode\n\tthis.size++\n}\n\nfunc (this *MyLinkedList) AddAtIndex(index int, val int) {\n\tif index < 0 {\n\t\tindex = 0\n\t} else if index > this.size {\n\t\treturn\n\t}\n\tnewNode := &LinkList{\n\t\tVal:  val,\n\t\tNext: nil,\n\t}\n\tp := this.newHead\n\tfor i := 0; i < index; i++ {\n\t\tp = p.Next\n\t}\n\tnewNode.Next = p.Next\n\tp.Next = newNode\n\tthis.size++\n}\n\nfunc (this *MyLinkedList) DeleteAtIndex(index int) {\n\tif index < 0 || index >= this.size {\n\t\treturn\n\t}\n\tp := this.newHead\n\tfor i := 0; i < index; i++ {\n\t\tp = p.Next\n\t}\n\tif p.Next != nil {\n\t\tp.Next = p.Next.Next\n\t}\n\tthis.size--\n}\n\n```\n\n\n\n\n## 206. 反转链表\n\n> 题目链接：[leetcode题目链接](https://leetcode.cn/problems/reverse-linked-list/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html)\n>\n> 视频讲解：[帮你拿下反转链表 | LeetCode：206.反转链表](https://www.bilibili.com/video/BV1nB4y1i7eL)\n>\n> 状态：AC\n\n### 思路\n\n1. 建立新的头结点`newHead` ，使其`newHead.Next = head`。\n2. 定义指针`p = head.Next`(先判断head是否为单节点)，然后手动断链，`head.Next = nil`\n3. 指针`p`不断向后，每遍历到一个元素，将这个元素保存到新的节点`newNode`，并且不断头插到`newHead`\n\n### 代码\n\n``` go\nfunc addAtHead(head *ListNode, val int) *ListNode {\n\tnewHead := &ListNode{\n\t\tVal:  0,\n\t\tNext: head,\n\t}\n\tnewNode := &ListNode{\n\t\tVal:  val,\n\t\tNext: newHead.Next,\n\t}\n\tnewHead.Next = newNode\n\treturn newHead.Next\n}\n\nfunc reverseList(head *ListNode) *ListNode {\n\tif head == nil {\n\t\treturn head\n\t}\n\tp := head.Next\n\thead.Next = nil\n\tfor p != nil {\n\t\thead = addAtHead(head, p.Val)\n\t\tp = p.Next\n\t}\n\treturn head\n}\n```\n\n\n\n## 小结\n\n- leetcode上的链表的题都是无头链表，所谓的 `head` 被叫做 `虚拟头`。我感觉还是叫做无头链表好一些，新建一个头先链接无头链表\n\n- 以前写过的都是有头链表，换到了无头链表刚开始有点不知所措、插入时候感觉怪怪的，其实都一样\n\n- `Go`的`new`相关或者初始化成员变量有了新的理解\n\n    ``` go\n    type SSS struct {\n        Val int\n    }\n    \n    //初始化的方式1\n    a := new SSS(1)\n    a.Val = 1\n    \n    //初始化的方式2\n    a := &SSS{\n        Val: 1\n    }\n    \n    ```\n\n- `Go`的构造函数看起来还有点懵\n- 最近事情太多了，周六上午招聘会、下午学校组织的求职训练营、晚上继续leetcode；周日上午训练营结课、下午再重写下链表、搞搞课题；周一还有个小活动。加油！\n","source":"_posts/day03.md","raw":"---\ntitle: 代码随想录算法训练营第三天| 203.移除链表元素、707.设计链表、206.反转链表。\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: bd069431\ndate: 2023-09-23 00:08:21\n---\n\n# 代码随想录算法训练营第三天| 203.移除链表元素、707.设计链表、206.反转链表。\n\n## 203. 移除链表元素\n\n> 题目链接：[leetcode题目链接](https://leetcode.cn/problems/remove-linked-list-elements/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html)\n>\n> 视频讲解：[链表基础操作| LeetCode：203.移除链表元素](https://www.bilibili.com/video/BV18B4y1s7R9)\n>\n> 状态：AC\n\n### 思路\n\n删除元素还是比较简单的，假设`q = p.Next`，如果删除`q`则是`p.Next = p.Next.Next`，考虑下`p.Next.Next`是否存在即可\n\n### 代码\n\n``` go\nfunc removeElements(head *ListNode, val int) *ListNode {\n\tnewHead := new(ListNode)\n\tnewHead.Next = head\n\tp := newHead\n\tfor p.Next != nil {\n\t\tif p.Next.Val == val {\n\t\t\tp.Next = p.Next.Next\n\t\t} else {\n\t\t\tp = p.Next\n\t\t}\n\t}\n\treturn newHead.Next\n}\n```\n\n\n\n## 707. 设计链表\n\n> 题目链接：[leetcode题目链接](https://leetcode.cn/problems/design-linked-list/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html)\n>\n> 视频讲解：[帮你把链表操作学个通透！LeetCode：707.设计链表](https://www.bilibili.com/video/BV1FU4y1X7WD)\n>\n> 状态：半AC（AC了但是也没完全AC）\n\n### 思路\n\n- `(this *MyLinkedList)get(index int) int`: 先判断index是否合法，所以需要引入一个新的成员对象`size`在`MyLinkedList`中\n- `(this *MyLinkedList)AddAtHead(val int)`: 头插法只需要在新的头之后接入一个新的节点，然后`size++`\n- `(this *MyLinkedList)AddAtTail(val int)`: 尾插法只需要在整个链表之后接入一个新的节点，然后`size++`\n- `(this *MyLinkedList)DeleteAtIndex(index int)`: 删除一个元素类似上一题，只不过要判断index是否合法\n- `(this *MyLinkedList)AddAtIndex(index int, val)`: 先判断index是否合法，找到正确位置进行插入\n\n### 代码\n\n``` go\n\ntype LinkList struct {\n\tVal  int\n\tNext *LinkList\n}\n\ntype MyLinkedList struct {\n\tsize    int\n\tnewHead *LinkList\n}\n\nfunc Constructor() MyLinkedList {\n\t//return MyLinkedList{}\n\tnode := &LinkList{\n\t\tVal:  0,\n\t\tNext: nil,\n\t}\n\treturn MyLinkedList{\n\t\tnewHead: node,\n\t\tsize:    0,\n\t}\n}\n\nfunc (this *MyLinkedList) Get(index int) int {\n\tif index < 0 || index >= this.size || this == nil {\n\t\treturn -1\n\t}\n\tp := this.newHead.Next\n\tfor i := 0; i < index; i++ {\n\t\tp = p.Next\n\t}\n\treturn p.Val\n}\n\nfunc (this *MyLinkedList) AddAtHead(val int) {\n\tnewNode := &LinkList{\n\t\tVal:  val,\n\t\tNext: this.newHead.Next,\n\t}\n\tthis.newHead.Next = newNode\n\tthis.size++\n}\n\nfunc (this *MyLinkedList) AddAtTail(val int) {\n\tnewNode := &LinkList{\n\t\tVal:  val,\n\t\tNext: nil,\n\t}\n\tp := this.newHead\n\tfor p.Next != nil {\n\t\tp = p.Next\n\t}\n\tp.Next = newNode\n\tthis.size++\n}\n\nfunc (this *MyLinkedList) AddAtIndex(index int, val int) {\n\tif index < 0 {\n\t\tindex = 0\n\t} else if index > this.size {\n\t\treturn\n\t}\n\tnewNode := &LinkList{\n\t\tVal:  val,\n\t\tNext: nil,\n\t}\n\tp := this.newHead\n\tfor i := 0; i < index; i++ {\n\t\tp = p.Next\n\t}\n\tnewNode.Next = p.Next\n\tp.Next = newNode\n\tthis.size++\n}\n\nfunc (this *MyLinkedList) DeleteAtIndex(index int) {\n\tif index < 0 || index >= this.size {\n\t\treturn\n\t}\n\tp := this.newHead\n\tfor i := 0; i < index; i++ {\n\t\tp = p.Next\n\t}\n\tif p.Next != nil {\n\t\tp.Next = p.Next.Next\n\t}\n\tthis.size--\n}\n\n```\n\n\n\n\n## 206. 反转链表\n\n> 题目链接：[leetcode题目链接](https://leetcode.cn/problems/reverse-linked-list/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html)\n>\n> 视频讲解：[帮你拿下反转链表 | LeetCode：206.反转链表](https://www.bilibili.com/video/BV1nB4y1i7eL)\n>\n> 状态：AC\n\n### 思路\n\n1. 建立新的头结点`newHead` ，使其`newHead.Next = head`。\n2. 定义指针`p = head.Next`(先判断head是否为单节点)，然后手动断链，`head.Next = nil`\n3. 指针`p`不断向后，每遍历到一个元素，将这个元素保存到新的节点`newNode`，并且不断头插到`newHead`\n\n### 代码\n\n``` go\nfunc addAtHead(head *ListNode, val int) *ListNode {\n\tnewHead := &ListNode{\n\t\tVal:  0,\n\t\tNext: head,\n\t}\n\tnewNode := &ListNode{\n\t\tVal:  val,\n\t\tNext: newHead.Next,\n\t}\n\tnewHead.Next = newNode\n\treturn newHead.Next\n}\n\nfunc reverseList(head *ListNode) *ListNode {\n\tif head == nil {\n\t\treturn head\n\t}\n\tp := head.Next\n\thead.Next = nil\n\tfor p != nil {\n\t\thead = addAtHead(head, p.Val)\n\t\tp = p.Next\n\t}\n\treturn head\n}\n```\n\n\n\n## 小结\n\n- leetcode上的链表的题都是无头链表，所谓的 `head` 被叫做 `虚拟头`。我感觉还是叫做无头链表好一些，新建一个头先链接无头链表\n\n- 以前写过的都是有头链表，换到了无头链表刚开始有点不知所措、插入时候感觉怪怪的，其实都一样\n\n- `Go`的`new`相关或者初始化成员变量有了新的理解\n\n    ``` go\n    type SSS struct {\n        Val int\n    }\n    \n    //初始化的方式1\n    a := new SSS(1)\n    a.Val = 1\n    \n    //初始化的方式2\n    a := &SSS{\n        Val: 1\n    }\n    \n    ```\n\n- `Go`的构造函数看起来还有点懵\n- 最近事情太多了，周六上午招聘会、下午学校组织的求职训练营、晚上继续leetcode；周日上午训练营结课、下午再重写下链表、搞搞课题；周一还有个小活动。加油！\n","slug":"day03","published":1,"updated":"2023-10-01T16:48:46.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln7q7alu0005vswhctx76rch","content":"<h1 id=\"代码随想录算法训练营第三天-203-移除链表元素、707-设计链表、206-反转链表。\"><a href=\"#代码随想录算法训练营第三天-203-移除链表元素、707-设计链表、206-反转链表。\" class=\"headerlink\" title=\"代码随想录算法训练营第三天| 203.移除链表元素、707.设计链表、206.反转链表。\"></a>代码随想录算法训练营第三天| 203.移除链表元素、707.设计链表、206.反转链表。</h1><h2 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203. 移除链表元素\"></a>203. 移除链表元素</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/remove-linked-list-elements/\">leetcode题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV18B4y1s7R9\">链表基础操作| LeetCode：203.移除链表元素</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>删除元素还是比较简单的，假设<code>q = p.Next</code>，如果删除<code>q</code>则是<code>p.Next = p.Next.Next</code>，考虑下<code>p.Next.Next</code>是否存在即可</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">removeElements</span><span class=\"hljs-params\">(head *ListNode, val <span class=\"hljs-type\">int</span>)</span></span> *ListNode &#123;<br>\tnewHead := <span class=\"hljs-built_in\">new</span>(ListNode)<br>\tnewHead.Next = head<br>\tp := newHead<br>\t<span class=\"hljs-keyword\">for</span> p.Next != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> p.Next.Val == val &#123;<br>\t\t\tp.Next = p.Next.Next<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tp = p.Next<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> newHead.Next<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"707-设计链表\"><a href=\"#707-设计链表\" class=\"headerlink\" title=\"707. 设计链表\"></a>707. 设计链表</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/design-linked-list/\">leetcode题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1FU4y1X7WD\">帮你把链表操作学个通透！LeetCode：707.设计链表</a></p>\n<p>状态：半AC（AC了但是也没完全AC）</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li><code>(this *MyLinkedList)get(index int) int</code>: 先判断index是否合法，所以需要引入一个新的成员对象<code>size</code>在<code>MyLinkedList</code>中</li>\n<li><code>(this *MyLinkedList)AddAtHead(val int)</code>: 头插法只需要在新的头之后接入一个新的节点，然后<code>size++</code></li>\n<li><code>(this *MyLinkedList)AddAtTail(val int)</code>: 尾插法只需要在整个链表之后接入一个新的节点，然后<code>size++</code></li>\n<li><code>(this *MyLinkedList)DeleteAtIndex(index int)</code>: 删除一个元素类似上一题，只不过要判断index是否合法</li>\n<li><code>(this *MyLinkedList)AddAtIndex(index int, val)</code>: 先判断index是否合法，找到正确位置进行插入</li>\n</ul>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><br><span class=\"hljs-keyword\">type</span> LinkList <span class=\"hljs-keyword\">struct</span> &#123;<br>\tVal  <span class=\"hljs-type\">int</span><br>\tNext *LinkList<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> MyLinkedList <span class=\"hljs-keyword\">struct</span> &#123;<br>\tsize    <span class=\"hljs-type\">int</span><br>\tnewHead *LinkList<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">()</span></span> MyLinkedList &#123;<br>\t<span class=\"hljs-comment\">//return MyLinkedList&#123;&#125;</span><br>\tnode := &amp;LinkList&#123;<br>\t\tVal:  <span class=\"hljs-number\">0</span>,<br>\t\tNext: <span class=\"hljs-literal\">nil</span>,<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> MyLinkedList&#123;<br>\t\tnewHead: node,<br>\t\tsize:    <span class=\"hljs-number\">0</span>,<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyLinkedList)</span></span> Get(index <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> index &lt; <span class=\"hljs-number\">0</span> || index &gt;= this.size || this == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>\t&#125;<br>\tp := this.newHead.Next<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; index; i++ &#123;<br>\t\tp = p.Next<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> p.Val<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyLinkedList)</span></span> AddAtHead(val <span class=\"hljs-type\">int</span>) &#123;<br>\tnewNode := &amp;LinkList&#123;<br>\t\tVal:  val,<br>\t\tNext: this.newHead.Next,<br>\t&#125;<br>\tthis.newHead.Next = newNode<br>\tthis.size++<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyLinkedList)</span></span> AddAtTail(val <span class=\"hljs-type\">int</span>) &#123;<br>\tnewNode := &amp;LinkList&#123;<br>\t\tVal:  val,<br>\t\tNext: <span class=\"hljs-literal\">nil</span>,<br>\t&#125;<br>\tp := this.newHead<br>\t<span class=\"hljs-keyword\">for</span> p.Next != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tp = p.Next<br>\t&#125;<br>\tp.Next = newNode<br>\tthis.size++<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyLinkedList)</span></span> AddAtIndex(index <span class=\"hljs-type\">int</span>, val <span class=\"hljs-type\">int</span>) &#123;<br>\t<span class=\"hljs-keyword\">if</span> index &lt; <span class=\"hljs-number\">0</span> &#123;<br>\t\tindex = <span class=\"hljs-number\">0</span><br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> index &gt; this.size &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\tnewNode := &amp;LinkList&#123;<br>\t\tVal:  val,<br>\t\tNext: <span class=\"hljs-literal\">nil</span>,<br>\t&#125;<br>\tp := this.newHead<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; index; i++ &#123;<br>\t\tp = p.Next<br>\t&#125;<br>\tnewNode.Next = p.Next<br>\tp.Next = newNode<br>\tthis.size++<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class=\"hljs-type\">int</span>) &#123;<br>\t<span class=\"hljs-keyword\">if</span> index &lt; <span class=\"hljs-number\">0</span> || index &gt;= this.size &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\tp := this.newHead<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; index; i++ &#123;<br>\t\tp = p.Next<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> p.Next != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tp.Next = p.Next.Next<br>\t&#125;<br>\tthis.size--<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206. 反转链表\"></a>206. 反转链表</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/reverse-linked-list/\">leetcode题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1nB4y1i7eL\">帮你拿下反转链表 | LeetCode：206.反转链表</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>建立新的头结点<code>newHead</code> ，使其<code>newHead.Next = head</code>。</li>\n<li>定义指针<code>p = head.Next</code>(先判断head是否为单节点)，然后手动断链，<code>head.Next = nil</code></li>\n<li>指针<code>p</code>不断向后，每遍历到一个元素，将这个元素保存到新的节点<code>newNode</code>，并且不断头插到<code>newHead</code></li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">addAtHead</span><span class=\"hljs-params\">(head *ListNode, val <span class=\"hljs-type\">int</span>)</span></span> *ListNode &#123;<br>\tnewHead := &amp;ListNode&#123;<br>\t\tVal:  <span class=\"hljs-number\">0</span>,<br>\t\tNext: head,<br>\t&#125;<br>\tnewNode := &amp;ListNode&#123;<br>\t\tVal:  val,<br>\t\tNext: newHead.Next,<br>\t&#125;<br>\tnewHead.Next = newNode<br>\t<span class=\"hljs-keyword\">return</span> newHead.Next<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">reverseList</span><span class=\"hljs-params\">(head *ListNode)</span></span> *ListNode &#123;<br>\t<span class=\"hljs-keyword\">if</span> head == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> head<br>\t&#125;<br>\tp := head.Next<br>\thead.Next = <span class=\"hljs-literal\">nil</span><br>\t<span class=\"hljs-keyword\">for</span> p != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\thead = addAtHead(head, p.Val)<br>\t\tp = p.Next<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li><p>leetcode上的链表的题都是无头链表，所谓的 <code>head</code> 被叫做 <code>虚拟头</code>。我感觉还是叫做无头链表好一些，新建一个头先链接无头链表</p>\n</li>\n<li><p>以前写过的都是有头链表，换到了无头链表刚开始有点不知所措、插入时候感觉怪怪的，其实都一样</p>\n</li>\n<li><p><code>Go</code>的<code>new</code>相关或者初始化成员变量有了新的理解</p>\n  <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> SSS <span class=\"hljs-keyword\">struct</span> &#123;<br>    Val <span class=\"hljs-type\">int</span><br>&#125;<br><br><span class=\"hljs-comment\">//初始化的方式1</span><br>a := <span class=\"hljs-built_in\">new</span> SSS(<span class=\"hljs-number\">1</span>)<br>a.Val = <span class=\"hljs-number\">1</span><br><br><span class=\"hljs-comment\">//初始化的方式2</span><br>a := &amp;SSS&#123;<br>    Val: <span class=\"hljs-number\">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>Go</code>的构造函数看起来还有点懵</p>\n</li>\n<li><p>最近事情太多了，周六上午招聘会、下午学校组织的求职训练营、晚上继续leetcode；周日上午训练营结课、下午再重写下链表、搞搞课题；周一还有个小活动。加油！</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第三天-203-移除链表元素、707-设计链表、206-反转链表。\"><a href=\"#代码随想录算法训练营第三天-203-移除链表元素、707-设计链表、206-反转链表。\" class=\"headerlink\" title=\"代码随想录算法训练营第三天| 203.移除链表元素、707.设计链表、206.反转链表。\"></a>代码随想录算法训练营第三天| 203.移除链表元素、707.设计链表、206.反转链表。</h1><h2 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203. 移除链表元素\"></a>203. 移除链表元素</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/remove-linked-list-elements/\">leetcode题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV18B4y1s7R9\">链表基础操作| LeetCode：203.移除链表元素</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>删除元素还是比较简单的，假设<code>q = p.Next</code>，如果删除<code>q</code>则是<code>p.Next = p.Next.Next</code>，考虑下<code>p.Next.Next</code>是否存在即可</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">removeElements</span><span class=\"hljs-params\">(head *ListNode, val <span class=\"hljs-type\">int</span>)</span></span> *ListNode &#123;<br>\tnewHead := <span class=\"hljs-built_in\">new</span>(ListNode)<br>\tnewHead.Next = head<br>\tp := newHead<br>\t<span class=\"hljs-keyword\">for</span> p.Next != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> p.Next.Val == val &#123;<br>\t\t\tp.Next = p.Next.Next<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tp = p.Next<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> newHead.Next<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"707-设计链表\"><a href=\"#707-设计链表\" class=\"headerlink\" title=\"707. 设计链表\"></a>707. 设计链表</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/design-linked-list/\">leetcode题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1FU4y1X7WD\">帮你把链表操作学个通透！LeetCode：707.设计链表</a></p>\n<p>状态：半AC（AC了但是也没完全AC）</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li><code>(this *MyLinkedList)get(index int) int</code>: 先判断index是否合法，所以需要引入一个新的成员对象<code>size</code>在<code>MyLinkedList</code>中</li>\n<li><code>(this *MyLinkedList)AddAtHead(val int)</code>: 头插法只需要在新的头之后接入一个新的节点，然后<code>size++</code></li>\n<li><code>(this *MyLinkedList)AddAtTail(val int)</code>: 尾插法只需要在整个链表之后接入一个新的节点，然后<code>size++</code></li>\n<li><code>(this *MyLinkedList)DeleteAtIndex(index int)</code>: 删除一个元素类似上一题，只不过要判断index是否合法</li>\n<li><code>(this *MyLinkedList)AddAtIndex(index int, val)</code>: 先判断index是否合法，找到正确位置进行插入</li>\n</ul>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><br><span class=\"hljs-keyword\">type</span> LinkList <span class=\"hljs-keyword\">struct</span> &#123;<br>\tVal  <span class=\"hljs-type\">int</span><br>\tNext *LinkList<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> MyLinkedList <span class=\"hljs-keyword\">struct</span> &#123;<br>\tsize    <span class=\"hljs-type\">int</span><br>\tnewHead *LinkList<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">()</span></span> MyLinkedList &#123;<br>\t<span class=\"hljs-comment\">//return MyLinkedList&#123;&#125;</span><br>\tnode := &amp;LinkList&#123;<br>\t\tVal:  <span class=\"hljs-number\">0</span>,<br>\t\tNext: <span class=\"hljs-literal\">nil</span>,<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> MyLinkedList&#123;<br>\t\tnewHead: node,<br>\t\tsize:    <span class=\"hljs-number\">0</span>,<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyLinkedList)</span></span> Get(index <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> index &lt; <span class=\"hljs-number\">0</span> || index &gt;= this.size || this == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>\t&#125;<br>\tp := this.newHead.Next<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; index; i++ &#123;<br>\t\tp = p.Next<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> p.Val<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyLinkedList)</span></span> AddAtHead(val <span class=\"hljs-type\">int</span>) &#123;<br>\tnewNode := &amp;LinkList&#123;<br>\t\tVal:  val,<br>\t\tNext: this.newHead.Next,<br>\t&#125;<br>\tthis.newHead.Next = newNode<br>\tthis.size++<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyLinkedList)</span></span> AddAtTail(val <span class=\"hljs-type\">int</span>) &#123;<br>\tnewNode := &amp;LinkList&#123;<br>\t\tVal:  val,<br>\t\tNext: <span class=\"hljs-literal\">nil</span>,<br>\t&#125;<br>\tp := this.newHead<br>\t<span class=\"hljs-keyword\">for</span> p.Next != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tp = p.Next<br>\t&#125;<br>\tp.Next = newNode<br>\tthis.size++<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyLinkedList)</span></span> AddAtIndex(index <span class=\"hljs-type\">int</span>, val <span class=\"hljs-type\">int</span>) &#123;<br>\t<span class=\"hljs-keyword\">if</span> index &lt; <span class=\"hljs-number\">0</span> &#123;<br>\t\tindex = <span class=\"hljs-number\">0</span><br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> index &gt; this.size &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\tnewNode := &amp;LinkList&#123;<br>\t\tVal:  val,<br>\t\tNext: <span class=\"hljs-literal\">nil</span>,<br>\t&#125;<br>\tp := this.newHead<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; index; i++ &#123;<br>\t\tp = p.Next<br>\t&#125;<br>\tnewNode.Next = p.Next<br>\tp.Next = newNode<br>\tthis.size++<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class=\"hljs-type\">int</span>) &#123;<br>\t<span class=\"hljs-keyword\">if</span> index &lt; <span class=\"hljs-number\">0</span> || index &gt;= this.size &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\tp := this.newHead<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; index; i++ &#123;<br>\t\tp = p.Next<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> p.Next != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tp.Next = p.Next.Next<br>\t&#125;<br>\tthis.size--<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206. 反转链表\"></a>206. 反转链表</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/reverse-linked-list/\">leetcode题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1nB4y1i7eL\">帮你拿下反转链表 | LeetCode：206.反转链表</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>建立新的头结点<code>newHead</code> ，使其<code>newHead.Next = head</code>。</li>\n<li>定义指针<code>p = head.Next</code>(先判断head是否为单节点)，然后手动断链，<code>head.Next = nil</code></li>\n<li>指针<code>p</code>不断向后，每遍历到一个元素，将这个元素保存到新的节点<code>newNode</code>，并且不断头插到<code>newHead</code></li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">addAtHead</span><span class=\"hljs-params\">(head *ListNode, val <span class=\"hljs-type\">int</span>)</span></span> *ListNode &#123;<br>\tnewHead := &amp;ListNode&#123;<br>\t\tVal:  <span class=\"hljs-number\">0</span>,<br>\t\tNext: head,<br>\t&#125;<br>\tnewNode := &amp;ListNode&#123;<br>\t\tVal:  val,<br>\t\tNext: newHead.Next,<br>\t&#125;<br>\tnewHead.Next = newNode<br>\t<span class=\"hljs-keyword\">return</span> newHead.Next<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">reverseList</span><span class=\"hljs-params\">(head *ListNode)</span></span> *ListNode &#123;<br>\t<span class=\"hljs-keyword\">if</span> head == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> head<br>\t&#125;<br>\tp := head.Next<br>\thead.Next = <span class=\"hljs-literal\">nil</span><br>\t<span class=\"hljs-keyword\">for</span> p != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\thead = addAtHead(head, p.Val)<br>\t\tp = p.Next<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li><p>leetcode上的链表的题都是无头链表，所谓的 <code>head</code> 被叫做 <code>虚拟头</code>。我感觉还是叫做无头链表好一些，新建一个头先链接无头链表</p>\n</li>\n<li><p>以前写过的都是有头链表，换到了无头链表刚开始有点不知所措、插入时候感觉怪怪的，其实都一样</p>\n</li>\n<li><p><code>Go</code>的<code>new</code>相关或者初始化成员变量有了新的理解</p>\n  <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> SSS <span class=\"hljs-keyword\">struct</span> &#123;<br>    Val <span class=\"hljs-type\">int</span><br>&#125;<br><br><span class=\"hljs-comment\">//初始化的方式1</span><br>a := <span class=\"hljs-built_in\">new</span> SSS(<span class=\"hljs-number\">1</span>)<br>a.Val = <span class=\"hljs-number\">1</span><br><br><span class=\"hljs-comment\">//初始化的方式2</span><br>a := &amp;SSS&#123;<br>    Val: <span class=\"hljs-number\">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>Go</code>的构造函数看起来还有点懵</p>\n</li>\n<li><p>最近事情太多了，周六上午招聘会、下午学校组织的求职训练营、晚上继续leetcode；周日上午训练营结课、下午再重写下链表、搞搞课题；周一还有个小活动。加油！</p>\n</li>\n</ul>\n"},{"title":"代码随想录算法训练营第六天| 242.有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和 。","abbrlink":"20198d61","date":"2023-09-25T02:09:40.000Z","_content":"\n# 代码随想录算法训练营第六天| 242.有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和 。\n\n## 242.有效的字母异位词\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/valid-anagram/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html)\n>\n>   视频讲解：[学透哈希表，数组使用有技巧！Leetcode：242.有效的字母异位词](https://www.bilibili.com/video/BV1YG411p7BA)\n>\n>   状态：AC\n\n### 思路\n\n-   方法一：使用`map`即可。键是字母的`ASCII`码、值为频率。分别用两个串构建两个`map`，再比较两个`map`是否相同。\n\n-   方法二：看了卡哥给的代码发现优化空间还是很大的，使用一个`map`即可，存放`s`的情况。异位词满足两个条件：\n    -   两个串等长。\n    -   两个串中字母出现的频率相同。这一点可以用`s`串的`map`的`value`自减。\n\n### 代码\n\n``` go\n//麻烦的方法\nfunc isAnagram(s string, t string) bool {\n\twords1 := map[byte]int{}\n\twords2 := map[byte]int{}\n\tfor i := 0; i < len(s); i++ {\n\t\t_, ok := words1[s[i]]\n\t\tif ok {\n\t\t\twords1[s[i]] += 1\n\t\t} else {\n\t\t\twords1[s[i]] = 1\n\t\t}\n\t}\n\tfor i := 0; i < len(t); i++ {\n\t\t_, ok := words2[t[i]]\n\t\tif ok {\n\t\t\twords2[t[i]] += 1\n\t\t} else {\n\t\t\twords2[t[i]] = 1\n\t\t}\n\t}\n\n\treturn reflect.DeepEqual(words1, words2)\n}\n```\n\n``` go\n// 简单的代码\nfunc isAnagram(s, t string) bool {\n\tif len(s) != len(t) {\n\t\treturn false\n\t}\n\tcnt := map[rune]int{}\n\tfor _, ch := range s {\n\t\tcnt[ch]++\n\t}\n\tfor _, ch := range t {\n\t\tcnt[ch]--\n\t\tif cnt[ch] < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```\n\n\n\n## 349. 两个数组的交集\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/intersection-of-two-arrays/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html)\n>\n>   视频讲解：[学透哈希表，set使用有技巧！Leetcode：349. 两个数组的交集](https://www.bilibili.com/video/BV1ba411S7wu)\n>\n>   状态：AC\n\n### 思路\n\n从求交集可以看出是要使用集合的结构，但是在Go语言中<font color=\"#ff0000\">并没有</font>集合，所以我使用了`map`（并不是用map模拟set）。map中，键为`nums1`的每个元素，值只有三种状态：第一次出现是`0`，多次出现是`1`，在`nums2`也出现过是`2`，最后遍历map，找到值为2的key。\n\n利用const和iota模拟枚举类型。\n\n### 代码\n\n``` go\nconst (\n\tNEW = iota\n\tEXIST1\n\tEXIST2\n)\n\nfunc intersection(nums1 []int, nums2 []int) []int {\n\tset := map[int]int{}  //类集合操作\n\tfor _, v := range nums1 {\n\t\tif _, ok := set[v]; !ok {\n\t\t\tset[v] = NEW  // 第一个出现\n\t\t} else {  // 多次出现\n\t\t\tset[v] = EXIST1\n\t\t}\n\t}\n\tfor _, v := range nums2 {\n\t\tif _, ok := set[v]; ok {  // nums2也出现\n\t\t\tset[v] = EXIST2\n\t\t}\n\t}\n\tvar result []int\n\tfor k, v := range set {\n\t\tif v == EXIST2 {\n\t\t\tresult = append(result, k)\n\t\t}\n\t}\n\treturn result\n}\n```\n\n## 202. 快乐数\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/happy-number/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html#%E6%80%9D%E8%B7%AF)\n>\n>   状态：AC\n\n### 思路\n\n1.   构造一个集合，用于存放每一次拆数求平方和的结果\n2.   拆数\n3.   判断结果是否是1，如果是`return true`\n4.   如果不是1，判断结果是否在集合中，如果存在则说明出现了循环，`return false`\n\n\n\n### 代码\n\n``` go\nfunc isHappy(n int) bool {\n\tset := map[int]bool{}  // 模拟集合\n\tfor {\n\t\tsum := 0\n        //拆数求平方和\n\t\tfor n > 0 {\n\t\t\tsum += (n % 10) * (n % 10)\n\t\t\tn /= 10\n\t\t}\n        //得到正确答案\n\t\tif sum == 1 {\n\t\t\treturn true\n\t\t}\n        \n        //结果不在集合中则放入集合\n\t\tif _, ok := set[sum]; !ok {\n\t\t\tset[sum] = true\n\t\t} else {// 否则退出循环 return false\n\t\t\tbreak\n\t\t}\n\t\tn = sum // 新一轮的数\n\t}\n\treturn false\n}\n```\n\n## 1.两数之和\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/two-sum/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html)\n>\n>   视频讲解：[梦开始的地方，Leetcode：1.两数之和](https://www.bilibili.com/video/BV1aT41177mK)\n>\n>   状态：AC\n\n### 思路\n\n1.   遍历`nums`将元素存为`map`的`key`，将元素的索引存放为`map`的`value`；\n2.   再遍历`nums`，查看`target - v`是否在`key`中，并返回两个值：`nums`元素的索引和`map[target-v]`\n\n遍历两次还是思路上走弯路了，一次即可。\n\n### 代码\n\n```go\n//遍历两次\nfunc twoSum(nums []int, target int) []int {\n    mapNums := map[int]int{}\n    for i, v := range nums {\n       mapNums[v] = i\n    }\n    var result []int\n    for i, v := range nums {\n       if _, ok := mapNums[target-v]; ok && mapNums[target-v] != i {\n          result = append(result, i)\n          result = append(result, mapNums[target-v])\n          break\n       }\n    }\n    return result\n}\n```\n\n``` go\nfunc twoSum(nums []int, target int) []int {\n\tmapNums := map[int]int{}\n\tfor i, v := range nums {\n\t\tif value, ok := mapNums[target-v]; ok {\n\t\t\treturn []int{i, value}\n\t\t} else {\n\t\t\tmapNums[v] = i\n\t\t}\n\t}\n\treturn []int{}\n}\n```\n\n## 小结\n\n-   这次的题目不算很难，做起来就很快，算上写博客的时间不到两个小时\n\n-   对Go语言的map有了新的理解：\n\n    ``` go\n    test = map[int]int{}\n    if value, ok := test[key]; ok {\n    \t// key存在的情况\n    } else {\n    \t// key不存在的情况\n    }\n    ```\n\n    ``` go\n    // 使用反射来判断两个map是否相等\n    import reflect\n    reflect.DeepEqual(map1, map2)\n    ```\n\n    ``` go\n    test = map[int]int{}\n    test[1]--  // 即使不存在1，默认新增键值对{1:0}，然后再自减\n    ```\n\n    \n\n-   第一次使用Go模拟枚举\n\n    ``` go\n    const (\n    \tA iota\n        B\n        C\n    )\n    ```\n\n    \n","source":"_posts/day06.md","raw":"---\ntitle: 代码随想录算法训练营第六天| 242.有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和 。\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: 20198d61\ndate: 2023-09-25 10:09:40\n---\n\n# 代码随想录算法训练营第六天| 242.有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和 。\n\n## 242.有效的字母异位词\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/valid-anagram/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html)\n>\n>   视频讲解：[学透哈希表，数组使用有技巧！Leetcode：242.有效的字母异位词](https://www.bilibili.com/video/BV1YG411p7BA)\n>\n>   状态：AC\n\n### 思路\n\n-   方法一：使用`map`即可。键是字母的`ASCII`码、值为频率。分别用两个串构建两个`map`，再比较两个`map`是否相同。\n\n-   方法二：看了卡哥给的代码发现优化空间还是很大的，使用一个`map`即可，存放`s`的情况。异位词满足两个条件：\n    -   两个串等长。\n    -   两个串中字母出现的频率相同。这一点可以用`s`串的`map`的`value`自减。\n\n### 代码\n\n``` go\n//麻烦的方法\nfunc isAnagram(s string, t string) bool {\n\twords1 := map[byte]int{}\n\twords2 := map[byte]int{}\n\tfor i := 0; i < len(s); i++ {\n\t\t_, ok := words1[s[i]]\n\t\tif ok {\n\t\t\twords1[s[i]] += 1\n\t\t} else {\n\t\t\twords1[s[i]] = 1\n\t\t}\n\t}\n\tfor i := 0; i < len(t); i++ {\n\t\t_, ok := words2[t[i]]\n\t\tif ok {\n\t\t\twords2[t[i]] += 1\n\t\t} else {\n\t\t\twords2[t[i]] = 1\n\t\t}\n\t}\n\n\treturn reflect.DeepEqual(words1, words2)\n}\n```\n\n``` go\n// 简单的代码\nfunc isAnagram(s, t string) bool {\n\tif len(s) != len(t) {\n\t\treturn false\n\t}\n\tcnt := map[rune]int{}\n\tfor _, ch := range s {\n\t\tcnt[ch]++\n\t}\n\tfor _, ch := range t {\n\t\tcnt[ch]--\n\t\tif cnt[ch] < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```\n\n\n\n## 349. 两个数组的交集\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/intersection-of-two-arrays/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html)\n>\n>   视频讲解：[学透哈希表，set使用有技巧！Leetcode：349. 两个数组的交集](https://www.bilibili.com/video/BV1ba411S7wu)\n>\n>   状态：AC\n\n### 思路\n\n从求交集可以看出是要使用集合的结构，但是在Go语言中<font color=\"#ff0000\">并没有</font>集合，所以我使用了`map`（并不是用map模拟set）。map中，键为`nums1`的每个元素，值只有三种状态：第一次出现是`0`，多次出现是`1`，在`nums2`也出现过是`2`，最后遍历map，找到值为2的key。\n\n利用const和iota模拟枚举类型。\n\n### 代码\n\n``` go\nconst (\n\tNEW = iota\n\tEXIST1\n\tEXIST2\n)\n\nfunc intersection(nums1 []int, nums2 []int) []int {\n\tset := map[int]int{}  //类集合操作\n\tfor _, v := range nums1 {\n\t\tif _, ok := set[v]; !ok {\n\t\t\tset[v] = NEW  // 第一个出现\n\t\t} else {  // 多次出现\n\t\t\tset[v] = EXIST1\n\t\t}\n\t}\n\tfor _, v := range nums2 {\n\t\tif _, ok := set[v]; ok {  // nums2也出现\n\t\t\tset[v] = EXIST2\n\t\t}\n\t}\n\tvar result []int\n\tfor k, v := range set {\n\t\tif v == EXIST2 {\n\t\t\tresult = append(result, k)\n\t\t}\n\t}\n\treturn result\n}\n```\n\n## 202. 快乐数\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/happy-number/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html#%E6%80%9D%E8%B7%AF)\n>\n>   状态：AC\n\n### 思路\n\n1.   构造一个集合，用于存放每一次拆数求平方和的结果\n2.   拆数\n3.   判断结果是否是1，如果是`return true`\n4.   如果不是1，判断结果是否在集合中，如果存在则说明出现了循环，`return false`\n\n\n\n### 代码\n\n``` go\nfunc isHappy(n int) bool {\n\tset := map[int]bool{}  // 模拟集合\n\tfor {\n\t\tsum := 0\n        //拆数求平方和\n\t\tfor n > 0 {\n\t\t\tsum += (n % 10) * (n % 10)\n\t\t\tn /= 10\n\t\t}\n        //得到正确答案\n\t\tif sum == 1 {\n\t\t\treturn true\n\t\t}\n        \n        //结果不在集合中则放入集合\n\t\tif _, ok := set[sum]; !ok {\n\t\t\tset[sum] = true\n\t\t} else {// 否则退出循环 return false\n\t\t\tbreak\n\t\t}\n\t\tn = sum // 新一轮的数\n\t}\n\treturn false\n}\n```\n\n## 1.两数之和\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/two-sum/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html)\n>\n>   视频讲解：[梦开始的地方，Leetcode：1.两数之和](https://www.bilibili.com/video/BV1aT41177mK)\n>\n>   状态：AC\n\n### 思路\n\n1.   遍历`nums`将元素存为`map`的`key`，将元素的索引存放为`map`的`value`；\n2.   再遍历`nums`，查看`target - v`是否在`key`中，并返回两个值：`nums`元素的索引和`map[target-v]`\n\n遍历两次还是思路上走弯路了，一次即可。\n\n### 代码\n\n```go\n//遍历两次\nfunc twoSum(nums []int, target int) []int {\n    mapNums := map[int]int{}\n    for i, v := range nums {\n       mapNums[v] = i\n    }\n    var result []int\n    for i, v := range nums {\n       if _, ok := mapNums[target-v]; ok && mapNums[target-v] != i {\n          result = append(result, i)\n          result = append(result, mapNums[target-v])\n          break\n       }\n    }\n    return result\n}\n```\n\n``` go\nfunc twoSum(nums []int, target int) []int {\n\tmapNums := map[int]int{}\n\tfor i, v := range nums {\n\t\tif value, ok := mapNums[target-v]; ok {\n\t\t\treturn []int{i, value}\n\t\t} else {\n\t\t\tmapNums[v] = i\n\t\t}\n\t}\n\treturn []int{}\n}\n```\n\n## 小结\n\n-   这次的题目不算很难，做起来就很快，算上写博客的时间不到两个小时\n\n-   对Go语言的map有了新的理解：\n\n    ``` go\n    test = map[int]int{}\n    if value, ok := test[key]; ok {\n    \t// key存在的情况\n    } else {\n    \t// key不存在的情况\n    }\n    ```\n\n    ``` go\n    // 使用反射来判断两个map是否相等\n    import reflect\n    reflect.DeepEqual(map1, map2)\n    ```\n\n    ``` go\n    test = map[int]int{}\n    test[1]--  // 即使不存在1，默认新增键值对{1:0}，然后再自减\n    ```\n\n    \n\n-   第一次使用Go模拟枚举\n\n    ``` go\n    const (\n    \tA iota\n        B\n        C\n    )\n    ```\n\n    \n","slug":"day06","published":1,"updated":"2023-10-04T11:44:13.086Z","_id":"cln7q7alv0008vswh1zq3fitx","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第六天-242-有效的字母异位词、349-两个数组的交集、202-快乐数、1-两数之和-。\"><a href=\"#代码随想录算法训练营第六天-242-有效的字母异位词、349-两个数组的交集、202-快乐数、1-两数之和-。\" class=\"headerlink\" title=\"代码随想录算法训练营第六天| 242.有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和 。\"></a>代码随想录算法训练营第六天| 242.有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和 。</h1><h2 id=\"242-有效的字母异位词\"><a href=\"#242-有效的字母异位词\" class=\"headerlink\" title=\"242.有效的字母异位词\"></a>242.有效的字母异位词</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/valid-anagram/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1YG411p7BA\">学透哈希表，数组使用有技巧！Leetcode：242.有效的字母异位词</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li><p>方法一：使用<code>map</code>即可。键是字母的<code>ASCII</code>码、值为频率。分别用两个串构建两个<code>map</code>，再比较两个<code>map</code>是否相同。</p>\n</li>\n<li><p>方法二：看了卡哥给的代码发现优化空间还是很大的，使用一个<code>map</code>即可，存放<code>s</code>的情况。异位词满足两个条件：</p>\n<ul>\n<li>两个串等长。</li>\n<li>两个串中字母出现的频率相同。这一点可以用<code>s</code>串的<code>map</code>的<code>value</code>自减。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//麻烦的方法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isAnagram</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>, t <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\twords1 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\twords2 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ &#123;<br>\t\t_, ok := words1[s[i]]<br>\t\t<span class=\"hljs-keyword\">if</span> ok &#123;<br>\t\t\twords1[s[i]] += <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\twords1[s[i]] = <span class=\"hljs-number\">1</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(t); i++ &#123;<br>\t\t_, ok := words2[t[i]]<br>\t\t<span class=\"hljs-keyword\">if</span> ok &#123;<br>\t\t\twords2[t[i]] += <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\twords2[t[i]] = <span class=\"hljs-number\">1</span><br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> reflect.DeepEqual(words1, words2)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 简单的代码</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isAnagram</span><span class=\"hljs-params\">(s, t <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(s) != <span class=\"hljs-built_in\">len</span>(t) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>\tcnt := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">rune</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, ch := <span class=\"hljs-keyword\">range</span> s &#123;<br>\t\tcnt[ch]++<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, ch := <span class=\"hljs-keyword\">range</span> t &#123;<br>\t\tcnt[ch]--<br>\t\t<span class=\"hljs-keyword\">if</span> cnt[ch] &lt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"349-两个数组的交集\"><a href=\"#349-两个数组的交集\" class=\"headerlink\" title=\"349. 两个数组的交集\"></a>349. 两个数组的交集</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/intersection-of-two-arrays/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1ba411S7wu\">学透哈希表，set使用有技巧！Leetcode：349. 两个数组的交集</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>从求交集可以看出是要使用集合的结构，但是在Go语言中<font color=\"#ff0000\">并没有</font>集合，所以我使用了<code>map</code>（并不是用map模拟set）。map中，键为<code>nums1</code>的每个元素，值只有三种状态：第一次出现是<code>0</code>，多次出现是<code>1</code>，在<code>nums2</code>也出现过是<code>2</code>，最后遍历map，找到值为2的key。</p>\n<p>利用const和iota模拟枚举类型。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">const</span> (<br>\tNEW = <span class=\"hljs-literal\">iota</span><br>\tEXIST1<br>\tEXIST2<br>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">intersection</span><span class=\"hljs-params\">(nums1 []<span class=\"hljs-type\">int</span>, nums2 []<span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tset := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;  <span class=\"hljs-comment\">//类集合操作</span><br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> nums1 &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> _, ok := set[v]; !ok &#123;<br>\t\t\tset[v] = NEW  <span class=\"hljs-comment\">// 第一个出现</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;  <span class=\"hljs-comment\">// 多次出现</span><br>\t\t\tset[v] = EXIST1<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> nums2 &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> _, ok := set[v]; ok &#123;  <span class=\"hljs-comment\">// nums2也出现</span><br>\t\t\tset[v] = EXIST2<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">for</span> k, v := <span class=\"hljs-keyword\">range</span> set &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v == EXIST2 &#123;<br>\t\t\tresult = <span class=\"hljs-built_in\">append</span>(result, k)<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"202-快乐数\"><a href=\"#202-快乐数\" class=\"headerlink\" title=\"202. 快乐数\"></a>202. 快乐数</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/happy-number/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html#%E6%80%9D%E8%B7%AF\">代码随想录(programmercarl.com)</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>构造一个集合，用于存放每一次拆数求平方和的结果</li>\n<li>拆数</li>\n<li>判断结果是否是1，如果是<code>return true</code></li>\n<li>如果不是1，判断结果是否在集合中，如果存在则说明出现了循环，<code>return false</code></li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isHappy</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\tset := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">bool</span>&#123;&#125;  <span class=\"hljs-comment\">// 模拟集合</span><br>\t<span class=\"hljs-keyword\">for</span> &#123;<br>\t\tsum := <span class=\"hljs-number\">0</span><br>        <span class=\"hljs-comment\">//拆数求平方和</span><br>\t\t<span class=\"hljs-keyword\">for</span> n &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\tsum += (n % <span class=\"hljs-number\">10</span>) * (n % <span class=\"hljs-number\">10</span>)<br>\t\t\tn /= <span class=\"hljs-number\">10</span><br>\t\t&#125;<br>        <span class=\"hljs-comment\">//得到正确答案</span><br>\t\t<span class=\"hljs-keyword\">if</span> sum == <span class=\"hljs-number\">1</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t\t&#125;<br>        <br>        <span class=\"hljs-comment\">//结果不在集合中则放入集合</span><br>\t\t<span class=\"hljs-keyword\">if</span> _, ok := set[sum]; !ok &#123;<br>\t\t\tset[sum] = <span class=\"hljs-literal\">true</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">// 否则退出循环 return false</span><br>\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t&#125;<br>\t\tn = sum <span class=\"hljs-comment\">// 新一轮的数</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和\"></a>1.两数之和</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/two-sum/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1aT41177mK\">梦开始的地方，Leetcode：1.两数之和</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>遍历<code>nums</code>将元素存为<code>map</code>的<code>key</code>，将元素的索引存放为<code>map</code>的<code>value</code>；</li>\n<li>再遍历<code>nums</code>，查看<code>target - v</code>是否在<code>key</code>中，并返回两个值：<code>nums</code>元素的索引和<code>map[target-v]</code></li>\n</ol>\n<p>遍历两次还是思路上走弯路了，一次即可。</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//遍历两次</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">twoSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>    mapNums := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>       mapNums[v] = i<br>    &#125;<br>    <span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>       <span class=\"hljs-keyword\">if</span> _, ok := mapNums[target-v]; ok &amp;&amp; mapNums[target-v] != i &#123;<br>          result = <span class=\"hljs-built_in\">append</span>(result, i)<br>          result = <span class=\"hljs-built_in\">append</span>(result, mapNums[target-v])<br>          <span class=\"hljs-keyword\">break</span><br>       &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">twoSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tmapNums := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> value, ok := mapNums[target-v]; ok &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;i, value&#125;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tmapNums[v] = i<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li><p>这次的题目不算很难，做起来就很快，算上写博客的时间不到两个小时</p>\n</li>\n<li><p>对Go语言的map有了新的理解：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">test = <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br><span class=\"hljs-keyword\">if</span> value, ok := test[key]; ok &#123;<br>\t<span class=\"hljs-comment\">// key存在的情况</span><br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t<span class=\"hljs-comment\">// key不存在的情况</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 使用反射来判断两个map是否相等</span><br><span class=\"hljs-keyword\">import</span> reflect<br>reflect.DeepEqual(map1, map2)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">test = <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>test[<span class=\"hljs-number\">1</span>]--  <span class=\"hljs-comment\">// 即使不存在1，默认新增键值对&#123;1:0&#125;，然后再自减</span><br></code></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>第一次使用Go模拟枚举</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">const</span> (<br>\tA <span class=\"hljs-literal\">iota</span><br>    B<br>    C<br>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第六天-242-有效的字母异位词、349-两个数组的交集、202-快乐数、1-两数之和-。\"><a href=\"#代码随想录算法训练营第六天-242-有效的字母异位词、349-两个数组的交集、202-快乐数、1-两数之和-。\" class=\"headerlink\" title=\"代码随想录算法训练营第六天| 242.有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和 。\"></a>代码随想录算法训练营第六天| 242.有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和 。</h1><h2 id=\"242-有效的字母异位词\"><a href=\"#242-有效的字母异位词\" class=\"headerlink\" title=\"242.有效的字母异位词\"></a>242.有效的字母异位词</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/valid-anagram/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1YG411p7BA\">学透哈希表，数组使用有技巧！Leetcode：242.有效的字母异位词</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li><p>方法一：使用<code>map</code>即可。键是字母的<code>ASCII</code>码、值为频率。分别用两个串构建两个<code>map</code>，再比较两个<code>map</code>是否相同。</p>\n</li>\n<li><p>方法二：看了卡哥给的代码发现优化空间还是很大的，使用一个<code>map</code>即可，存放<code>s</code>的情况。异位词满足两个条件：</p>\n<ul>\n<li>两个串等长。</li>\n<li>两个串中字母出现的频率相同。这一点可以用<code>s</code>串的<code>map</code>的<code>value</code>自减。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//麻烦的方法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isAnagram</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>, t <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\twords1 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\twords2 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ &#123;<br>\t\t_, ok := words1[s[i]]<br>\t\t<span class=\"hljs-keyword\">if</span> ok &#123;<br>\t\t\twords1[s[i]] += <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\twords1[s[i]] = <span class=\"hljs-number\">1</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(t); i++ &#123;<br>\t\t_, ok := words2[t[i]]<br>\t\t<span class=\"hljs-keyword\">if</span> ok &#123;<br>\t\t\twords2[t[i]] += <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\twords2[t[i]] = <span class=\"hljs-number\">1</span><br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> reflect.DeepEqual(words1, words2)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 简单的代码</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isAnagram</span><span class=\"hljs-params\">(s, t <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(s) != <span class=\"hljs-built_in\">len</span>(t) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>\tcnt := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">rune</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, ch := <span class=\"hljs-keyword\">range</span> s &#123;<br>\t\tcnt[ch]++<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, ch := <span class=\"hljs-keyword\">range</span> t &#123;<br>\t\tcnt[ch]--<br>\t\t<span class=\"hljs-keyword\">if</span> cnt[ch] &lt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"349-两个数组的交集\"><a href=\"#349-两个数组的交集\" class=\"headerlink\" title=\"349. 两个数组的交集\"></a>349. 两个数组的交集</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/intersection-of-two-arrays/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1ba411S7wu\">学透哈希表，set使用有技巧！Leetcode：349. 两个数组的交集</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>从求交集可以看出是要使用集合的结构，但是在Go语言中<font color=\"#ff0000\">并没有</font>集合，所以我使用了<code>map</code>（并不是用map模拟set）。map中，键为<code>nums1</code>的每个元素，值只有三种状态：第一次出现是<code>0</code>，多次出现是<code>1</code>，在<code>nums2</code>也出现过是<code>2</code>，最后遍历map，找到值为2的key。</p>\n<p>利用const和iota模拟枚举类型。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">const</span> (<br>\tNEW = <span class=\"hljs-literal\">iota</span><br>\tEXIST1<br>\tEXIST2<br>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">intersection</span><span class=\"hljs-params\">(nums1 []<span class=\"hljs-type\">int</span>, nums2 []<span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tset := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;  <span class=\"hljs-comment\">//类集合操作</span><br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> nums1 &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> _, ok := set[v]; !ok &#123;<br>\t\t\tset[v] = NEW  <span class=\"hljs-comment\">// 第一个出现</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;  <span class=\"hljs-comment\">// 多次出现</span><br>\t\t\tset[v] = EXIST1<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> nums2 &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> _, ok := set[v]; ok &#123;  <span class=\"hljs-comment\">// nums2也出现</span><br>\t\t\tset[v] = EXIST2<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">for</span> k, v := <span class=\"hljs-keyword\">range</span> set &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v == EXIST2 &#123;<br>\t\t\tresult = <span class=\"hljs-built_in\">append</span>(result, k)<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"202-快乐数\"><a href=\"#202-快乐数\" class=\"headerlink\" title=\"202. 快乐数\"></a>202. 快乐数</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/happy-number/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html#%E6%80%9D%E8%B7%AF\">代码随想录(programmercarl.com)</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>构造一个集合，用于存放每一次拆数求平方和的结果</li>\n<li>拆数</li>\n<li>判断结果是否是1，如果是<code>return true</code></li>\n<li>如果不是1，判断结果是否在集合中，如果存在则说明出现了循环，<code>return false</code></li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isHappy</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\tset := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">bool</span>&#123;&#125;  <span class=\"hljs-comment\">// 模拟集合</span><br>\t<span class=\"hljs-keyword\">for</span> &#123;<br>\t\tsum := <span class=\"hljs-number\">0</span><br>        <span class=\"hljs-comment\">//拆数求平方和</span><br>\t\t<span class=\"hljs-keyword\">for</span> n &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\tsum += (n % <span class=\"hljs-number\">10</span>) * (n % <span class=\"hljs-number\">10</span>)<br>\t\t\tn /= <span class=\"hljs-number\">10</span><br>\t\t&#125;<br>        <span class=\"hljs-comment\">//得到正确答案</span><br>\t\t<span class=\"hljs-keyword\">if</span> sum == <span class=\"hljs-number\">1</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t\t&#125;<br>        <br>        <span class=\"hljs-comment\">//结果不在集合中则放入集合</span><br>\t\t<span class=\"hljs-keyword\">if</span> _, ok := set[sum]; !ok &#123;<br>\t\t\tset[sum] = <span class=\"hljs-literal\">true</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">// 否则退出循环 return false</span><br>\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t&#125;<br>\t\tn = sum <span class=\"hljs-comment\">// 新一轮的数</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和\"></a>1.两数之和</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/two-sum/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1aT41177mK\">梦开始的地方，Leetcode：1.两数之和</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>遍历<code>nums</code>将元素存为<code>map</code>的<code>key</code>，将元素的索引存放为<code>map</code>的<code>value</code>；</li>\n<li>再遍历<code>nums</code>，查看<code>target - v</code>是否在<code>key</code>中，并返回两个值：<code>nums</code>元素的索引和<code>map[target-v]</code></li>\n</ol>\n<p>遍历两次还是思路上走弯路了，一次即可。</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//遍历两次</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">twoSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>    mapNums := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>       mapNums[v] = i<br>    &#125;<br>    <span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>       <span class=\"hljs-keyword\">if</span> _, ok := mapNums[target-v]; ok &amp;&amp; mapNums[target-v] != i &#123;<br>          result = <span class=\"hljs-built_in\">append</span>(result, i)<br>          result = <span class=\"hljs-built_in\">append</span>(result, mapNums[target-v])<br>          <span class=\"hljs-keyword\">break</span><br>       &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">twoSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tmapNums := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> value, ok := mapNums[target-v]; ok &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;i, value&#125;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tmapNums[v] = i<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li><p>这次的题目不算很难，做起来就很快，算上写博客的时间不到两个小时</p>\n</li>\n<li><p>对Go语言的map有了新的理解：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">test = <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br><span class=\"hljs-keyword\">if</span> value, ok := test[key]; ok &#123;<br>\t<span class=\"hljs-comment\">// key存在的情况</span><br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t<span class=\"hljs-comment\">// key不存在的情况</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 使用反射来判断两个map是否相等</span><br><span class=\"hljs-keyword\">import</span> reflect<br>reflect.DeepEqual(map1, map2)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">test = <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>test[<span class=\"hljs-number\">1</span>]--  <span class=\"hljs-comment\">// 即使不存在1，默认新增键值对&#123;1:0&#125;，然后再自减</span><br></code></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>第一次使用Go模拟枚举</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">const</span> (<br>\tA <span class=\"hljs-literal\">iota</span><br>    B<br>    C<br>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"代码随想录算法训练营第八天 344. 反转字符串、541. 反转字符串II、剑指Offer 05.替换空格、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串。","abbrlink":"6416b651","date":"2023-09-28T06:17:36.000Z","_content":"\n# 代码随想录算法训练营第八天| 344. 反转字符串、541. 反转字符串II、剑指Offer 05.替换空格、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串。\n\n## 344. 反转字符串\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/reverse-string/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html)\n>\n>   视频讲解：[字符串基础操作！ | LeetCode：344.反转字符串](https://www.bilibili.com/video/BV1fV4y17748)\n>\n>   状态：AC\n\n### 思路\n\n![截屏2023-09-28 14.28.20](../images/day08/反转字符串.png)\n\n相同颜色的互换位置即可，即`i`与`len(s) - 1 - i`交换。`i`的范围到`len(s)/2`\n\n### 代码\n\n``` go\nfunc reverseString(s []byte) {\n\tfor i := 0; i < len(s)/2; i++ {\n\t\ttemp := s[i]\n\t\ts[i] = s[len(s)-i-1]\n\t\ts[len(s)-i-1] = temp\n\t}\n}\n```\n\n## 541. 反转字符串II\n\n>   题目链接：[力扣题目链接]([力扣题目链接](https://leetcode.cn/problems/reverse-string-ii/))\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html)\n>\n>   视频讲解：[字符串操作进阶！ | LeetCode：541. 反转字符串II](https://www.bilibili.com/video/BV1dT411j7NN)\n>\n>   状态：AC\n\n### 思路\n\n![反转2(1)](../images/day08/反转2(1).png)\n\n1.   如图，图中相同颜色的部分代表一个`2k`段，循环条件：`for i := 0; i < len(s); i += 2 * k`。\n2.   相同颜色下，分为两段，前`k`段和后`k`段。前`k`段进行反转，后`k`段直接拼接。如果某一段到达了字符串`s`尾部，需要停止。\n3.   由于Go语言的字符串不可变，所以新建一个变量，一点点“组装”成最终结果。前`k`段翻转直接进行反向遍历。\n\n### 代码\n\n``` go\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    } else {\n        return b\n    }\n}\n\nfunc reverseStr(s string, k int) string {\n\tnewString := \"\"\n\tfor i := 0; i < len(s); i += 2 * k {\n\t\tfor j := min(len(s), i+k) - 1; j >= i; j-- { // 前k段\n\t\t\tnewString += string(s[j])\n\t\t}\n\t\tfor j := i + k; j < min(len(s), i+2*k); j++ {  // 后k段\n\t\t\tnewString += string(s[j])\n\t\t}\n\t}\n\treturn newString\n}\n```\n\n## 剑指Offer 05.替换空格、LCR22.路径加密\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html)\n>\n>   状态：AC\n\n### 思路\n\n直接投机取巧，新建一个字符串`newString`，遍历字符串`s`，如果`s[i] == '.'`，在`newString += ' '`，否则`newString += s[i]`\n\n### 代码\n\n``` go\nfunc pathEncryption(path string) string {\n\tnewString := \"\"\n\tfor _, v:= range path{\n\t\tif v == '.' {\n\t\t\tnewString += \" \"\n\t\t} else {\n\t\t\tnewString += string(v)\n\t\t}\n\t}\n    return newString\n}\n```\n\n## 151.翻转字符串里的单词\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/reverse-words-in-a-string/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html)\n>\n>   视频链接：[字符串复杂操作拿捏了！ | LeetCode:151.翻转字符串里的单词](https://www.bilibili.com/video/BV1uT41177fX)\n>\n>   状态：AC\n\n### 思路\n\n1.   使用双指针，`left`指针指向的是单词的起始位置，遍历字符串用的`i`找到单词末尾。\n2.   新建一个字符串数组`words`，将每个单词加入到其中\n3.   定义新字符串`newString`，将`words`中每个单词拼接到`newString`中（反向遍历`words`），并且如果不是最后一个单词则再加一个空格。\n\n### 代码\n\n``` go\nfunc reverseWords(s string) string {\n\twords := []string{}\n\tleft := 0\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tif s[left:i] != \"\" {\n\t\t\t\twords = append(words, s[left:i])\n\t\t\t}\n\t\t\tleft = i + 1\n\t\t} else if i == len(s)-1 {\n\t\t\twords = append(words, s[left:])\n\t\t}\n\t}\n\tnewString := \"\"\n\tfor i := len(words) - 1; i >= 0; i-- {\n\t\tnewString += words[i]\n\t\tif i > 0 {\n\t\t\tnewString += \" \"\n\t\t}\n\t}\n\treturn newString\n}\n```\n\n## Offer58-II.左旋转字符串\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html)\n>\n>   状态：AC\n\n### 思路\n\n#### 方法一\n\n直接拼接\n\n#### 方法二\n\n![字符串移位](../images/day08/字符串移位.png)\n\n### 代码\n\n``` go\n// 方法一\nfunc dynamicPassword(password string, target int) string {\n\treturn password[target:] + password[:target]\n}\n```\n\n``` go\n// 方法二\nfunc reverse(chars []byte, left, right int) {\n    for left < right {\n        temp := chars[left]\n        chars[left] = chars[right]\n        chars[right] = temp\n        left++\n        right--\n    }\n}\nfunc dynamicPassword(password string, target int) string {\n    chars := []byte(s)\n    reverse(chars, 0, target - 1)\n    reverse(chars, target, len(chars) - 1)\n    reverse(chars, 0, len(chars) - 1)\n    return string(chars)\n}\n```\n\n","source":"_posts/day08.md","raw":"---\ntitle: 代码随想录算法训练营第八天 344. 反转字符串、541. 反转字符串II、剑指Offer\n  05.替换空格、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串。\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: 6416b651\ndate: 2023-09-28 14:17:36\n---\n\n# 代码随想录算法训练营第八天| 344. 反转字符串、541. 反转字符串II、剑指Offer 05.替换空格、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串。\n\n## 344. 反转字符串\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/reverse-string/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html)\n>\n>   视频讲解：[字符串基础操作！ | LeetCode：344.反转字符串](https://www.bilibili.com/video/BV1fV4y17748)\n>\n>   状态：AC\n\n### 思路\n\n![截屏2023-09-28 14.28.20](../images/day08/反转字符串.png)\n\n相同颜色的互换位置即可，即`i`与`len(s) - 1 - i`交换。`i`的范围到`len(s)/2`\n\n### 代码\n\n``` go\nfunc reverseString(s []byte) {\n\tfor i := 0; i < len(s)/2; i++ {\n\t\ttemp := s[i]\n\t\ts[i] = s[len(s)-i-1]\n\t\ts[len(s)-i-1] = temp\n\t}\n}\n```\n\n## 541. 反转字符串II\n\n>   题目链接：[力扣题目链接]([力扣题目链接](https://leetcode.cn/problems/reverse-string-ii/))\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html)\n>\n>   视频讲解：[字符串操作进阶！ | LeetCode：541. 反转字符串II](https://www.bilibili.com/video/BV1dT411j7NN)\n>\n>   状态：AC\n\n### 思路\n\n![反转2(1)](../images/day08/反转2(1).png)\n\n1.   如图，图中相同颜色的部分代表一个`2k`段，循环条件：`for i := 0; i < len(s); i += 2 * k`。\n2.   相同颜色下，分为两段，前`k`段和后`k`段。前`k`段进行反转，后`k`段直接拼接。如果某一段到达了字符串`s`尾部，需要停止。\n3.   由于Go语言的字符串不可变，所以新建一个变量，一点点“组装”成最终结果。前`k`段翻转直接进行反向遍历。\n\n### 代码\n\n``` go\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    } else {\n        return b\n    }\n}\n\nfunc reverseStr(s string, k int) string {\n\tnewString := \"\"\n\tfor i := 0; i < len(s); i += 2 * k {\n\t\tfor j := min(len(s), i+k) - 1; j >= i; j-- { // 前k段\n\t\t\tnewString += string(s[j])\n\t\t}\n\t\tfor j := i + k; j < min(len(s), i+2*k); j++ {  // 后k段\n\t\t\tnewString += string(s[j])\n\t\t}\n\t}\n\treturn newString\n}\n```\n\n## 剑指Offer 05.替换空格、LCR22.路径加密\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html)\n>\n>   状态：AC\n\n### 思路\n\n直接投机取巧，新建一个字符串`newString`，遍历字符串`s`，如果`s[i] == '.'`，在`newString += ' '`，否则`newString += s[i]`\n\n### 代码\n\n``` go\nfunc pathEncryption(path string) string {\n\tnewString := \"\"\n\tfor _, v:= range path{\n\t\tif v == '.' {\n\t\t\tnewString += \" \"\n\t\t} else {\n\t\t\tnewString += string(v)\n\t\t}\n\t}\n    return newString\n}\n```\n\n## 151.翻转字符串里的单词\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/reverse-words-in-a-string/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html)\n>\n>   视频链接：[字符串复杂操作拿捏了！ | LeetCode:151.翻转字符串里的单词](https://www.bilibili.com/video/BV1uT41177fX)\n>\n>   状态：AC\n\n### 思路\n\n1.   使用双指针，`left`指针指向的是单词的起始位置，遍历字符串用的`i`找到单词末尾。\n2.   新建一个字符串数组`words`，将每个单词加入到其中\n3.   定义新字符串`newString`，将`words`中每个单词拼接到`newString`中（反向遍历`words`），并且如果不是最后一个单词则再加一个空格。\n\n### 代码\n\n``` go\nfunc reverseWords(s string) string {\n\twords := []string{}\n\tleft := 0\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tif s[left:i] != \"\" {\n\t\t\t\twords = append(words, s[left:i])\n\t\t\t}\n\t\t\tleft = i + 1\n\t\t} else if i == len(s)-1 {\n\t\t\twords = append(words, s[left:])\n\t\t}\n\t}\n\tnewString := \"\"\n\tfor i := len(words) - 1; i >= 0; i-- {\n\t\tnewString += words[i]\n\t\tif i > 0 {\n\t\t\tnewString += \" \"\n\t\t}\n\t}\n\treturn newString\n}\n```\n\n## Offer58-II.左旋转字符串\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html)\n>\n>   状态：AC\n\n### 思路\n\n#### 方法一\n\n直接拼接\n\n#### 方法二\n\n![字符串移位](../images/day08/字符串移位.png)\n\n### 代码\n\n``` go\n// 方法一\nfunc dynamicPassword(password string, target int) string {\n\treturn password[target:] + password[:target]\n}\n```\n\n``` go\n// 方法二\nfunc reverse(chars []byte, left, right int) {\n    for left < right {\n        temp := chars[left]\n        chars[left] = chars[right]\n        chars[right] = temp\n        left++\n        right--\n    }\n}\nfunc dynamicPassword(password string, target int) string {\n    chars := []byte(s)\n    reverse(chars, 0, target - 1)\n    reverse(chars, target, len(chars) - 1)\n    reverse(chars, 0, len(chars) - 1)\n    return string(chars)\n}\n```\n\n","slug":"day08","published":1,"updated":"2023-10-04T11:44:13.085Z","_id":"cln7q7alv000bvswh5akb3kmg","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第八天-344-反转字符串、541-反转字符串II、剑指Offer-05-替换空格、151-翻转字符串里的单词、剑指Offer58-II-左旋转字符串。\"><a href=\"#代码随想录算法训练营第八天-344-反转字符串、541-反转字符串II、剑指Offer-05-替换空格、151-翻转字符串里的单词、剑指Offer58-II-左旋转字符串。\" class=\"headerlink\" title=\"代码随想录算法训练营第八天| 344. 反转字符串、541. 反转字符串II、剑指Offer 05.替换空格、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串。\"></a>代码随想录算法训练营第八天| 344. 反转字符串、541. 反转字符串II、剑指Offer 05.替换空格、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串。</h1><h2 id=\"344-反转字符串\"><a href=\"#344-反转字符串\" class=\"headerlink\" title=\"344. 反转字符串\"></a>344. 反转字符串</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/reverse-string/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1fV4y17748\">字符串基础操作！ | LeetCode：344.反转字符串</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p><img src=\"/../images/day08/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.png\" alt=\"截屏2023-09-28 14.28.20\"></p>\n<p>相同颜色的互换位置即可，即<code>i</code>与<code>len(s) - 1 - i</code>交换。<code>i</code>的范围到<code>len(s)/2</code></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">reverseString</span><span class=\"hljs-params\">(s []<span class=\"hljs-type\">byte</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s)/<span class=\"hljs-number\">2</span>; i++ &#123;<br>\t\ttemp := s[i]<br>\t\ts[i] = s[<span class=\"hljs-built_in\">len</span>(s)-i<span class=\"hljs-number\">-1</span>]<br>\t\ts[<span class=\"hljs-built_in\">len</span>(s)-i<span class=\"hljs-number\">-1</span>] = temp<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"541-反转字符串II\"><a href=\"#541-反转字符串II\" class=\"headerlink\" title=\"541. 反转字符串II\"></a>541. 反转字符串II</h2><blockquote>\n<p>  题目链接：<a href=\"%5B%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%5D(https://leetcode.cn/problems/reverse-string-ii/)\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1dT411j7NN\">字符串操作进阶！ | LeetCode：541. 反转字符串II</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p><img src=\"/../images/day08/%E5%8F%8D%E8%BD%AC2(1).png\" alt=\"反转2(1)\"></p>\n<ol>\n<li>如图，图中相同颜色的部分代表一个<code>2k</code>段，循环条件：<code>for i := 0; i &lt; len(s); i += 2 * k</code>。</li>\n<li>相同颜色下，分为两段，前<code>k</code>段和后<code>k</code>段。前<code>k</code>段进行反转，后<code>k</code>段直接拼接。如果某一段到达了字符串<code>s</code>尾部，需要停止。</li>\n<li>由于Go语言的字符串不可变，所以新建一个变量，一点点“组装”成最终结果。前<code>k</code>段翻转直接进行反向遍历。</li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &lt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> b<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">reverseStr</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>, k <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>\tnewString := <span class=\"hljs-string\">&quot;&quot;</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i += <span class=\"hljs-number\">2</span> * k &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> j := min(<span class=\"hljs-built_in\">len</span>(s), i+k) - <span class=\"hljs-number\">1</span>; j &gt;= i; j-- &#123; <span class=\"hljs-comment\">// 前k段</span><br>\t\t\tnewString += <span class=\"hljs-type\">string</span>(s[j])<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> j := i + k; j &lt; min(<span class=\"hljs-built_in\">len</span>(s), i+<span class=\"hljs-number\">2</span>*k); j++ &#123;  <span class=\"hljs-comment\">// 后k段</span><br>\t\t\tnewString += <span class=\"hljs-type\">string</span>(s[j])<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> newString<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"剑指Offer-05-替换空格、LCR22-路径加密\"><a href=\"#剑指Offer-05-替换空格、LCR22-路径加密\" class=\"headerlink\" title=\"剑指Offer 05.替换空格、LCR22.路径加密\"></a>剑指Offer 05.替换空格、LCR22.路径加密</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/ti-huan-kong-ge-lcof/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html\">代码随想录(programmercarl.com)</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>直接投机取巧，新建一个字符串<code>newString</code>，遍历字符串<code>s</code>，如果<code>s[i] == &#39;.&#39;</code>，在<code>newString += &#39; &#39;</code>，否则<code>newString += s[i]</code></p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">pathEncryption</span><span class=\"hljs-params\">(path <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>\tnewString := <span class=\"hljs-string\">&quot;&quot;</span><br>\t<span class=\"hljs-keyword\">for</span> _, v:= <span class=\"hljs-keyword\">range</span> path&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v == <span class=\"hljs-string\">&#x27;.&#x27;</span> &#123;<br>\t\t\tnewString += <span class=\"hljs-string\">&quot; &quot;</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tnewString += <span class=\"hljs-type\">string</span>(v)<br>\t\t&#125;<br>\t&#125;<br>    <span class=\"hljs-keyword\">return</span> newString<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"151-翻转字符串里的单词\"><a href=\"#151-翻转字符串里的单词\" class=\"headerlink\" title=\"151.翻转字符串里的单词\"></a>151.翻转字符串里的单词</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/reverse-words-in-a-string/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频链接：<a href=\"https://www.bilibili.com/video/BV1uT41177fX\">字符串复杂操作拿捏了！ | LeetCode:151.翻转字符串里的单词</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>使用双指针，<code>left</code>指针指向的是单词的起始位置，遍历字符串用的<code>i</code>找到单词末尾。</li>\n<li>新建一个字符串数组<code>words</code>，将每个单词加入到其中</li>\n<li>定义新字符串<code>newString</code>，将<code>words</code>中每个单词拼接到<code>newString</code>中（反向遍历<code>words</code>），并且如果不是最后一个单词则再加一个空格。</li>\n</ol>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">reverseWords</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>\twords := []<span class=\"hljs-type\">string</span>&#123;&#125;<br>\tleft := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> s[i] == <span class=\"hljs-string\">&#x27; &#x27;</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> s[left:i] != <span class=\"hljs-string\">&quot;&quot;</span> &#123;<br>\t\t\t\twords = <span class=\"hljs-built_in\">append</span>(words, s[left:i])<br>\t\t\t&#125;<br>\t\t\tleft = i + <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-built_in\">len</span>(s)<span class=\"hljs-number\">-1</span> &#123;<br>\t\t\twords = <span class=\"hljs-built_in\">append</span>(words, s[left:])<br>\t\t&#125;<br>\t&#125;<br>\tnewString := <span class=\"hljs-string\">&quot;&quot;</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-built_in\">len</span>(words) - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i-- &#123;<br>\t\tnewString += words[i]<br>\t\t<span class=\"hljs-keyword\">if</span> i &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\tnewString += <span class=\"hljs-string\">&quot; &quot;</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> newString<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Offer58-II-左旋转字符串\"><a href=\"#Offer58-II-左旋转字符串\" class=\"headerlink\" title=\"Offer58-II.左旋转字符串\"></a>Offer58-II.左旋转字符串</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html\">代码随想录(programmercarl.com)</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>直接拼接</p>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p><img src=\"/../images/day08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%BB%E4%BD%8D.png\" alt=\"字符串移位\"></p>\n<h3 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 方法一</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">dynamicPassword</span><span class=\"hljs-params\">(password <span class=\"hljs-type\">string</span>, target <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> password[target:] + password[:target]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 方法二</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">reverse</span><span class=\"hljs-params\">(chars []<span class=\"hljs-type\">byte</span>, left, right <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    <span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>        temp := chars[left]<br>        chars[left] = chars[right]<br>        chars[right] = temp<br>        left++<br>        right--<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">dynamicPassword</span><span class=\"hljs-params\">(password <span class=\"hljs-type\">string</span>, target <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>    chars := []<span class=\"hljs-type\">byte</span>(s)<br>    reverse(chars, <span class=\"hljs-number\">0</span>, target - <span class=\"hljs-number\">1</span>)<br>    reverse(chars, target, <span class=\"hljs-built_in\">len</span>(chars) - <span class=\"hljs-number\">1</span>)<br>    reverse(chars, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(chars) - <span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">string</span>(chars)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第八天-344-反转字符串、541-反转字符串II、剑指Offer-05-替换空格、151-翻转字符串里的单词、剑指Offer58-II-左旋转字符串。\"><a href=\"#代码随想录算法训练营第八天-344-反转字符串、541-反转字符串II、剑指Offer-05-替换空格、151-翻转字符串里的单词、剑指Offer58-II-左旋转字符串。\" class=\"headerlink\" title=\"代码随想录算法训练营第八天| 344. 反转字符串、541. 反转字符串II、剑指Offer 05.替换空格、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串。\"></a>代码随想录算法训练营第八天| 344. 反转字符串、541. 反转字符串II、剑指Offer 05.替换空格、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串。</h1><h2 id=\"344-反转字符串\"><a href=\"#344-反转字符串\" class=\"headerlink\" title=\"344. 反转字符串\"></a>344. 反转字符串</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/reverse-string/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1fV4y17748\">字符串基础操作！ | LeetCode：344.反转字符串</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p><img src=\"/../images/day08/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.png\" alt=\"截屏2023-09-28 14.28.20\"></p>\n<p>相同颜色的互换位置即可，即<code>i</code>与<code>len(s) - 1 - i</code>交换。<code>i</code>的范围到<code>len(s)/2</code></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">reverseString</span><span class=\"hljs-params\">(s []<span class=\"hljs-type\">byte</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s)/<span class=\"hljs-number\">2</span>; i++ &#123;<br>\t\ttemp := s[i]<br>\t\ts[i] = s[<span class=\"hljs-built_in\">len</span>(s)-i<span class=\"hljs-number\">-1</span>]<br>\t\ts[<span class=\"hljs-built_in\">len</span>(s)-i<span class=\"hljs-number\">-1</span>] = temp<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"541-反转字符串II\"><a href=\"#541-反转字符串II\" class=\"headerlink\" title=\"541. 反转字符串II\"></a>541. 反转字符串II</h2><blockquote>\n<p>  题目链接：<a href=\"%5B%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%5D(https://leetcode.cn/problems/reverse-string-ii/)\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1dT411j7NN\">字符串操作进阶！ | LeetCode：541. 反转字符串II</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p><img src=\"/../images/day08/%E5%8F%8D%E8%BD%AC2(1).png\" alt=\"反转2(1)\"></p>\n<ol>\n<li>如图，图中相同颜色的部分代表一个<code>2k</code>段，循环条件：<code>for i := 0; i &lt; len(s); i += 2 * k</code>。</li>\n<li>相同颜色下，分为两段，前<code>k</code>段和后<code>k</code>段。前<code>k</code>段进行反转，后<code>k</code>段直接拼接。如果某一段到达了字符串<code>s</code>尾部，需要停止。</li>\n<li>由于Go语言的字符串不可变，所以新建一个变量，一点点“组装”成最终结果。前<code>k</code>段翻转直接进行反向遍历。</li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> a &lt; b &#123;<br>        <span class=\"hljs-keyword\">return</span> a<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> b<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">reverseStr</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>, k <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>\tnewString := <span class=\"hljs-string\">&quot;&quot;</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i += <span class=\"hljs-number\">2</span> * k &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> j := min(<span class=\"hljs-built_in\">len</span>(s), i+k) - <span class=\"hljs-number\">1</span>; j &gt;= i; j-- &#123; <span class=\"hljs-comment\">// 前k段</span><br>\t\t\tnewString += <span class=\"hljs-type\">string</span>(s[j])<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> j := i + k; j &lt; min(<span class=\"hljs-built_in\">len</span>(s), i+<span class=\"hljs-number\">2</span>*k); j++ &#123;  <span class=\"hljs-comment\">// 后k段</span><br>\t\t\tnewString += <span class=\"hljs-type\">string</span>(s[j])<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> newString<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"剑指Offer-05-替换空格、LCR22-路径加密\"><a href=\"#剑指Offer-05-替换空格、LCR22-路径加密\" class=\"headerlink\" title=\"剑指Offer 05.替换空格、LCR22.路径加密\"></a>剑指Offer 05.替换空格、LCR22.路径加密</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/ti-huan-kong-ge-lcof/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html\">代码随想录(programmercarl.com)</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>直接投机取巧，新建一个字符串<code>newString</code>，遍历字符串<code>s</code>，如果<code>s[i] == &#39;.&#39;</code>，在<code>newString += &#39; &#39;</code>，否则<code>newString += s[i]</code></p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">pathEncryption</span><span class=\"hljs-params\">(path <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>\tnewString := <span class=\"hljs-string\">&quot;&quot;</span><br>\t<span class=\"hljs-keyword\">for</span> _, v:= <span class=\"hljs-keyword\">range</span> path&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v == <span class=\"hljs-string\">&#x27;.&#x27;</span> &#123;<br>\t\t\tnewString += <span class=\"hljs-string\">&quot; &quot;</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tnewString += <span class=\"hljs-type\">string</span>(v)<br>\t\t&#125;<br>\t&#125;<br>    <span class=\"hljs-keyword\">return</span> newString<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"151-翻转字符串里的单词\"><a href=\"#151-翻转字符串里的单词\" class=\"headerlink\" title=\"151.翻转字符串里的单词\"></a>151.翻转字符串里的单词</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/reverse-words-in-a-string/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频链接：<a href=\"https://www.bilibili.com/video/BV1uT41177fX\">字符串复杂操作拿捏了！ | LeetCode:151.翻转字符串里的单词</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>使用双指针，<code>left</code>指针指向的是单词的起始位置，遍历字符串用的<code>i</code>找到单词末尾。</li>\n<li>新建一个字符串数组<code>words</code>，将每个单词加入到其中</li>\n<li>定义新字符串<code>newString</code>，将<code>words</code>中每个单词拼接到<code>newString</code>中（反向遍历<code>words</code>），并且如果不是最后一个单词则再加一个空格。</li>\n</ol>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">reverseWords</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>\twords := []<span class=\"hljs-type\">string</span>&#123;&#125;<br>\tleft := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> s[i] == <span class=\"hljs-string\">&#x27; &#x27;</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> s[left:i] != <span class=\"hljs-string\">&quot;&quot;</span> &#123;<br>\t\t\t\twords = <span class=\"hljs-built_in\">append</span>(words, s[left:i])<br>\t\t\t&#125;<br>\t\t\tleft = i + <span class=\"hljs-number\">1</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-built_in\">len</span>(s)<span class=\"hljs-number\">-1</span> &#123;<br>\t\t\twords = <span class=\"hljs-built_in\">append</span>(words, s[left:])<br>\t\t&#125;<br>\t&#125;<br>\tnewString := <span class=\"hljs-string\">&quot;&quot;</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-built_in\">len</span>(words) - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i-- &#123;<br>\t\tnewString += words[i]<br>\t\t<span class=\"hljs-keyword\">if</span> i &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\tnewString += <span class=\"hljs-string\">&quot; &quot;</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> newString<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Offer58-II-左旋转字符串\"><a href=\"#Offer58-II-左旋转字符串\" class=\"headerlink\" title=\"Offer58-II.左旋转字符串\"></a>Offer58-II.左旋转字符串</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html\">代码随想录(programmercarl.com)</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>直接拼接</p>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p><img src=\"/../images/day08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%BB%E4%BD%8D.png\" alt=\"字符串移位\"></p>\n<h3 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 方法一</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">dynamicPassword</span><span class=\"hljs-params\">(password <span class=\"hljs-type\">string</span>, target <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> password[target:] + password[:target]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 方法二</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">reverse</span><span class=\"hljs-params\">(chars []<span class=\"hljs-type\">byte</span>, left, right <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    <span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>        temp := chars[left]<br>        chars[left] = chars[right]<br>        chars[right] = temp<br>        left++<br>        right--<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">dynamicPassword</span><span class=\"hljs-params\">(password <span class=\"hljs-type\">string</span>, target <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>    chars := []<span class=\"hljs-type\">byte</span>(s)<br>    reverse(chars, <span class=\"hljs-number\">0</span>, target - <span class=\"hljs-number\">1</span>)<br>    reverse(chars, target, <span class=\"hljs-built_in\">len</span>(chars) - <span class=\"hljs-number\">1</span>)<br>    reverse(chars, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(chars) - <span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">string</span>(chars)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"代码随想录算法训练营第九天 28. 实现 strStr()。459.重复的子字符串","abbrlink":"369230e4","date":"2023-09-28T07:08:08.000Z","_content":"\n# 代码随想录算法训练营第九天 28. 实现 strStr()。459.重复的子字符串\n\n## 28.实现strStr()\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html)\n>\n>   视频讲解：\n>\n>   -   [帮你把KMP算法学个通透！B站（理论篇）](https://www.bilibili.com/video/BV1PD4y1o7nd/)\n>   -   [帮你把KMP算法学个通透！（求next数组代码篇）](https://www.bilibili.com/video/BV1M5411j7Xx)\n>\n>   状态：看过视频之后AC\n\n### 思路\n\n具体KMP算法原理看卡哥的视频，讲的很好。\n\n#### KMP中匹配的过程\n\nKMP算法，匹配过程放入到一个小视频当中，每个画面持续3秒。好多视频讲解都是“移动模式串”来讲，自己写代码时候有点蒙，所以自己做了个小动图，不使用“移动”来呈现。\n\n<div style=\"position: relative; width: 100%; height: 100%;padding-bottom: 100%;\"><iframe \nsrc=\"../images/day09/匹配.mp4\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n\n#### Next数组构建过程\n\n<div style=\"position: relative; width: 100%; height: 0;padding-bottom: 100%;\"><iframe \nsrc=\"../images/day09/next数组构建.mp4\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n\n\n#### Next数组说明\n\nNext数组中，每个元素表示：\n\n-   截止到目前为止，最长相等前后缀的长度；\n-   截止到目前为止，最长前缀的后一位。\n\n### 代码\n\n``` go\nfunc getNext(next []int, s string) {\n\tj := 0\n\tnext[0] = 0\n\tfor i := 1; i < len(s); i++ {\n\t\tfor s[i] != s[j] && j > 0 {\n\t\t\tj = next[j-1]\n\t\t}\n\t\tif s[i] == s[j] {\n\t\t\tj++\n\t\t}\n\t\tnext[i] = j\n\t\t//fmt.Printf(\"第%v次循环后的next数组结果为:%v\\n\", i, next)\n\t}\n}\n\nfunc strStr(haystack string, needle string) int {\n\tif len(needle) == 0 {\n\t\treturn 0\n\t}\n\tnext := make([]int, len(needle))\n\tgetNext(next, needle)\n\tj := 0\n\tfor i := range haystack {\n\t\tfor j > 0 && haystack[i] != needle[j] {\n\t\t\tj = next[j-1]\n\t\t}\n\t\tif haystack[i] == needle[j] {\n\t\t\tj++\n\t\t}\n\t\tif j == len(needle) {\n\t\t\treturn i - len(needle) + 1\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n\n\n## 459. 重复的字符串\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/repeated-substring-pattern/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html)\n>\n>   视频讲解：[字符串这么玩，可有点难度！ | LeetCode：459.重复的子字符串](https://www.bilibili.com/video/BV1cg41127fw)\n>\n>   状态：AC\n\n### 思路\n\n如果不使用KMP算法还是比较简单的，有很多东西语言已经帮我们实现好了。看了卡哥的讲解感叹这个思路。\n\n构建一个新字符串`newString`为两个旧串`s`的拼接，但是要掐头去尾一个元素。如果`newString`仍然包含`s`，说明存在子串构成原字符串。\n\n### 代码\n\n``` go\nfunc repeatedSubstringPattern(s string) bool {\n\tnewString := s + s\n\tnewString = newString[1 : len(newString)-2]\n\treturn strings.Contains(newString, s)\n}\n```\n\n","source":"_posts/day09.md","raw":"---\ntitle: 代码随想录算法训练营第九天 28. 实现 strStr()。459.重复的子字符串\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: '369230e4'\ndate: 2023-09-28 15:08:08\n---\n\n# 代码随想录算法训练营第九天 28. 实现 strStr()。459.重复的子字符串\n\n## 28.实现strStr()\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html)\n>\n>   视频讲解：\n>\n>   -   [帮你把KMP算法学个通透！B站（理论篇）](https://www.bilibili.com/video/BV1PD4y1o7nd/)\n>   -   [帮你把KMP算法学个通透！（求next数组代码篇）](https://www.bilibili.com/video/BV1M5411j7Xx)\n>\n>   状态：看过视频之后AC\n\n### 思路\n\n具体KMP算法原理看卡哥的视频，讲的很好。\n\n#### KMP中匹配的过程\n\nKMP算法，匹配过程放入到一个小视频当中，每个画面持续3秒。好多视频讲解都是“移动模式串”来讲，自己写代码时候有点蒙，所以自己做了个小动图，不使用“移动”来呈现。\n\n<div style=\"position: relative; width: 100%; height: 100%;padding-bottom: 100%;\"><iframe \nsrc=\"../images/day09/匹配.mp4\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n\n#### Next数组构建过程\n\n<div style=\"position: relative; width: 100%; height: 0;padding-bottom: 100%;\"><iframe \nsrc=\"../images/day09/next数组构建.mp4\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n\n\n#### Next数组说明\n\nNext数组中，每个元素表示：\n\n-   截止到目前为止，最长相等前后缀的长度；\n-   截止到目前为止，最长前缀的后一位。\n\n### 代码\n\n``` go\nfunc getNext(next []int, s string) {\n\tj := 0\n\tnext[0] = 0\n\tfor i := 1; i < len(s); i++ {\n\t\tfor s[i] != s[j] && j > 0 {\n\t\t\tj = next[j-1]\n\t\t}\n\t\tif s[i] == s[j] {\n\t\t\tj++\n\t\t}\n\t\tnext[i] = j\n\t\t//fmt.Printf(\"第%v次循环后的next数组结果为:%v\\n\", i, next)\n\t}\n}\n\nfunc strStr(haystack string, needle string) int {\n\tif len(needle) == 0 {\n\t\treturn 0\n\t}\n\tnext := make([]int, len(needle))\n\tgetNext(next, needle)\n\tj := 0\n\tfor i := range haystack {\n\t\tfor j > 0 && haystack[i] != needle[j] {\n\t\t\tj = next[j-1]\n\t\t}\n\t\tif haystack[i] == needle[j] {\n\t\t\tj++\n\t\t}\n\t\tif j == len(needle) {\n\t\t\treturn i - len(needle) + 1\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n\n\n## 459. 重复的字符串\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/repeated-substring-pattern/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html)\n>\n>   视频讲解：[字符串这么玩，可有点难度！ | LeetCode：459.重复的子字符串](https://www.bilibili.com/video/BV1cg41127fw)\n>\n>   状态：AC\n\n### 思路\n\n如果不使用KMP算法还是比较简单的，有很多东西语言已经帮我们实现好了。看了卡哥的讲解感叹这个思路。\n\n构建一个新字符串`newString`为两个旧串`s`的拼接，但是要掐头去尾一个元素。如果`newString`仍然包含`s`，说明存在子串构成原字符串。\n\n### 代码\n\n``` go\nfunc repeatedSubstringPattern(s string) bool {\n\tnewString := s + s\n\tnewString = newString[1 : len(newString)-2]\n\treturn strings.Contains(newString, s)\n}\n```\n\n","slug":"day09","published":1,"updated":"2023-10-04T11:44:13.085Z","_id":"cln7q7alw000evswh5pqt7yew","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第九天-28-实现-strStr-。459-重复的子字符串\"><a href=\"#代码随想录算法训练营第九天-28-实现-strStr-。459-重复的子字符串\" class=\"headerlink\" title=\"代码随想录算法训练营第九天 28. 实现 strStr()。459.重复的子字符串\"></a>代码随想录算法训练营第九天 28. 实现 strStr()。459.重复的子字符串</h1><h2 id=\"28-实现strStr\"><a href=\"#28-实现strStr\" class=\"headerlink\" title=\"28.实现strStr()\"></a>28.实现strStr()</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1PD4y1o7nd/\">帮你把KMP算法学个通透！B站（理论篇）</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1M5411j7Xx\">帮你把KMP算法学个通透！（求next数组代码篇）</a></li>\n</ul>\n<p>  状态：看过视频之后AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>具体KMP算法原理看卡哥的视频，讲的很好。</p>\n<h4 id=\"KMP中匹配的过程\"><a href=\"#KMP中匹配的过程\" class=\"headerlink\" title=\"KMP中匹配的过程\"></a>KMP中匹配的过程</h4><p>KMP算法，匹配过程放入到一个小视频当中，每个画面持续3秒。好多视频讲解都是“移动模式串”来讲，自己写代码时候有点蒙，所以自己做了个小动图，不使用“移动”来呈现。</p>\n<div style=\"position: relative; width: 100%; height: 100%;padding-bottom: 100%;\"><iframe \nsrc=\"../images/day09/匹配.mp4\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n\n<h4 id=\"Next数组构建过程\"><a href=\"#Next数组构建过程\" class=\"headerlink\" title=\"Next数组构建过程\"></a>Next数组构建过程</h4><div style=\"position: relative; width: 100%; height: 0;padding-bottom: 100%;\"><iframe \nsrc=\"../images/day09/next数组构建.mp4\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n\n\n<h4 id=\"Next数组说明\"><a href=\"#Next数组说明\" class=\"headerlink\" title=\"Next数组说明\"></a>Next数组说明</h4><p>Next数组中，每个元素表示：</p>\n<ul>\n<li>截止到目前为止，最长相等前后缀的长度；</li>\n<li>截止到目前为止，最长前缀的后一位。</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getNext</span><span class=\"hljs-params\">(next []<span class=\"hljs-type\">int</span>, s <span class=\"hljs-type\">string</span>)</span></span> &#123;<br>\tj := <span class=\"hljs-number\">0</span><br>\tnext[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> s[i] != s[j] &amp;&amp; j &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\tj = next[j<span class=\"hljs-number\">-1</span>]<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> s[i] == s[j] &#123;<br>\t\t\tj++<br>\t\t&#125;<br>\t\tnext[i] = j<br>\t\t<span class=\"hljs-comment\">//fmt.Printf(&quot;第%v次循环后的next数组结果为:%v\\n&quot;, i, next)</span><br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">strStr</span><span class=\"hljs-params\">(haystack <span class=\"hljs-type\">string</span>, needle <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(needle) == <span class=\"hljs-number\">0</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tnext := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(needle))<br>\tgetNext(next, needle)<br>\tj := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> haystack &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> j &gt; <span class=\"hljs-number\">0</span> &amp;&amp; haystack[i] != needle[j] &#123;<br>\t\t\tj = next[j<span class=\"hljs-number\">-1</span>]<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> haystack[i] == needle[j] &#123;<br>\t\t\tj++<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> j == <span class=\"hljs-built_in\">len</span>(needle) &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> i - <span class=\"hljs-built_in\">len</span>(needle) + <span class=\"hljs-number\">1</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"459-重复的字符串\"><a href=\"#459-重复的字符串\" class=\"headerlink\" title=\"459. 重复的字符串\"></a>459. 重复的字符串</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/repeated-substring-pattern/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1cg41127fw\">字符串这么玩，可有点难度！ | LeetCode：459.重复的子字符串</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>如果不使用KMP算法还是比较简单的，有很多东西语言已经帮我们实现好了。看了卡哥的讲解感叹这个思路。</p>\n<p>构建一个新字符串<code>newString</code>为两个旧串<code>s</code>的拼接，但是要掐头去尾一个元素。如果<code>newString</code>仍然包含<code>s</code>，说明存在子串构成原字符串。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">repeatedSubstringPattern</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\tnewString := s + s<br>\tnewString = newString[<span class=\"hljs-number\">1</span> : <span class=\"hljs-built_in\">len</span>(newString)<span class=\"hljs-number\">-2</span>]<br>\t<span class=\"hljs-keyword\">return</span> strings.Contains(newString, s)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第九天-28-实现-strStr-。459-重复的子字符串\"><a href=\"#代码随想录算法训练营第九天-28-实现-strStr-。459-重复的子字符串\" class=\"headerlink\" title=\"代码随想录算法训练营第九天 28. 实现 strStr()。459.重复的子字符串\"></a>代码随想录算法训练营第九天 28. 实现 strStr()。459.重复的子字符串</h1><h2 id=\"28-实现strStr\"><a href=\"#28-实现strStr\" class=\"headerlink\" title=\"28.实现strStr()\"></a>28.实现strStr()</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1PD4y1o7nd/\">帮你把KMP算法学个通透！B站（理论篇）</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1M5411j7Xx\">帮你把KMP算法学个通透！（求next数组代码篇）</a></li>\n</ul>\n<p>  状态：看过视频之后AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>具体KMP算法原理看卡哥的视频，讲的很好。</p>\n<h4 id=\"KMP中匹配的过程\"><a href=\"#KMP中匹配的过程\" class=\"headerlink\" title=\"KMP中匹配的过程\"></a>KMP中匹配的过程</h4><p>KMP算法，匹配过程放入到一个小视频当中，每个画面持续3秒。好多视频讲解都是“移动模式串”来讲，自己写代码时候有点蒙，所以自己做了个小动图，不使用“移动”来呈现。</p>\n<div style=\"position: relative; width: 100%; height: 100%;padding-bottom: 100%;\"><iframe \nsrc=\"../images/day09/匹配.mp4\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n\n<h4 id=\"Next数组构建过程\"><a href=\"#Next数组构建过程\" class=\"headerlink\" title=\"Next数组构建过程\"></a>Next数组构建过程</h4><div style=\"position: relative; width: 100%; height: 0;padding-bottom: 100%;\"><iframe \nsrc=\"../images/day09/next数组构建.mp4\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n\n\n<h4 id=\"Next数组说明\"><a href=\"#Next数组说明\" class=\"headerlink\" title=\"Next数组说明\"></a>Next数组说明</h4><p>Next数组中，每个元素表示：</p>\n<ul>\n<li>截止到目前为止，最长相等前后缀的长度；</li>\n<li>截止到目前为止，最长前缀的后一位。</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getNext</span><span class=\"hljs-params\">(next []<span class=\"hljs-type\">int</span>, s <span class=\"hljs-type\">string</span>)</span></span> &#123;<br>\tj := <span class=\"hljs-number\">0</span><br>\tnext[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> s[i] != s[j] &amp;&amp; j &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\tj = next[j<span class=\"hljs-number\">-1</span>]<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> s[i] == s[j] &#123;<br>\t\t\tj++<br>\t\t&#125;<br>\t\tnext[i] = j<br>\t\t<span class=\"hljs-comment\">//fmt.Printf(&quot;第%v次循环后的next数组结果为:%v\\n&quot;, i, next)</span><br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">strStr</span><span class=\"hljs-params\">(haystack <span class=\"hljs-type\">string</span>, needle <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(needle) == <span class=\"hljs-number\">0</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tnext := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(needle))<br>\tgetNext(next, needle)<br>\tj := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> haystack &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> j &gt; <span class=\"hljs-number\">0</span> &amp;&amp; haystack[i] != needle[j] &#123;<br>\t\t\tj = next[j<span class=\"hljs-number\">-1</span>]<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> haystack[i] == needle[j] &#123;<br>\t\t\tj++<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> j == <span class=\"hljs-built_in\">len</span>(needle) &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> i - <span class=\"hljs-built_in\">len</span>(needle) + <span class=\"hljs-number\">1</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"459-重复的字符串\"><a href=\"#459-重复的字符串\" class=\"headerlink\" title=\"459. 重复的字符串\"></a>459. 重复的字符串</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/repeated-substring-pattern/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1cg41127fw\">字符串这么玩，可有点难度！ | LeetCode：459.重复的子字符串</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>如果不使用KMP算法还是比较简单的，有很多东西语言已经帮我们实现好了。看了卡哥的讲解感叹这个思路。</p>\n<p>构建一个新字符串<code>newString</code>为两个旧串<code>s</code>的拼接，但是要掐头去尾一个元素。如果<code>newString</code>仍然包含<code>s</code>，说明存在子串构成原字符串。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">repeatedSubstringPattern</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\tnewString := s + s<br>\tnewString = newString[<span class=\"hljs-number\">1</span> : <span class=\"hljs-built_in\">len</span>(newString)<span class=\"hljs-number\">-2</span>]<br>\t<span class=\"hljs-keyword\">return</span> strings.Contains(newString, s)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"代码随想录算法训练营第七天| 454.四数相加II、383. 赎金信、15. 三数之和、18. 四数之和。","abbrlink":"bc862a56","date":"2023-09-26T03:31:08.000Z","_content":"\n# 代码随想录算法训练营第七天| 454.四数相加II、383. 赎金信、15. 三数之和、18. 四数之和。\n\n## 454. 两数相加\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/4sum-ii/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)\n>\n>   视频讲解：[学透哈希表，map使用有技巧！LeetCode：454.四数相加II](https://www.bilibili.com/video/BV1Md4y1Q7Yh)\n>\n>   状态：TLE\n\n### 思路\n\n#### 思路一：暴力算法\n\n暴力算法就不用解释了，每个元素都遍历下。定义`count`记录满足条件情况的个数。满足条件`count++`就好。不出意外的也肯定会超时。\n\n#### 思路二：使用map\n\n将`num4`的值存入到`map4`中的`key`，值出现的次数存为`value`。三层循环后接一个判断，判断第四个数是否在`map4`中，如果存在则总数加`value`\n\n```go\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {\n\tcount := 0\n\tmap4 := map[int]int{}\n\tfor _, v := range nums4 {\n\t\tmap4[v]++\n\t}\n\tfor _, i := range nums1 {\n\t\tfor _, j := range nums2 {\n\t\t\tfor _, k := range nums3 {\n\t\t\t\tif v, ok := map4[0-i-j-k]; ok {\n\t\t\t\t\tcount += v\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n```\n\n结果你猜超时没有，肯定还是超时了。\n\n#### 思路三：使用四个map\n\n每个map中都存放`nums`中出现的数以及出现的次数。第一个map定义为`map1`，键是`k1`，值是`v1`，以此类推。\n\n三层循环后判断`map4[0-k1-k2-k3]`是否存在，如果存在那么`count += v1 * v2 * v3 * v4`\n\n``` go\ncount := 0\nmap1 := map[int]int{}\nmap2 := map[int]int{}\nmap3 := map[int]int{}\nmap4 := map[int]int{}\nfor i := 0; i < len(nums1); i++ {\n    map1[nums1[i]]++\n    map2[nums2[i]]++\n    map3[nums3[i]]++\n    map4[nums4[i]]++\n}\nfor k1, v1 := range map1 {\n    for k2, v2 := range map2 {\n        for k3, v3 := range map3 {\n            if v4, ok := map4[0-k1-k2-k3]; ok {\n                count += v1 * v2 * v3 * v4\n            }\n        }\n    }\n}\nreturn count\n```\n\n结果你猜超时没有，肯定还是超时了。\n\n原因如下：如果数组中重复的数不多，或者没有，就会退化成思路二。\n\n想了许久，想不出优化的方法了，看了卡哥的题解，我就用我的理解描述一下。\n\n#### 卡哥题解\n\n先计算`nums1`与`nums2`和，将两数组所有和的情况保存到`mapAB`中。key保存的是和，value保存的是和的个数。\n\n再计算`nums3`与`nums4`和，判断`mapAB[0-k3-k4]`是否存在，若存在`count+=mapAB[0-k3-k4]`\n\n``` go\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {\n\tcount := 0\n\tmapAB := map[int]int{}\n\tfor _, v1 := range nums1 {\n\t\tfor _, v2 := range nums2 {\n\t\t\tmapAB[v1+v2]++\n\t\t}\n\t}\n\tfor _, v3 := range nums3 {\n\t\tfor _, v4 := range nums4 {\n\t\t\tif v, ok := mapAB[0-v3-v4]; ok {\n\t\t\t\tcount += v\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n```\n\n## 383. 赎金信\n\n### 思路\n\n要判断`ransomNote`是否含于`magazine`，先构建一个数组，存放`magazine`的情况，索引代表字母：0代表`'a'`，1代表`'b'`等等；值代表字母出现的次数。构建好后再遍历`ransomNote`串，将对应的字母数量减少一，如果不存在直接`return false`\n\n### 代码\n\n``` go\nfunc canConstruct(ransomNote string, magazine string) bool {\n\tif len(ransomNote) > len(magazine) {\n\t\treturn false\n\t}\n\tarr := make([]int, 26)\n\tfor _, v := range magazine {\n\t\tarr[v-'a']++\n\t}\n\tfor _, v := range ransomNote {\n\t\tarr[v-'a']--\n\t\tif arr[v-'a'] < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```\n\n\n\n## 15. 三数之和\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/3sum/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)\n>\n>   视频讲解：[梦破碎的地方！| LeetCode：15.三数之和](https://www.bilibili.com/video/BV1GW4y127qo)\n>\n>   状态：TLE\n\n### 思路\n\n我投降了这道题，Go的底层现在有一个新的理解！\n\n#### 方法一：回溯算法\n\n首先先将`nums`排序，利用回溯算法得到所有的组合，选择排序的原因是因为这样得到的组合，即使是重复的也可以保证顺序一致，方便判断这个组合是否出现过。最终结果保存到变量`result`，得到的可能得组合保存到变量`path`\n\n#### 代码\n\n``` go\nfunc backTracking(nums []int, index int, result *[][]int, path *[]int) {\n\tif len(*path) == 3 {\n\t\tif (*path)[0]+(*path)[1]+(*path)[2] == 0 {\n\t\t\t// 后面的append()操作是深拷贝，所以这里使用temp保存path的值\n            temp := make([]int, len(*path))  \n\t\t\tcopy(temp, *path)\n\t\t\tfor _, v := range *result {\n\t\t\t\tif reflect.DeepEqual(temp, v) {  // 使用反射判断temp是否在result中\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\t*result = append(*result, temp)\n\t\t}\n\t\treturn\n\t}\n\tfor i := index; i < len(nums); i++ {\n\t\t*path = append(*path, nums[i])\n\t\tbackTracking(nums, i+1, result, path)\n\t\t*path = (*path)[:len(*path)-1]\n\n\t}\n}\n\nfunc threeSum(nums []int) [][]int {\n\tvar result [][]int\n\tvar path []int\n\tsort.Ints(nums)\n\tbackTracking(nums, 0, &result, &path)\n\treturn result\n}\n```\n\n结果你猜超时没有，肯定还是超时了。\n\n这里我遇到了好多问题，首先是发现了`result = append(result, temp)`，这里`append`方法实际上是浅拷贝！也就是说以后`temp`的值，`result`也会变化。这也是我为什么用一个临时变量`temp`来保存`path`，而且使用的是`copy()`。\n\n要判断`temp`是否存在于`result`中，那么则需要使用反射，进行深度判断`reflect.DeepEqual(temp, v)`。\n\n##### 遇到最头大的问题！！！！！！\n\n以前用别的语言写回溯，很自然的使用了全局变量，结果在Go语言中发生了奇妙的事情。请看截图\n\n<img src=\"../images/day07/使用全局变量leetcode.png\" alt=\"使用全局变量leetcode\" style=\"zoom:80%;\" />\n\n明明输入的只有0和1，怎么会输出了2。而且这个测试用例这么眼熟呢，没错这就是给出的测试用例Case1的答案。放到Goland里面明明是正确答案！到这里就变了，说明全局变量出现了问题。解决这个问题有两个想法：\n\n-   查找有没有类似C++中的`delete`，使用完变量之后释放掉。发现并没有。而且使用完变量应该在`threeSum()`之外了，函数内释放就没有结果了。\n-   `threeSum()`定义变量，使用指针传值。\n\n当然，第二种才是正解。改完之后就是上面放出来的代码了，超时。\n\n#### 方法二：使用哈希\n\n将`nums`进行排序，并哈希处理，定义变量`map1`用作哈希表，`nums`中的每个元素做key，value则是每个元素出现的次数。\n\n使用两层for循环之后，判断`0-nums[i]-nums[j]`是否存在。若存在还需要判断每个数字出现的次数是否合法（例如`nums = [-1,0,1,2,-1,-4]`，如果找到一个组合是`[2, -4, 2]`则需要舍弃。之所以会出现这样，是因为两层for会找到`2`和`-4`，而`0-nums[i]-nums[j]`会找到重复的2）\n\n找到组合之后，对组合再排序，判断`path`是否在`result`中。\n\n``` go\nfunc threeSum(nums []int) [][]int {\n\tsort.Ints(nums)\n\tmap1 := map[int]int{}\n\tfor _, v := range nums {\n\t\tmap1[v]++\n\t}\n\tvar result [][]int\n\tfor i := 0; i < len(nums); i++ {\n\t\tfor j := i + 1; j < len(nums); j++ {\n\t\t\tif v, ok := map1[-nums[i]-nums[j]]; ok {\n\t\t\t\ttemp := []int{nums[i], nums[j], -nums[i] - nums[j]}\n\t\t\t\tsort.Ints(temp)\n\t\t\t\tcount := 0\n\t\t\t\tif nums[i] == nums[j] || nums[j] == -nums[i]-nums[j] || nums[i] == -nums[i]-nums[j] {\n\t\t\t\t\tcount = 2\n\t\t\t\t}\n\t\t\t\tif nums[i] == nums[j] && nums[j] == -nums[i]-nums[j] {\n\t\t\t\t\tcount = 3\n\t\t\t\t}\n\t\t\t\tif v >= count {\n\t\t\t\t\tflag := true\n\t\t\t\t\tfor _, value := range result {\n\t\t\t\t\t\tif reflect.DeepEqual(value, temp) {\n\t\t\t\t\t\t\tflag = false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif flag {\n\t\t\t\t\t\tresult = append(result, temp)\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n```\n\n结果你猜超时没有，肯定还是超时了。\n\n好了，我投降了，想不到好方法了。去看卡哥视频了。\n\n\n\n### 卡哥解法\n\n<font color=\"red\">这道题不适合用哈希表做</font>。双指针我想了一下也没有太想明白，主要还是去重操作。看了视频讲解很清楚了\n\n1.   数组排序，方便后序操作\n2.   先找第一个数，使用一层`for`，指针为`i`\n3.   找第二个、第三个数。分别用指针`left = i + 1`，`right = len(nums) - 1`\n4.   剪枝：如果`i>0`，那么直接`return`，说明后续不可能再有等于0的三元组了\n5.   判断`nums[i] + nums[left] + nums[right]`和0的情况\n     -   `nums[i] + nums[left] + nums[right] > 0    right--`\n     -   `nums[i] + nums[left] + nums[right] < 0    left++`\n     -   `nums[i] + nums[left] + nums[right] == 0` \n         -   这个三元组放入到结果中，但是仍然要相向前进。对于`left`，如果如果一致前进得到的`nums[left]==nums[left+1]`，说明该三元组已经存在过了（`0, -1, -1, 1 ,1`）。`right`同理，`nums[right] == nums[right - 1]`\n         -   找到各自不同的数`nums[left+1]`和`nums[right-1]`，再前进一个（`0, -1, -1, -2, 2, 1, 1`）\n\n6.   `return result`\n\n\n\n### 代码\n\n``` go\nfunc threeSum(nums []int) [][]int {\n\tsort.Ints(nums)\n\tresult := [][]int{}\n\tfor i := 0; i < len(nums); i++ {\n\t\tif nums[i] > 0 {\n\t\t\treturn result\n\t\t}\n\t\tif i > 0 && nums[i] == nums[i-1] {\n\t\t\tcontinue\n\t\t}\n\t\tleft := i + 1\n\t\tright := len(nums) - 1\n\t\tfor left < right {\n\t\t\tif nums[i]+nums[left]+nums[right] > 0 {\n\t\t\t\tright--\n\t\t\t} else if nums[i]+nums[left]+nums[right] < 0 {\n\t\t\t\tleft++\n\t\t\t} else {\n\t\t\t\tresult = append(result, []int{nums[i], nums[left], nums[right]})\n\t\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\t\tleft++\n\t\t\t\t}\n\t\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\t\tright--\n\t\t\t\t}\n\t\t\t\tleft++\n\t\t\t\tright--\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n```\n\n虽然这个代码AC了，但是毫无成就感。现在是9月27日凌晨2:53，还有一道题。继续\n\n\n\n## 18. 四数之和\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/4sum/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html)\n>\n>   视频讲解：[难在去重和剪枝！| LeetCode：18. 四数之和](https://www.bilibili.com/video/BV1DS4y147US)\n>\n>   状态：AC\n\n### 算法\n\n算法同上题，只不过这次要先确定两个数，然后用`left`和`right`指针找第三个第四个数。有几点不同：\n\n-   这里不是与0作比较，而是`target`，不可以`nums[i] > target`之后就`break`，因为如果有一堆负数相加一定出现越加越小，使得等于`target`\n-   数组长度可能小于4，需要额外判断\n-   剪枝`i>0`开始，`j>i+1`开始，`j`永远在`i`后一位\n\n领悟了上一道题，这一题不难了\n\n### 代码\n\n``` go\nfunc fourSum(nums []int, target int) [][]int {\n\tvar result [][]int\n\tif len(nums) < 4 {\n\t\treturn result\n\t}\n\tsort.Ints(nums)\n\tfor i := 0; i < len(nums)-3; i++ {\n\t\tif i > 0 && nums[i] == nums[i-1] {\n\t\t\tcontinue\n\t\t}\n\t\tfor j := i + 1; j < len(nums)-2; j++ {\n\t\t\tif j > i+1 && nums[j] == nums[j-1] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tleft := j + 1\n\t\t\tright := len(nums) - 1\n\t\t\tfor left < right {\n\t\t\t\tif nums[i]+nums[j]+nums[left]+nums[right] < target {\n\t\t\t\t\tleft++\n\t\t\t\t} else if nums[i]+nums[j]+nums[left]+nums[right] > target {\n\t\t\t\t\tright--\n\t\t\t\t} else {\n\t\t\t\t\tresult = append(result, []int{nums[i], nums[j], nums[left], nums[right]})\n\t\t\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\t\t\tleft++\n\t\t\t\t\t}\n\t\t\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\t\t\tright--\n\t\t\t\t\t}\n\t\t\t\t\tleft++\n\t\t\t\t\tright--\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n```\n\n## 小结\n\n-   Go的底层有了很多认识，是以前做题或者写项目时候意识不到的。尤其是浅拷贝与深拷贝，大概找到规律了，几乎都是浅拷贝，如果想要深拷贝一定要用`copy()`\n-   由于Go的特性，Go的全局变量不可以在leetcode使用，需要指针传值\n-   晚安，准备睡觉了，3:20了，一觉起来是新的题，字符串要学KMP算法什么的了。\n","source":"_posts/day07.md","raw":"---\ntitle: 代码随想录算法训练营第七天| 454.四数相加II、383. 赎金信、15. 三数之和、18. 四数之和。\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: bc862a56\ndate: 2023-09-26 11:31:08\n---\n\n# 代码随想录算法训练营第七天| 454.四数相加II、383. 赎金信、15. 三数之和、18. 四数之和。\n\n## 454. 两数相加\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/4sum-ii/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)\n>\n>   视频讲解：[学透哈希表，map使用有技巧！LeetCode：454.四数相加II](https://www.bilibili.com/video/BV1Md4y1Q7Yh)\n>\n>   状态：TLE\n\n### 思路\n\n#### 思路一：暴力算法\n\n暴力算法就不用解释了，每个元素都遍历下。定义`count`记录满足条件情况的个数。满足条件`count++`就好。不出意外的也肯定会超时。\n\n#### 思路二：使用map\n\n将`num4`的值存入到`map4`中的`key`，值出现的次数存为`value`。三层循环后接一个判断，判断第四个数是否在`map4`中，如果存在则总数加`value`\n\n```go\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {\n\tcount := 0\n\tmap4 := map[int]int{}\n\tfor _, v := range nums4 {\n\t\tmap4[v]++\n\t}\n\tfor _, i := range nums1 {\n\t\tfor _, j := range nums2 {\n\t\t\tfor _, k := range nums3 {\n\t\t\t\tif v, ok := map4[0-i-j-k]; ok {\n\t\t\t\t\tcount += v\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n```\n\n结果你猜超时没有，肯定还是超时了。\n\n#### 思路三：使用四个map\n\n每个map中都存放`nums`中出现的数以及出现的次数。第一个map定义为`map1`，键是`k1`，值是`v1`，以此类推。\n\n三层循环后判断`map4[0-k1-k2-k3]`是否存在，如果存在那么`count += v1 * v2 * v3 * v4`\n\n``` go\ncount := 0\nmap1 := map[int]int{}\nmap2 := map[int]int{}\nmap3 := map[int]int{}\nmap4 := map[int]int{}\nfor i := 0; i < len(nums1); i++ {\n    map1[nums1[i]]++\n    map2[nums2[i]]++\n    map3[nums3[i]]++\n    map4[nums4[i]]++\n}\nfor k1, v1 := range map1 {\n    for k2, v2 := range map2 {\n        for k3, v3 := range map3 {\n            if v4, ok := map4[0-k1-k2-k3]; ok {\n                count += v1 * v2 * v3 * v4\n            }\n        }\n    }\n}\nreturn count\n```\n\n结果你猜超时没有，肯定还是超时了。\n\n原因如下：如果数组中重复的数不多，或者没有，就会退化成思路二。\n\n想了许久，想不出优化的方法了，看了卡哥的题解，我就用我的理解描述一下。\n\n#### 卡哥题解\n\n先计算`nums1`与`nums2`和，将两数组所有和的情况保存到`mapAB`中。key保存的是和，value保存的是和的个数。\n\n再计算`nums3`与`nums4`和，判断`mapAB[0-k3-k4]`是否存在，若存在`count+=mapAB[0-k3-k4]`\n\n``` go\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {\n\tcount := 0\n\tmapAB := map[int]int{}\n\tfor _, v1 := range nums1 {\n\t\tfor _, v2 := range nums2 {\n\t\t\tmapAB[v1+v2]++\n\t\t}\n\t}\n\tfor _, v3 := range nums3 {\n\t\tfor _, v4 := range nums4 {\n\t\t\tif v, ok := mapAB[0-v3-v4]; ok {\n\t\t\t\tcount += v\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n```\n\n## 383. 赎金信\n\n### 思路\n\n要判断`ransomNote`是否含于`magazine`，先构建一个数组，存放`magazine`的情况，索引代表字母：0代表`'a'`，1代表`'b'`等等；值代表字母出现的次数。构建好后再遍历`ransomNote`串，将对应的字母数量减少一，如果不存在直接`return false`\n\n### 代码\n\n``` go\nfunc canConstruct(ransomNote string, magazine string) bool {\n\tif len(ransomNote) > len(magazine) {\n\t\treturn false\n\t}\n\tarr := make([]int, 26)\n\tfor _, v := range magazine {\n\t\tarr[v-'a']++\n\t}\n\tfor _, v := range ransomNote {\n\t\tarr[v-'a']--\n\t\tif arr[v-'a'] < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```\n\n\n\n## 15. 三数之和\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/3sum/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)\n>\n>   视频讲解：[梦破碎的地方！| LeetCode：15.三数之和](https://www.bilibili.com/video/BV1GW4y127qo)\n>\n>   状态：TLE\n\n### 思路\n\n我投降了这道题，Go的底层现在有一个新的理解！\n\n#### 方法一：回溯算法\n\n首先先将`nums`排序，利用回溯算法得到所有的组合，选择排序的原因是因为这样得到的组合，即使是重复的也可以保证顺序一致，方便判断这个组合是否出现过。最终结果保存到变量`result`，得到的可能得组合保存到变量`path`\n\n#### 代码\n\n``` go\nfunc backTracking(nums []int, index int, result *[][]int, path *[]int) {\n\tif len(*path) == 3 {\n\t\tif (*path)[0]+(*path)[1]+(*path)[2] == 0 {\n\t\t\t// 后面的append()操作是深拷贝，所以这里使用temp保存path的值\n            temp := make([]int, len(*path))  \n\t\t\tcopy(temp, *path)\n\t\t\tfor _, v := range *result {\n\t\t\t\tif reflect.DeepEqual(temp, v) {  // 使用反射判断temp是否在result中\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\t*result = append(*result, temp)\n\t\t}\n\t\treturn\n\t}\n\tfor i := index; i < len(nums); i++ {\n\t\t*path = append(*path, nums[i])\n\t\tbackTracking(nums, i+1, result, path)\n\t\t*path = (*path)[:len(*path)-1]\n\n\t}\n}\n\nfunc threeSum(nums []int) [][]int {\n\tvar result [][]int\n\tvar path []int\n\tsort.Ints(nums)\n\tbackTracking(nums, 0, &result, &path)\n\treturn result\n}\n```\n\n结果你猜超时没有，肯定还是超时了。\n\n这里我遇到了好多问题，首先是发现了`result = append(result, temp)`，这里`append`方法实际上是浅拷贝！也就是说以后`temp`的值，`result`也会变化。这也是我为什么用一个临时变量`temp`来保存`path`，而且使用的是`copy()`。\n\n要判断`temp`是否存在于`result`中，那么则需要使用反射，进行深度判断`reflect.DeepEqual(temp, v)`。\n\n##### 遇到最头大的问题！！！！！！\n\n以前用别的语言写回溯，很自然的使用了全局变量，结果在Go语言中发生了奇妙的事情。请看截图\n\n<img src=\"../images/day07/使用全局变量leetcode.png\" alt=\"使用全局变量leetcode\" style=\"zoom:80%;\" />\n\n明明输入的只有0和1，怎么会输出了2。而且这个测试用例这么眼熟呢，没错这就是给出的测试用例Case1的答案。放到Goland里面明明是正确答案！到这里就变了，说明全局变量出现了问题。解决这个问题有两个想法：\n\n-   查找有没有类似C++中的`delete`，使用完变量之后释放掉。发现并没有。而且使用完变量应该在`threeSum()`之外了，函数内释放就没有结果了。\n-   `threeSum()`定义变量，使用指针传值。\n\n当然，第二种才是正解。改完之后就是上面放出来的代码了，超时。\n\n#### 方法二：使用哈希\n\n将`nums`进行排序，并哈希处理，定义变量`map1`用作哈希表，`nums`中的每个元素做key，value则是每个元素出现的次数。\n\n使用两层for循环之后，判断`0-nums[i]-nums[j]`是否存在。若存在还需要判断每个数字出现的次数是否合法（例如`nums = [-1,0,1,2,-1,-4]`，如果找到一个组合是`[2, -4, 2]`则需要舍弃。之所以会出现这样，是因为两层for会找到`2`和`-4`，而`0-nums[i]-nums[j]`会找到重复的2）\n\n找到组合之后，对组合再排序，判断`path`是否在`result`中。\n\n``` go\nfunc threeSum(nums []int) [][]int {\n\tsort.Ints(nums)\n\tmap1 := map[int]int{}\n\tfor _, v := range nums {\n\t\tmap1[v]++\n\t}\n\tvar result [][]int\n\tfor i := 0; i < len(nums); i++ {\n\t\tfor j := i + 1; j < len(nums); j++ {\n\t\t\tif v, ok := map1[-nums[i]-nums[j]]; ok {\n\t\t\t\ttemp := []int{nums[i], nums[j], -nums[i] - nums[j]}\n\t\t\t\tsort.Ints(temp)\n\t\t\t\tcount := 0\n\t\t\t\tif nums[i] == nums[j] || nums[j] == -nums[i]-nums[j] || nums[i] == -nums[i]-nums[j] {\n\t\t\t\t\tcount = 2\n\t\t\t\t}\n\t\t\t\tif nums[i] == nums[j] && nums[j] == -nums[i]-nums[j] {\n\t\t\t\t\tcount = 3\n\t\t\t\t}\n\t\t\t\tif v >= count {\n\t\t\t\t\tflag := true\n\t\t\t\t\tfor _, value := range result {\n\t\t\t\t\t\tif reflect.DeepEqual(value, temp) {\n\t\t\t\t\t\t\tflag = false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif flag {\n\t\t\t\t\t\tresult = append(result, temp)\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n```\n\n结果你猜超时没有，肯定还是超时了。\n\n好了，我投降了，想不到好方法了。去看卡哥视频了。\n\n\n\n### 卡哥解法\n\n<font color=\"red\">这道题不适合用哈希表做</font>。双指针我想了一下也没有太想明白，主要还是去重操作。看了视频讲解很清楚了\n\n1.   数组排序，方便后序操作\n2.   先找第一个数，使用一层`for`，指针为`i`\n3.   找第二个、第三个数。分别用指针`left = i + 1`，`right = len(nums) - 1`\n4.   剪枝：如果`i>0`，那么直接`return`，说明后续不可能再有等于0的三元组了\n5.   判断`nums[i] + nums[left] + nums[right]`和0的情况\n     -   `nums[i] + nums[left] + nums[right] > 0    right--`\n     -   `nums[i] + nums[left] + nums[right] < 0    left++`\n     -   `nums[i] + nums[left] + nums[right] == 0` \n         -   这个三元组放入到结果中，但是仍然要相向前进。对于`left`，如果如果一致前进得到的`nums[left]==nums[left+1]`，说明该三元组已经存在过了（`0, -1, -1, 1 ,1`）。`right`同理，`nums[right] == nums[right - 1]`\n         -   找到各自不同的数`nums[left+1]`和`nums[right-1]`，再前进一个（`0, -1, -1, -2, 2, 1, 1`）\n\n6.   `return result`\n\n\n\n### 代码\n\n``` go\nfunc threeSum(nums []int) [][]int {\n\tsort.Ints(nums)\n\tresult := [][]int{}\n\tfor i := 0; i < len(nums); i++ {\n\t\tif nums[i] > 0 {\n\t\t\treturn result\n\t\t}\n\t\tif i > 0 && nums[i] == nums[i-1] {\n\t\t\tcontinue\n\t\t}\n\t\tleft := i + 1\n\t\tright := len(nums) - 1\n\t\tfor left < right {\n\t\t\tif nums[i]+nums[left]+nums[right] > 0 {\n\t\t\t\tright--\n\t\t\t} else if nums[i]+nums[left]+nums[right] < 0 {\n\t\t\t\tleft++\n\t\t\t} else {\n\t\t\t\tresult = append(result, []int{nums[i], nums[left], nums[right]})\n\t\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\t\tleft++\n\t\t\t\t}\n\t\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\t\tright--\n\t\t\t\t}\n\t\t\t\tleft++\n\t\t\t\tright--\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n```\n\n虽然这个代码AC了，但是毫无成就感。现在是9月27日凌晨2:53，还有一道题。继续\n\n\n\n## 18. 四数之和\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/4sum/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html)\n>\n>   视频讲解：[难在去重和剪枝！| LeetCode：18. 四数之和](https://www.bilibili.com/video/BV1DS4y147US)\n>\n>   状态：AC\n\n### 算法\n\n算法同上题，只不过这次要先确定两个数，然后用`left`和`right`指针找第三个第四个数。有几点不同：\n\n-   这里不是与0作比较，而是`target`，不可以`nums[i] > target`之后就`break`，因为如果有一堆负数相加一定出现越加越小，使得等于`target`\n-   数组长度可能小于4，需要额外判断\n-   剪枝`i>0`开始，`j>i+1`开始，`j`永远在`i`后一位\n\n领悟了上一道题，这一题不难了\n\n### 代码\n\n``` go\nfunc fourSum(nums []int, target int) [][]int {\n\tvar result [][]int\n\tif len(nums) < 4 {\n\t\treturn result\n\t}\n\tsort.Ints(nums)\n\tfor i := 0; i < len(nums)-3; i++ {\n\t\tif i > 0 && nums[i] == nums[i-1] {\n\t\t\tcontinue\n\t\t}\n\t\tfor j := i + 1; j < len(nums)-2; j++ {\n\t\t\tif j > i+1 && nums[j] == nums[j-1] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tleft := j + 1\n\t\t\tright := len(nums) - 1\n\t\t\tfor left < right {\n\t\t\t\tif nums[i]+nums[j]+nums[left]+nums[right] < target {\n\t\t\t\t\tleft++\n\t\t\t\t} else if nums[i]+nums[j]+nums[left]+nums[right] > target {\n\t\t\t\t\tright--\n\t\t\t\t} else {\n\t\t\t\t\tresult = append(result, []int{nums[i], nums[j], nums[left], nums[right]})\n\t\t\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\t\t\tleft++\n\t\t\t\t\t}\n\t\t\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\t\t\tright--\n\t\t\t\t\t}\n\t\t\t\t\tleft++\n\t\t\t\t\tright--\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n```\n\n## 小结\n\n-   Go的底层有了很多认识，是以前做题或者写项目时候意识不到的。尤其是浅拷贝与深拷贝，大概找到规律了，几乎都是浅拷贝，如果想要深拷贝一定要用`copy()`\n-   由于Go的特性，Go的全局变量不可以在leetcode使用，需要指针传值\n-   晚安，准备睡觉了，3:20了，一觉起来是新的题，字符串要学KMP算法什么的了。\n","slug":"day07","published":1,"updated":"2023-10-04T11:44:13.085Z","_id":"cln7q7alw000hvswha1iihvvl","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第七天-454-四数相加II、383-赎金信、15-三数之和、18-四数之和。\"><a href=\"#代码随想录算法训练营第七天-454-四数相加II、383-赎金信、15-三数之和、18-四数之和。\" class=\"headerlink\" title=\"代码随想录算法训练营第七天| 454.四数相加II、383. 赎金信、15. 三数之和、18. 四数之和。\"></a>代码随想录算法训练营第七天| 454.四数相加II、383. 赎金信、15. 三数之和、18. 四数之和。</h1><h2 id=\"454-两数相加\"><a href=\"#454-两数相加\" class=\"headerlink\" title=\"454. 两数相加\"></a>454. 两数相加</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/4sum-ii/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1Md4y1Q7Yh\">学透哈希表，map使用有技巧！LeetCode：454.四数相加II</a></p>\n<p>  状态：TLE</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"思路一：暴力算法\"><a href=\"#思路一：暴力算法\" class=\"headerlink\" title=\"思路一：暴力算法\"></a>思路一：暴力算法</h4><p>暴力算法就不用解释了，每个元素都遍历下。定义<code>count</code>记录满足条件情况的个数。满足条件<code>count++</code>就好。不出意外的也肯定会超时。</p>\n<h4 id=\"思路二：使用map\"><a href=\"#思路二：使用map\" class=\"headerlink\" title=\"思路二：使用map\"></a>思路二：使用map</h4><p>将<code>num4</code>的值存入到<code>map4</code>中的<code>key</code>，值出现的次数存为<code>value</code>。三层循环后接一个判断，判断第四个数是否在<code>map4</code>中，如果存在则总数加<code>value</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fourSumCount</span><span class=\"hljs-params\">(nums1 []<span class=\"hljs-type\">int</span>, nums2 []<span class=\"hljs-type\">int</span>, nums3 []<span class=\"hljs-type\">int</span>, nums4 []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tcount := <span class=\"hljs-number\">0</span><br>\tmap4 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> nums4 &#123;<br>\t\tmap4[v]++<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, i := <span class=\"hljs-keyword\">range</span> nums1 &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> _, j := <span class=\"hljs-keyword\">range</span> nums2 &#123;<br>\t\t\t<span class=\"hljs-keyword\">for</span> _, k := <span class=\"hljs-keyword\">range</span> nums3 &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> v, ok := map4[<span class=\"hljs-number\">0</span>-i-j-k]; ok &#123;<br>\t\t\t\t\tcount += v<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>结果你猜超时没有，肯定还是超时了。</p>\n<h4 id=\"思路三：使用四个map\"><a href=\"#思路三：使用四个map\" class=\"headerlink\" title=\"思路三：使用四个map\"></a>思路三：使用四个map</h4><p>每个map中都存放<code>nums</code>中出现的数以及出现的次数。第一个map定义为<code>map1</code>，键是<code>k1</code>，值是<code>v1</code>，以此类推。</p>\n<p>三层循环后判断<code>map4[0-k1-k2-k3]</code>是否存在，如果存在那么<code>count += v1 * v2 * v3 * v4</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">count := <span class=\"hljs-number\">0</span><br>map1 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>map2 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>map3 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>map4 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br><span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums1); i++ &#123;<br>    map1[nums1[i]]++<br>    map2[nums2[i]]++<br>    map3[nums3[i]]++<br>    map4[nums4[i]]++<br>&#125;<br><span class=\"hljs-keyword\">for</span> k1, v1 := <span class=\"hljs-keyword\">range</span> map1 &#123;<br>    <span class=\"hljs-keyword\">for</span> k2, v2 := <span class=\"hljs-keyword\">range</span> map2 &#123;<br>        <span class=\"hljs-keyword\">for</span> k3, v3 := <span class=\"hljs-keyword\">range</span> map3 &#123;<br>            <span class=\"hljs-keyword\">if</span> v4, ok := map4[<span class=\"hljs-number\">0</span>-k1-k2-k3]; ok &#123;<br>                count += v1 * v2 * v3 * v4<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">return</span> count<br></code></pre></td></tr></table></figure>\n\n<p>结果你猜超时没有，肯定还是超时了。</p>\n<p>原因如下：如果数组中重复的数不多，或者没有，就会退化成思路二。</p>\n<p>想了许久，想不出优化的方法了，看了卡哥的题解，我就用我的理解描述一下。</p>\n<h4 id=\"卡哥题解\"><a href=\"#卡哥题解\" class=\"headerlink\" title=\"卡哥题解\"></a>卡哥题解</h4><p>先计算<code>nums1</code>与<code>nums2</code>和，将两数组所有和的情况保存到<code>mapAB</code>中。key保存的是和，value保存的是和的个数。</p>\n<p>再计算<code>nums3</code>与<code>nums4</code>和，判断<code>mapAB[0-k3-k4]</code>是否存在，若存在<code>count+=mapAB[0-k3-k4]</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fourSumCount</span><span class=\"hljs-params\">(nums1 []<span class=\"hljs-type\">int</span>, nums2 []<span class=\"hljs-type\">int</span>, nums3 []<span class=\"hljs-type\">int</span>, nums4 []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tcount := <span class=\"hljs-number\">0</span><br>\tmapAB := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v1 := <span class=\"hljs-keyword\">range</span> nums1 &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> _, v2 := <span class=\"hljs-keyword\">range</span> nums2 &#123;<br>\t\t\tmapAB[v1+v2]++<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v3 := <span class=\"hljs-keyword\">range</span> nums3 &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> _, v4 := <span class=\"hljs-keyword\">range</span> nums4 &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> v, ok := mapAB[<span class=\"hljs-number\">0</span>-v3-v4]; ok &#123;<br>\t\t\t\tcount += v<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"383-赎金信\"><a href=\"#383-赎金信\" class=\"headerlink\" title=\"383. 赎金信\"></a>383. 赎金信</h2><h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>要判断<code>ransomNote</code>是否含于<code>magazine</code>，先构建一个数组，存放<code>magazine</code>的情况，索引代表字母：0代表<code>&#39;a&#39;</code>，1代表<code>&#39;b&#39;</code>等等；值代表字母出现的次数。构建好后再遍历<code>ransomNote</code>串，将对应的字母数量减少一，如果不存在直接<code>return false</code></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">canConstruct</span><span class=\"hljs-params\">(ransomNote <span class=\"hljs-type\">string</span>, magazine <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(ransomNote) &gt; <span class=\"hljs-built_in\">len</span>(magazine) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>\tarr := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">26</span>)<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> magazine &#123;<br>\t\tarr[v-<span class=\"hljs-string\">&#x27;a&#x27;</span>]++<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> ransomNote &#123;<br>\t\tarr[v-<span class=\"hljs-string\">&#x27;a&#x27;</span>]--<br>\t\t<span class=\"hljs-keyword\">if</span> arr[v-<span class=\"hljs-string\">&#x27;a&#x27;</span>] &lt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15. 三数之和\"></a>15. 三数之和</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/3sum/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1GW4y127qo\">梦破碎的地方！| LeetCode：15.三数之和</a></p>\n<p>  状态：TLE</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>我投降了这道题，Go的底层现在有一个新的理解！</p>\n<h4 id=\"方法一：回溯算法\"><a href=\"#方法一：回溯算法\" class=\"headerlink\" title=\"方法一：回溯算法\"></a>方法一：回溯算法</h4><p>首先先将<code>nums</code>排序，利用回溯算法得到所有的组合，选择排序的原因是因为这样得到的组合，即使是重复的也可以保证顺序一致，方便判断这个组合是否出现过。最终结果保存到变量<code>result</code>，得到的可能得组合保存到变量<code>path</code></p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">backTracking</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, index <span class=\"hljs-type\">int</span>, result *[][]<span class=\"hljs-type\">int</span>, path *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(*path) == <span class=\"hljs-number\">3</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (*path)[<span class=\"hljs-number\">0</span>]+(*path)[<span class=\"hljs-number\">1</span>]+(*path)[<span class=\"hljs-number\">2</span>] == <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t<span class=\"hljs-comment\">// 后面的append()操作是深拷贝，所以这里使用temp保存path的值</span><br>            temp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(*path))  <br>\t\t\t<span class=\"hljs-built_in\">copy</span>(temp, *path)<br>\t\t\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> *result &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> reflect.DeepEqual(temp, v) &#123;  <span class=\"hljs-comment\">// 使用反射判断temp是否在result中</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">return</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t\t*result = <span class=\"hljs-built_in\">append</span>(*result, temp)<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := index; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, nums[i])<br>\t\tbackTracking(nums, i+<span class=\"hljs-number\">1</span>, result, path)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br><br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">threeSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">var</span> path []<span class=\"hljs-type\">int</span><br>\tsort.Ints(nums)<br>\tbackTracking(nums, <span class=\"hljs-number\">0</span>, &amp;result, &amp;path)<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>结果你猜超时没有，肯定还是超时了。</p>\n<p>这里我遇到了好多问题，首先是发现了<code>result = append(result, temp)</code>，这里<code>append</code>方法实际上是浅拷贝！也就是说以后<code>temp</code>的值，<code>result</code>也会变化。这也是我为什么用一个临时变量<code>temp</code>来保存<code>path</code>，而且使用的是<code>copy()</code>。</p>\n<p>要判断<code>temp</code>是否存在于<code>result</code>中，那么则需要使用反射，进行深度判断<code>reflect.DeepEqual(temp, v)</code>。</p>\n<h5 id=\"遇到最头大的问题！！！！！！\"><a href=\"#遇到最头大的问题！！！！！！\" class=\"headerlink\" title=\"遇到最头大的问题！！！！！！\"></a>遇到最头大的问题！！！！！！</h5><p>以前用别的语言写回溯，很自然的使用了全局变量，结果在Go语言中发生了奇妙的事情。请看截图</p>\n<img src=\"../images/day07/使用全局变量leetcode.png\" alt=\"使用全局变量leetcode\" style=\"zoom:80%;\" />\n\n<p>明明输入的只有0和1，怎么会输出了2。而且这个测试用例这么眼熟呢，没错这就是给出的测试用例Case1的答案。放到Goland里面明明是正确答案！到这里就变了，说明全局变量出现了问题。解决这个问题有两个想法：</p>\n<ul>\n<li>查找有没有类似C++中的<code>delete</code>，使用完变量之后释放掉。发现并没有。而且使用完变量应该在<code>threeSum()</code>之外了，函数内释放就没有结果了。</li>\n<li><code>threeSum()</code>定义变量，使用指针传值。</li>\n</ul>\n<p>当然，第二种才是正解。改完之后就是上面放出来的代码了，超时。</p>\n<h4 id=\"方法二：使用哈希\"><a href=\"#方法二：使用哈希\" class=\"headerlink\" title=\"方法二：使用哈希\"></a>方法二：使用哈希</h4><p>将<code>nums</code>进行排序，并哈希处理，定义变量<code>map1</code>用作哈希表，<code>nums</code>中的每个元素做key，value则是每个元素出现的次数。</p>\n<p>使用两层for循环之后，判断<code>0-nums[i]-nums[j]</code>是否存在。若存在还需要判断每个数字出现的次数是否合法（例如<code>nums = [-1,0,1,2,-1,-4]</code>，如果找到一个组合是<code>[2, -4, 2]</code>则需要舍弃。之所以会出现这样，是因为两层for会找到<code>2</code>和<code>-4</code>，而<code>0-nums[i]-nums[j]</code>会找到重复的2）</p>\n<p>找到组合之后，对组合再排序，判断<code>path</code>是否在<code>result</code>中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">threeSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\tsort.Ints(nums)<br>\tmap1 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>\t\tmap1[v]++<br>\t&#125;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> j := i + <span class=\"hljs-number\">1</span>; j &lt; <span class=\"hljs-built_in\">len</span>(nums); j++ &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> v, ok := map1[-nums[i]-nums[j]]; ok &#123;<br>\t\t\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;nums[i], nums[j], -nums[i] - nums[j]&#125;<br>\t\t\t\tsort.Ints(temp)<br>\t\t\t\tcount := <span class=\"hljs-number\">0</span><br>\t\t\t\t<span class=\"hljs-keyword\">if</span> nums[i] == nums[j] || nums[j] == -nums[i]-nums[j] || nums[i] == -nums[i]-nums[j] &#123;<br>\t\t\t\t\tcount = <span class=\"hljs-number\">2</span><br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> nums[i] == nums[j] &amp;&amp; nums[j] == -nums[i]-nums[j] &#123;<br>\t\t\t\t\tcount = <span class=\"hljs-number\">3</span><br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> v &gt;= count &#123;<br>\t\t\t\t\tflag := <span class=\"hljs-literal\">true</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">for</span> _, value := <span class=\"hljs-keyword\">range</span> result &#123;<br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> reflect.DeepEqual(value, temp) &#123;<br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">false</span><br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> flag &#123;<br>\t\t\t\t\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t\t\t\t\t&#125;<br><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>结果你猜超时没有，肯定还是超时了。</p>\n<p>好了，我投降了，想不到好方法了。去看卡哥视频了。</p>\n<h3 id=\"卡哥解法\"><a href=\"#卡哥解法\" class=\"headerlink\" title=\"卡哥解法\"></a>卡哥解法</h3><p><font color=\"red\">这道题不适合用哈希表做</font>。双指针我想了一下也没有太想明白，主要还是去重操作。看了视频讲解很清楚了</p>\n<ol>\n<li><p>数组排序，方便后序操作</p>\n</li>\n<li><p>先找第一个数，使用一层<code>for</code>，指针为<code>i</code></p>\n</li>\n<li><p>找第二个、第三个数。分别用指针<code>left = i + 1</code>，<code>right = len(nums) - 1</code></p>\n</li>\n<li><p>剪枝：如果<code>i&gt;0</code>，那么直接<code>return</code>，说明后续不可能再有等于0的三元组了</p>\n</li>\n<li><p>判断<code>nums[i] + nums[left] + nums[right]</code>和0的情况</p>\n<ul>\n<li><code>nums[i] + nums[left] + nums[right] &gt; 0    right--</code></li>\n<li><code>nums[i] + nums[left] + nums[right] &lt; 0    left++</code></li>\n<li><code>nums[i] + nums[left] + nums[right] == 0</code> <ul>\n<li>这个三元组放入到结果中，但是仍然要相向前进。对于<code>left</code>，如果如果一致前进得到的<code>nums[left]==nums[left+1]</code>，说明该三元组已经存在过了（<code>0, -1, -1, 1 ,1</code>）。<code>right</code>同理，<code>nums[right] == nums[right - 1]</code></li>\n<li>找到各自不同的数<code>nums[left+1]</code>和<code>nums[right-1]</code>，再前进一个（<code>0, -1, -1, -2, 2, 1, 1</code>）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>return result</code></p>\n</li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">threeSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\tsort.Ints(nums)<br>\tresult := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> nums[i] &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> result<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> i &gt; <span class=\"hljs-number\">0</span> &amp;&amp; nums[i] == nums[i<span class=\"hljs-number\">-1</span>] &#123;<br>\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t&#125;<br>\t\tleft := i + <span class=\"hljs-number\">1</span><br>\t\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t\t<span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> nums[i]+nums[left]+nums[right] &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t\tright--<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[i]+nums[left]+nums[right] &lt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t\tleft++<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tresult = <span class=\"hljs-built_in\">append</span>(result, []<span class=\"hljs-type\">int</span>&#123;nums[i], nums[left], nums[right]&#125;)<br>\t\t\t\t<span class=\"hljs-keyword\">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class=\"hljs-number\">1</span>] &#123;<br>\t\t\t\t\tleft++<br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class=\"hljs-number\">-1</span>] &#123;<br>\t\t\t\t\tright--<br>\t\t\t\t&#125;<br>\t\t\t\tleft++<br>\t\t\t\tright--<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>虽然这个代码AC了，但是毫无成就感。现在是9月27日凌晨2:53，还有一道题。继续</p>\n<h2 id=\"18-四数之和\"><a href=\"#18-四数之和\" class=\"headerlink\" title=\"18. 四数之和\"></a>18. 四数之和</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/4sum/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1DS4y147US\">难在去重和剪枝！| LeetCode：18. 四数之和</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>算法同上题，只不过这次要先确定两个数，然后用<code>left</code>和<code>right</code>指针找第三个第四个数。有几点不同：</p>\n<ul>\n<li>这里不是与0作比较，而是<code>target</code>，不可以<code>nums[i] &gt; target</code>之后就<code>break</code>，因为如果有一堆负数相加一定出现越加越小，使得等于<code>target</code></li>\n<li>数组长度可能小于4，需要额外判断</li>\n<li>剪枝<code>i&gt;0</code>开始，<code>j&gt;i+1</code>开始，<code>j</code>永远在<code>i</code>后一位</li>\n</ul>\n<p>领悟了上一道题，这一题不难了</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fourSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(nums) &lt; <span class=\"hljs-number\">4</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tsort.Ints(nums)<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums)<span class=\"hljs-number\">-3</span>; i++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> i &gt; <span class=\"hljs-number\">0</span> &amp;&amp; nums[i] == nums[i<span class=\"hljs-number\">-1</span>] &#123;<br>\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> j := i + <span class=\"hljs-number\">1</span>; j &lt; <span class=\"hljs-built_in\">len</span>(nums)<span class=\"hljs-number\">-2</span>; j++ &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> j &gt; i+<span class=\"hljs-number\">1</span> &amp;&amp; nums[j] == nums[j<span class=\"hljs-number\">-1</span>] &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t\t&#125;<br>\t\t\tleft := j + <span class=\"hljs-number\">1</span><br>\t\t\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t\t\t<span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> nums[i]+nums[j]+nums[left]+nums[right] &lt; target &#123;<br>\t\t\t\t\tleft++<br>\t\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[i]+nums[j]+nums[left]+nums[right] &gt; target &#123;<br>\t\t\t\t\tright--<br>\t\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t\tresult = <span class=\"hljs-built_in\">append</span>(result, []<span class=\"hljs-type\">int</span>&#123;nums[i], nums[j], nums[left], nums[right]&#125;)<br>\t\t\t\t\t<span class=\"hljs-keyword\">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class=\"hljs-number\">1</span>] &#123;<br>\t\t\t\t\t\tleft++<br>\t\t\t\t\t&#125;<br>\t\t\t\t\t<span class=\"hljs-keyword\">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class=\"hljs-number\">-1</span>] &#123;<br>\t\t\t\t\t\tright--<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tleft++<br>\t\t\t\t\tright--<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>Go的底层有了很多认识，是以前做题或者写项目时候意识不到的。尤其是浅拷贝与深拷贝，大概找到规律了，几乎都是浅拷贝，如果想要深拷贝一定要用<code>copy()</code></li>\n<li>由于Go的特性，Go的全局变量不可以在leetcode使用，需要指针传值</li>\n<li>晚安，准备睡觉了，3:20了，一觉起来是新的题，字符串要学KMP算法什么的了。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第七天-454-四数相加II、383-赎金信、15-三数之和、18-四数之和。\"><a href=\"#代码随想录算法训练营第七天-454-四数相加II、383-赎金信、15-三数之和、18-四数之和。\" class=\"headerlink\" title=\"代码随想录算法训练营第七天| 454.四数相加II、383. 赎金信、15. 三数之和、18. 四数之和。\"></a>代码随想录算法训练营第七天| 454.四数相加II、383. 赎金信、15. 三数之和、18. 四数之和。</h1><h2 id=\"454-两数相加\"><a href=\"#454-两数相加\" class=\"headerlink\" title=\"454. 两数相加\"></a>454. 两数相加</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/4sum-ii/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1Md4y1Q7Yh\">学透哈希表，map使用有技巧！LeetCode：454.四数相加II</a></p>\n<p>  状态：TLE</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"思路一：暴力算法\"><a href=\"#思路一：暴力算法\" class=\"headerlink\" title=\"思路一：暴力算法\"></a>思路一：暴力算法</h4><p>暴力算法就不用解释了，每个元素都遍历下。定义<code>count</code>记录满足条件情况的个数。满足条件<code>count++</code>就好。不出意外的也肯定会超时。</p>\n<h4 id=\"思路二：使用map\"><a href=\"#思路二：使用map\" class=\"headerlink\" title=\"思路二：使用map\"></a>思路二：使用map</h4><p>将<code>num4</code>的值存入到<code>map4</code>中的<code>key</code>，值出现的次数存为<code>value</code>。三层循环后接一个判断，判断第四个数是否在<code>map4</code>中，如果存在则总数加<code>value</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fourSumCount</span><span class=\"hljs-params\">(nums1 []<span class=\"hljs-type\">int</span>, nums2 []<span class=\"hljs-type\">int</span>, nums3 []<span class=\"hljs-type\">int</span>, nums4 []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tcount := <span class=\"hljs-number\">0</span><br>\tmap4 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> nums4 &#123;<br>\t\tmap4[v]++<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, i := <span class=\"hljs-keyword\">range</span> nums1 &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> _, j := <span class=\"hljs-keyword\">range</span> nums2 &#123;<br>\t\t\t<span class=\"hljs-keyword\">for</span> _, k := <span class=\"hljs-keyword\">range</span> nums3 &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> v, ok := map4[<span class=\"hljs-number\">0</span>-i-j-k]; ok &#123;<br>\t\t\t\t\tcount += v<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>结果你猜超时没有，肯定还是超时了。</p>\n<h4 id=\"思路三：使用四个map\"><a href=\"#思路三：使用四个map\" class=\"headerlink\" title=\"思路三：使用四个map\"></a>思路三：使用四个map</h4><p>每个map中都存放<code>nums</code>中出现的数以及出现的次数。第一个map定义为<code>map1</code>，键是<code>k1</code>，值是<code>v1</code>，以此类推。</p>\n<p>三层循环后判断<code>map4[0-k1-k2-k3]</code>是否存在，如果存在那么<code>count += v1 * v2 * v3 * v4</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">count := <span class=\"hljs-number\">0</span><br>map1 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>map2 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>map3 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>map4 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br><span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums1); i++ &#123;<br>    map1[nums1[i]]++<br>    map2[nums2[i]]++<br>    map3[nums3[i]]++<br>    map4[nums4[i]]++<br>&#125;<br><span class=\"hljs-keyword\">for</span> k1, v1 := <span class=\"hljs-keyword\">range</span> map1 &#123;<br>    <span class=\"hljs-keyword\">for</span> k2, v2 := <span class=\"hljs-keyword\">range</span> map2 &#123;<br>        <span class=\"hljs-keyword\">for</span> k3, v3 := <span class=\"hljs-keyword\">range</span> map3 &#123;<br>            <span class=\"hljs-keyword\">if</span> v4, ok := map4[<span class=\"hljs-number\">0</span>-k1-k2-k3]; ok &#123;<br>                count += v1 * v2 * v3 * v4<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">return</span> count<br></code></pre></td></tr></table></figure>\n\n<p>结果你猜超时没有，肯定还是超时了。</p>\n<p>原因如下：如果数组中重复的数不多，或者没有，就会退化成思路二。</p>\n<p>想了许久，想不出优化的方法了，看了卡哥的题解，我就用我的理解描述一下。</p>\n<h4 id=\"卡哥题解\"><a href=\"#卡哥题解\" class=\"headerlink\" title=\"卡哥题解\"></a>卡哥题解</h4><p>先计算<code>nums1</code>与<code>nums2</code>和，将两数组所有和的情况保存到<code>mapAB</code>中。key保存的是和，value保存的是和的个数。</p>\n<p>再计算<code>nums3</code>与<code>nums4</code>和，判断<code>mapAB[0-k3-k4]</code>是否存在，若存在<code>count+=mapAB[0-k3-k4]</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fourSumCount</span><span class=\"hljs-params\">(nums1 []<span class=\"hljs-type\">int</span>, nums2 []<span class=\"hljs-type\">int</span>, nums3 []<span class=\"hljs-type\">int</span>, nums4 []<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tcount := <span class=\"hljs-number\">0</span><br>\tmapAB := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v1 := <span class=\"hljs-keyword\">range</span> nums1 &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> _, v2 := <span class=\"hljs-keyword\">range</span> nums2 &#123;<br>\t\t\tmapAB[v1+v2]++<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v3 := <span class=\"hljs-keyword\">range</span> nums3 &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> _, v4 := <span class=\"hljs-keyword\">range</span> nums4 &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> v, ok := mapAB[<span class=\"hljs-number\">0</span>-v3-v4]; ok &#123;<br>\t\t\t\tcount += v<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"383-赎金信\"><a href=\"#383-赎金信\" class=\"headerlink\" title=\"383. 赎金信\"></a>383. 赎金信</h2><h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>要判断<code>ransomNote</code>是否含于<code>magazine</code>，先构建一个数组，存放<code>magazine</code>的情况，索引代表字母：0代表<code>&#39;a&#39;</code>，1代表<code>&#39;b&#39;</code>等等；值代表字母出现的次数。构建好后再遍历<code>ransomNote</code>串，将对应的字母数量减少一，如果不存在直接<code>return false</code></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">canConstruct</span><span class=\"hljs-params\">(ransomNote <span class=\"hljs-type\">string</span>, magazine <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(ransomNote) &gt; <span class=\"hljs-built_in\">len</span>(magazine) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>\tarr := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">26</span>)<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> magazine &#123;<br>\t\tarr[v-<span class=\"hljs-string\">&#x27;a&#x27;</span>]++<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> ransomNote &#123;<br>\t\tarr[v-<span class=\"hljs-string\">&#x27;a&#x27;</span>]--<br>\t\t<span class=\"hljs-keyword\">if</span> arr[v-<span class=\"hljs-string\">&#x27;a&#x27;</span>] &lt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15. 三数之和\"></a>15. 三数之和</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/3sum/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1GW4y127qo\">梦破碎的地方！| LeetCode：15.三数之和</a></p>\n<p>  状态：TLE</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>我投降了这道题，Go的底层现在有一个新的理解！</p>\n<h4 id=\"方法一：回溯算法\"><a href=\"#方法一：回溯算法\" class=\"headerlink\" title=\"方法一：回溯算法\"></a>方法一：回溯算法</h4><p>首先先将<code>nums</code>排序，利用回溯算法得到所有的组合，选择排序的原因是因为这样得到的组合，即使是重复的也可以保证顺序一致，方便判断这个组合是否出现过。最终结果保存到变量<code>result</code>，得到的可能得组合保存到变量<code>path</code></p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">backTracking</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, index <span class=\"hljs-type\">int</span>, result *[][]<span class=\"hljs-type\">int</span>, path *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(*path) == <span class=\"hljs-number\">3</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (*path)[<span class=\"hljs-number\">0</span>]+(*path)[<span class=\"hljs-number\">1</span>]+(*path)[<span class=\"hljs-number\">2</span>] == <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t<span class=\"hljs-comment\">// 后面的append()操作是深拷贝，所以这里使用temp保存path的值</span><br>            temp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(*path))  <br>\t\t\t<span class=\"hljs-built_in\">copy</span>(temp, *path)<br>\t\t\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> *result &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> reflect.DeepEqual(temp, v) &#123;  <span class=\"hljs-comment\">// 使用反射判断temp是否在result中</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">return</span><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t\t*result = <span class=\"hljs-built_in\">append</span>(*result, temp)<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := index; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, nums[i])<br>\t\tbackTracking(nums, i+<span class=\"hljs-number\">1</span>, result, path)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br><br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">threeSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">var</span> path []<span class=\"hljs-type\">int</span><br>\tsort.Ints(nums)<br>\tbackTracking(nums, <span class=\"hljs-number\">0</span>, &amp;result, &amp;path)<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>结果你猜超时没有，肯定还是超时了。</p>\n<p>这里我遇到了好多问题，首先是发现了<code>result = append(result, temp)</code>，这里<code>append</code>方法实际上是浅拷贝！也就是说以后<code>temp</code>的值，<code>result</code>也会变化。这也是我为什么用一个临时变量<code>temp</code>来保存<code>path</code>，而且使用的是<code>copy()</code>。</p>\n<p>要判断<code>temp</code>是否存在于<code>result</code>中，那么则需要使用反射，进行深度判断<code>reflect.DeepEqual(temp, v)</code>。</p>\n<h5 id=\"遇到最头大的问题！！！！！！\"><a href=\"#遇到最头大的问题！！！！！！\" class=\"headerlink\" title=\"遇到最头大的问题！！！！！！\"></a>遇到最头大的问题！！！！！！</h5><p>以前用别的语言写回溯，很自然的使用了全局变量，结果在Go语言中发生了奇妙的事情。请看截图</p>\n<img src=\"../images/day07/使用全局变量leetcode.png\" alt=\"使用全局变量leetcode\" style=\"zoom:80%;\" />\n\n<p>明明输入的只有0和1，怎么会输出了2。而且这个测试用例这么眼熟呢，没错这就是给出的测试用例Case1的答案。放到Goland里面明明是正确答案！到这里就变了，说明全局变量出现了问题。解决这个问题有两个想法：</p>\n<ul>\n<li>查找有没有类似C++中的<code>delete</code>，使用完变量之后释放掉。发现并没有。而且使用完变量应该在<code>threeSum()</code>之外了，函数内释放就没有结果了。</li>\n<li><code>threeSum()</code>定义变量，使用指针传值。</li>\n</ul>\n<p>当然，第二种才是正解。改完之后就是上面放出来的代码了，超时。</p>\n<h4 id=\"方法二：使用哈希\"><a href=\"#方法二：使用哈希\" class=\"headerlink\" title=\"方法二：使用哈希\"></a>方法二：使用哈希</h4><p>将<code>nums</code>进行排序，并哈希处理，定义变量<code>map1</code>用作哈希表，<code>nums</code>中的每个元素做key，value则是每个元素出现的次数。</p>\n<p>使用两层for循环之后，判断<code>0-nums[i]-nums[j]</code>是否存在。若存在还需要判断每个数字出现的次数是否合法（例如<code>nums = [-1,0,1,2,-1,-4]</code>，如果找到一个组合是<code>[2, -4, 2]</code>则需要舍弃。之所以会出现这样，是因为两层for会找到<code>2</code>和<code>-4</code>，而<code>0-nums[i]-nums[j]</code>会找到重复的2）</p>\n<p>找到组合之后，对组合再排序，判断<code>path</code>是否在<code>result</code>中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">threeSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\tsort.Ints(nums)<br>\tmap1 := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>\t\tmap1[v]++<br>\t&#125;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> j := i + <span class=\"hljs-number\">1</span>; j &lt; <span class=\"hljs-built_in\">len</span>(nums); j++ &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> v, ok := map1[-nums[i]-nums[j]]; ok &#123;<br>\t\t\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;nums[i], nums[j], -nums[i] - nums[j]&#125;<br>\t\t\t\tsort.Ints(temp)<br>\t\t\t\tcount := <span class=\"hljs-number\">0</span><br>\t\t\t\t<span class=\"hljs-keyword\">if</span> nums[i] == nums[j] || nums[j] == -nums[i]-nums[j] || nums[i] == -nums[i]-nums[j] &#123;<br>\t\t\t\t\tcount = <span class=\"hljs-number\">2</span><br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> nums[i] == nums[j] &amp;&amp; nums[j] == -nums[i]-nums[j] &#123;<br>\t\t\t\t\tcount = <span class=\"hljs-number\">3</span><br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> v &gt;= count &#123;<br>\t\t\t\t\tflag := <span class=\"hljs-literal\">true</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">for</span> _, value := <span class=\"hljs-keyword\">range</span> result &#123;<br>\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> reflect.DeepEqual(value, temp) &#123;<br>\t\t\t\t\t\t\tflag = <span class=\"hljs-literal\">false</span><br>\t\t\t\t\t\t&#125;<br>\t\t\t\t\t&#125;<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> flag &#123;<br>\t\t\t\t\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t\t\t\t\t&#125;<br><br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>结果你猜超时没有，肯定还是超时了。</p>\n<p>好了，我投降了，想不到好方法了。去看卡哥视频了。</p>\n<h3 id=\"卡哥解法\"><a href=\"#卡哥解法\" class=\"headerlink\" title=\"卡哥解法\"></a>卡哥解法</h3><p><font color=\"red\">这道题不适合用哈希表做</font>。双指针我想了一下也没有太想明白，主要还是去重操作。看了视频讲解很清楚了</p>\n<ol>\n<li><p>数组排序，方便后序操作</p>\n</li>\n<li><p>先找第一个数，使用一层<code>for</code>，指针为<code>i</code></p>\n</li>\n<li><p>找第二个、第三个数。分别用指针<code>left = i + 1</code>，<code>right = len(nums) - 1</code></p>\n</li>\n<li><p>剪枝：如果<code>i&gt;0</code>，那么直接<code>return</code>，说明后续不可能再有等于0的三元组了</p>\n</li>\n<li><p>判断<code>nums[i] + nums[left] + nums[right]</code>和0的情况</p>\n<ul>\n<li><code>nums[i] + nums[left] + nums[right] &gt; 0    right--</code></li>\n<li><code>nums[i] + nums[left] + nums[right] &lt; 0    left++</code></li>\n<li><code>nums[i] + nums[left] + nums[right] == 0</code> <ul>\n<li>这个三元组放入到结果中，但是仍然要相向前进。对于<code>left</code>，如果如果一致前进得到的<code>nums[left]==nums[left+1]</code>，说明该三元组已经存在过了（<code>0, -1, -1, 1 ,1</code>）。<code>right</code>同理，<code>nums[right] == nums[right - 1]</code></li>\n<li>找到各自不同的数<code>nums[left+1]</code>和<code>nums[right-1]</code>，再前进一个（<code>0, -1, -1, -2, 2, 1, 1</code>）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>return result</code></p>\n</li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">threeSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\tsort.Ints(nums)<br>\tresult := [][]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> nums[i] &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> result<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> i &gt; <span class=\"hljs-number\">0</span> &amp;&amp; nums[i] == nums[i<span class=\"hljs-number\">-1</span>] &#123;<br>\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t&#125;<br>\t\tleft := i + <span class=\"hljs-number\">1</span><br>\t\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t\t<span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> nums[i]+nums[left]+nums[right] &gt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t\tright--<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[i]+nums[left]+nums[right] &lt; <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t\tleft++<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tresult = <span class=\"hljs-built_in\">append</span>(result, []<span class=\"hljs-type\">int</span>&#123;nums[i], nums[left], nums[right]&#125;)<br>\t\t\t\t<span class=\"hljs-keyword\">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class=\"hljs-number\">1</span>] &#123;<br>\t\t\t\t\tleft++<br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class=\"hljs-number\">-1</span>] &#123;<br>\t\t\t\t\tright--<br>\t\t\t\t&#125;<br>\t\t\t\tleft++<br>\t\t\t\tright--<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>虽然这个代码AC了，但是毫无成就感。现在是9月27日凌晨2:53，还有一道题。继续</p>\n<h2 id=\"18-四数之和\"><a href=\"#18-四数之和\" class=\"headerlink\" title=\"18. 四数之和\"></a>18. 四数之和</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/4sum/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1DS4y147US\">难在去重和剪枝！| LeetCode：18. 四数之和</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>算法同上题，只不过这次要先确定两个数，然后用<code>left</code>和<code>right</code>指针找第三个第四个数。有几点不同：</p>\n<ul>\n<li>这里不是与0作比较，而是<code>target</code>，不可以<code>nums[i] &gt; target</code>之后就<code>break</code>，因为如果有一堆负数相加一定出现越加越小，使得等于<code>target</code></li>\n<li>数组长度可能小于4，需要额外判断</li>\n<li>剪枝<code>i&gt;0</code>开始，<code>j&gt;i+1</code>开始，<code>j</code>永远在<code>i</code>后一位</li>\n</ul>\n<p>领悟了上一道题，这一题不难了</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fourSum</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(nums) &lt; <span class=\"hljs-number\">4</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tsort.Ints(nums)<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nums)<span class=\"hljs-number\">-3</span>; i++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> i &gt; <span class=\"hljs-number\">0</span> &amp;&amp; nums[i] == nums[i<span class=\"hljs-number\">-1</span>] &#123;<br>\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> j := i + <span class=\"hljs-number\">1</span>; j &lt; <span class=\"hljs-built_in\">len</span>(nums)<span class=\"hljs-number\">-2</span>; j++ &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> j &gt; i+<span class=\"hljs-number\">1</span> &amp;&amp; nums[j] == nums[j<span class=\"hljs-number\">-1</span>] &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t\t&#125;<br>\t\t\tleft := j + <span class=\"hljs-number\">1</span><br>\t\t\tright := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>\t\t\t<span class=\"hljs-keyword\">for</span> left &lt; right &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> nums[i]+nums[j]+nums[left]+nums[right] &lt; target &#123;<br>\t\t\t\t\tleft++<br>\t\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> nums[i]+nums[j]+nums[left]+nums[right] &gt; target &#123;<br>\t\t\t\t\tright--<br>\t\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t\tresult = <span class=\"hljs-built_in\">append</span>(result, []<span class=\"hljs-type\">int</span>&#123;nums[i], nums[j], nums[left], nums[right]&#125;)<br>\t\t\t\t\t<span class=\"hljs-keyword\">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class=\"hljs-number\">1</span>] &#123;<br>\t\t\t\t\t\tleft++<br>\t\t\t\t\t&#125;<br>\t\t\t\t\t<span class=\"hljs-keyword\">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class=\"hljs-number\">-1</span>] &#123;<br>\t\t\t\t\t\tright--<br>\t\t\t\t\t&#125;<br>\t\t\t\t\tleft++<br>\t\t\t\t\tright--<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>Go的底层有了很多认识，是以前做题或者写项目时候意识不到的。尤其是浅拷贝与深拷贝，大概找到规律了，几乎都是浅拷贝，如果想要深拷贝一定要用<code>copy()</code></li>\n<li>由于Go的特性，Go的全局变量不可以在leetcode使用，需要指针传值</li>\n<li>晚安，准备睡觉了，3:20了，一觉起来是新的题，字符串要学KMP算法什么的了。</li>\n</ul>\n"},{"title":"代码随想录算法训练营第十天 232.用栈实现队列、225. 用队列实现栈。","abbrlink":"a8d0ca77","date":"2023-10-01T16:36:27.000Z","_content":"\n# 代码随想录算法训练营第十天 232.用栈实现队列、225. 用队列实现栈。\n\n## 232.用栈实现队列\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/implement-queue-using-stacks/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html)\n>\n> 视频讲解：[栈的基本操作！ | LeetCode：232.用栈实现队列](https://www.bilibili.com/video/BV1nY4y1w7VC)\n>\n> 状态：AC\n\n### 思路\n\n- 初始化两个栈，一个作为主栈`Stack1`、一个作为副栈`Stack2`\n- 主栈存放数据、副栈临时放数据\n- `Push`操作：将数据放入`Stack1`中\n- `Pop`操作：\n    - 将`Stack1`中所有元素退栈，并入栈`Stack2`。\n    - 将`Stack2`的栈顶元素出栈\n    - 将`Stack2`中所有元素退栈，并入栈`Stack1`。\n- `Peek`操作：\n    - 将`Stack1`中所有元素退栈，并入栈`Stack2`。\n    - 取`Stack2`的栈顶元素\n    - 将`Stack2`中所有元素退栈，并入栈`Stack1`。\n- `Empty`操作：\n    - 查看`Stack1`是否为空即可\n\n### 代码\n\n``` go\ntype MyQueue struct {\n\tStack1 arraystack.Stack\n\tStack2 arraystack.Stack\n}\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tStack1: *arraystack.New(),\n\t\tStack2: *arraystack.New(),\n\t}\n}\n\nfunc (this *MyQueue) Push(x int) {\n\tthis.Stack1.Push(x)\n}\n\nfunc (this *MyQueue) Pop() int {\n\tfor !this.Stack1.Empty() {\n\t\tif v, ok := this.Stack1.Pop(); ok {\n\t\t\tthis.Stack2.Push(v)\n\t\t}\n\t}\n\tvalue, _ := this.Stack2.Pop()\n\tfor !this.Stack2.Empty() {\n\t\tif v, ok := this.Stack2.Pop(); ok {\n\t\t\tthis.Stack1.Push(v)\n\t\t}\n\t}\n\treturn value.(int)\n}\n\nfunc (this *MyQueue) Peek() int {\n\tfor !this.Stack1.Empty() {\n\t\tif v, ok := this.Stack1.Pop(); ok {\n\t\t\tthis.Stack2.Push(v)\n\t\t}\n\t}\n\tvalue, _ := this.Stack2.Peek()\n\tfor !this.Stack2.Empty() {\n\t\tif v, ok := this.Stack2.Pop(); ok {\n\t\t\tthis.Stack1.Push(v)\n\t\t}\n\t}\n\treturn value.(int)\n}\n\nfunc (this *MyQueue) Empty() bool {\n\treturn this.Stack1.Empty()\n}\n```\n\n## 225. 用队列实现栈\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/implement-stack-using-queues/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html)\n>\n> 视频讲解：[队列的基本操作！ | LeetCode：225. 用队列实现栈](https://www.bilibili.com/video/BV1Fd4y1K7sm)\n>\n> 状态：AC\n\n### 思路\n\n- 初始化一个队列`Queue1`\n- 主栈存放数据、副栈临时放数据\n- `Push`操作：将数据入队`Queue1`\n- `Pop`操作：\n    - 将`Queue1`前`n-1`个元素出队，随后入队在队尾\n    - 最后一个元素出队，返回\n- `Top`操作：\n    - 将`Queue`每个出队，随后入队在队尾\n    - 如果是最后一个元素出队，保存该值，并入队\n    - 返回那个值\n- `Empty`操作：\n    - 查看`Queue1`是否为空即可\n\n### 代码\n\n``` go\ntype MyStack struct {\n\tQueue1 arrayqueue.Queue\n}\n\nfunc Constructor() MyStack {\n\treturn MyStack{\n\t\tQueue1: *arrayqueue.New(),\n\t}\n}\n\nfunc (this *MyStack) Push(x int) {\n\tthis.Queue1.Enqueue(x)\n}\n\nfunc (this *MyStack) Pop() int {\n\tfor i := 0; i < this.Queue1.Size()-1; i++ {\n\t\tv, _ := this.Queue1.Dequeue()\n\t\tvalue := v.(int)\n\t\tthis.Queue1.Enqueue(value)\n\t}\n\tv, _ := this.Queue1.Dequeue()\n\tvalue := v.(int)\n\treturn value\n}\n\nfunc (this *MyStack) Top() int {\n\ttop := 0\n\tfor i := 0; i < this.Queue1.Size(); i++ {\n\t\tv, _ := this.Queue1.Dequeue()\n\t\tvalue := v.(int)\n\t\tthis.Queue1.Enqueue(value)\n\t\tif i == this.Queue1.Size()-1 {\n\t\t\ttop = value\n\t\t}\n\t}\n\treturn top\n}\n\nfunc (this *MyStack) Empty() bool {\n\treturn this.Queue1.Empty()\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.Empty();\n */\n\n```\n\n","source":"_posts/day10.md","raw":"---\ntitle: 代码随想录算法训练营第十天 232.用栈实现队列、225. 用队列实现栈。\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: a8d0ca77\ndate: 2023-10-02 00:36:27\n---\n\n# 代码随想录算法训练营第十天 232.用栈实现队列、225. 用队列实现栈。\n\n## 232.用栈实现队列\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/implement-queue-using-stacks/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html)\n>\n> 视频讲解：[栈的基本操作！ | LeetCode：232.用栈实现队列](https://www.bilibili.com/video/BV1nY4y1w7VC)\n>\n> 状态：AC\n\n### 思路\n\n- 初始化两个栈，一个作为主栈`Stack1`、一个作为副栈`Stack2`\n- 主栈存放数据、副栈临时放数据\n- `Push`操作：将数据放入`Stack1`中\n- `Pop`操作：\n    - 将`Stack1`中所有元素退栈，并入栈`Stack2`。\n    - 将`Stack2`的栈顶元素出栈\n    - 将`Stack2`中所有元素退栈，并入栈`Stack1`。\n- `Peek`操作：\n    - 将`Stack1`中所有元素退栈，并入栈`Stack2`。\n    - 取`Stack2`的栈顶元素\n    - 将`Stack2`中所有元素退栈，并入栈`Stack1`。\n- `Empty`操作：\n    - 查看`Stack1`是否为空即可\n\n### 代码\n\n``` go\ntype MyQueue struct {\n\tStack1 arraystack.Stack\n\tStack2 arraystack.Stack\n}\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tStack1: *arraystack.New(),\n\t\tStack2: *arraystack.New(),\n\t}\n}\n\nfunc (this *MyQueue) Push(x int) {\n\tthis.Stack1.Push(x)\n}\n\nfunc (this *MyQueue) Pop() int {\n\tfor !this.Stack1.Empty() {\n\t\tif v, ok := this.Stack1.Pop(); ok {\n\t\t\tthis.Stack2.Push(v)\n\t\t}\n\t}\n\tvalue, _ := this.Stack2.Pop()\n\tfor !this.Stack2.Empty() {\n\t\tif v, ok := this.Stack2.Pop(); ok {\n\t\t\tthis.Stack1.Push(v)\n\t\t}\n\t}\n\treturn value.(int)\n}\n\nfunc (this *MyQueue) Peek() int {\n\tfor !this.Stack1.Empty() {\n\t\tif v, ok := this.Stack1.Pop(); ok {\n\t\t\tthis.Stack2.Push(v)\n\t\t}\n\t}\n\tvalue, _ := this.Stack2.Peek()\n\tfor !this.Stack2.Empty() {\n\t\tif v, ok := this.Stack2.Pop(); ok {\n\t\t\tthis.Stack1.Push(v)\n\t\t}\n\t}\n\treturn value.(int)\n}\n\nfunc (this *MyQueue) Empty() bool {\n\treturn this.Stack1.Empty()\n}\n```\n\n## 225. 用队列实现栈\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/implement-stack-using-queues/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html)\n>\n> 视频讲解：[队列的基本操作！ | LeetCode：225. 用队列实现栈](https://www.bilibili.com/video/BV1Fd4y1K7sm)\n>\n> 状态：AC\n\n### 思路\n\n- 初始化一个队列`Queue1`\n- 主栈存放数据、副栈临时放数据\n- `Push`操作：将数据入队`Queue1`\n- `Pop`操作：\n    - 将`Queue1`前`n-1`个元素出队，随后入队在队尾\n    - 最后一个元素出队，返回\n- `Top`操作：\n    - 将`Queue`每个出队，随后入队在队尾\n    - 如果是最后一个元素出队，保存该值，并入队\n    - 返回那个值\n- `Empty`操作：\n    - 查看`Queue1`是否为空即可\n\n### 代码\n\n``` go\ntype MyStack struct {\n\tQueue1 arrayqueue.Queue\n}\n\nfunc Constructor() MyStack {\n\treturn MyStack{\n\t\tQueue1: *arrayqueue.New(),\n\t}\n}\n\nfunc (this *MyStack) Push(x int) {\n\tthis.Queue1.Enqueue(x)\n}\n\nfunc (this *MyStack) Pop() int {\n\tfor i := 0; i < this.Queue1.Size()-1; i++ {\n\t\tv, _ := this.Queue1.Dequeue()\n\t\tvalue := v.(int)\n\t\tthis.Queue1.Enqueue(value)\n\t}\n\tv, _ := this.Queue1.Dequeue()\n\tvalue := v.(int)\n\treturn value\n}\n\nfunc (this *MyStack) Top() int {\n\ttop := 0\n\tfor i := 0; i < this.Queue1.Size(); i++ {\n\t\tv, _ := this.Queue1.Dequeue()\n\t\tvalue := v.(int)\n\t\tthis.Queue1.Enqueue(value)\n\t\tif i == this.Queue1.Size()-1 {\n\t\t\ttop = value\n\t\t}\n\t}\n\treturn top\n}\n\nfunc (this *MyStack) Empty() bool {\n\treturn this.Queue1.Empty()\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.Empty();\n */\n\n```\n\n","slug":"day10","published":1,"updated":"2023-10-01T17:18:33.392Z","_id":"cln7q7alx000kvswh2zt2gd2z","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第十天-232-用栈实现队列、225-用队列实现栈。\"><a href=\"#代码随想录算法训练营第十天-232-用栈实现队列、225-用队列实现栈。\" class=\"headerlink\" title=\"代码随想录算法训练营第十天 232.用栈实现队列、225. 用队列实现栈。\"></a>代码随想录算法训练营第十天 232.用栈实现队列、225. 用队列实现栈。</h1><h2 id=\"232-用栈实现队列\"><a href=\"#232-用栈实现队列\" class=\"headerlink\" title=\"232.用栈实现队列\"></a>232.用栈实现队列</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/implement-queue-using-stacks/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1nY4y1w7VC\">栈的基本操作！ | LeetCode：232.用栈实现队列</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>初始化两个栈，一个作为主栈<code>Stack1</code>、一个作为副栈<code>Stack2</code></li>\n<li>主栈存放数据、副栈临时放数据</li>\n<li><code>Push</code>操作：将数据放入<code>Stack1</code>中</li>\n<li><code>Pop</code>操作：<ul>\n<li>将<code>Stack1</code>中所有元素退栈，并入栈<code>Stack2</code>。</li>\n<li>将<code>Stack2</code>的栈顶元素出栈</li>\n<li>将<code>Stack2</code>中所有元素退栈，并入栈<code>Stack1</code>。</li>\n</ul>\n</li>\n<li><code>Peek</code>操作：<ul>\n<li>将<code>Stack1</code>中所有元素退栈，并入栈<code>Stack2</code>。</li>\n<li>取<code>Stack2</code>的栈顶元素</li>\n<li>将<code>Stack2</code>中所有元素退栈，并入栈<code>Stack1</code>。</li>\n</ul>\n</li>\n<li><code>Empty</code>操作：<ul>\n<li>查看<code>Stack1</code>是否为空即可</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> MyQueue <span class=\"hljs-keyword\">struct</span> &#123;<br>\tStack1 arraystack.Stack<br>\tStack2 arraystack.Stack<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">()</span></span> MyQueue &#123;<br>\t<span class=\"hljs-keyword\">return</span> MyQueue&#123;<br>\t\tStack1: *arraystack.New(),<br>\t\tStack2: *arraystack.New(),<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyQueue)</span></span> Push(x <span class=\"hljs-type\">int</span>) &#123;<br>\tthis.Stack1.Push(x)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyQueue)</span></span> Pop() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">for</span> !this.Stack1.Empty() &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v, ok := this.Stack1.Pop(); ok &#123;<br>\t\t\tthis.Stack2.Push(v)<br>\t\t&#125;<br>\t&#125;<br>\tvalue, _ := this.Stack2.Pop()<br>\t<span class=\"hljs-keyword\">for</span> !this.Stack2.Empty() &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v, ok := this.Stack2.Pop(); ok &#123;<br>\t\t\tthis.Stack1.Push(v)<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> value.(<span class=\"hljs-type\">int</span>)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyQueue)</span></span> Peek() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">for</span> !this.Stack1.Empty() &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v, ok := this.Stack1.Pop(); ok &#123;<br>\t\t\tthis.Stack2.Push(v)<br>\t\t&#125;<br>\t&#125;<br>\tvalue, _ := this.Stack2.Peek()<br>\t<span class=\"hljs-keyword\">for</span> !this.Stack2.Empty() &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v, ok := this.Stack2.Pop(); ok &#123;<br>\t\t\tthis.Stack1.Push(v)<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> value.(<span class=\"hljs-type\">int</span>)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyQueue)</span></span> Empty() <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> this.Stack1.Empty()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"225-用队列实现栈\"><a href=\"#225-用队列实现栈\" class=\"headerlink\" title=\"225. 用队列实现栈\"></a>225. 用队列实现栈</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/implement-stack-using-queues/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1Fd4y1K7sm\">队列的基本操作！ | LeetCode：225. 用队列实现栈</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>初始化一个队列<code>Queue1</code></li>\n<li>主栈存放数据、副栈临时放数据</li>\n<li><code>Push</code>操作：将数据入队<code>Queue1</code></li>\n<li><code>Pop</code>操作：<ul>\n<li>将<code>Queue1</code>前<code>n-1</code>个元素出队，随后入队在队尾</li>\n<li>最后一个元素出队，返回</li>\n</ul>\n</li>\n<li><code>Top</code>操作：<ul>\n<li>将<code>Queue</code>每个出队，随后入队在队尾</li>\n<li>如果是最后一个元素出队，保存该值，并入队</li>\n<li>返回那个值</li>\n</ul>\n</li>\n<li><code>Empty</code>操作：<ul>\n<li>查看<code>Queue1</code>是否为空即可</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> MyStack <span class=\"hljs-keyword\">struct</span> &#123;<br>\tQueue1 arrayqueue.Queue<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">()</span></span> MyStack &#123;<br>\t<span class=\"hljs-keyword\">return</span> MyStack&#123;<br>\t\tQueue1: *arrayqueue.New(),<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyStack)</span></span> Push(x <span class=\"hljs-type\">int</span>) &#123;<br>\tthis.Queue1.Enqueue(x)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyStack)</span></span> Pop() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; this.Queue1.Size()<span class=\"hljs-number\">-1</span>; i++ &#123;<br>\t\tv, _ := this.Queue1.Dequeue()<br>\t\tvalue := v.(<span class=\"hljs-type\">int</span>)<br>\t\tthis.Queue1.Enqueue(value)<br>\t&#125;<br>\tv, _ := this.Queue1.Dequeue()<br>\tvalue := v.(<span class=\"hljs-type\">int</span>)<br>\t<span class=\"hljs-keyword\">return</span> value<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyStack)</span></span> Top() <span class=\"hljs-type\">int</span> &#123;<br>\ttop := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; this.Queue1.Size(); i++ &#123;<br>\t\tv, _ := this.Queue1.Dequeue()<br>\t\tvalue := v.(<span class=\"hljs-type\">int</span>)<br>\t\tthis.Queue1.Enqueue(value)<br>\t\t<span class=\"hljs-keyword\">if</span> i == this.Queue1.Size()<span class=\"hljs-number\">-1</span> &#123;<br>\t\t\ttop = value<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> top<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyStack)</span></span> Empty() <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> this.Queue1.Empty()<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Your MyStack object will be instantiated and called as such:</span><br><span class=\"hljs-comment\"> * obj := Constructor();</span><br><span class=\"hljs-comment\"> * obj.Push(x);</span><br><span class=\"hljs-comment\"> * param_2 := obj.Pop();</span><br><span class=\"hljs-comment\"> * param_3 := obj.Top();</span><br><span class=\"hljs-comment\"> * param_4 := obj.Empty();</span><br><span class=\"hljs-comment\"> */</span><br><br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第十天-232-用栈实现队列、225-用队列实现栈。\"><a href=\"#代码随想录算法训练营第十天-232-用栈实现队列、225-用队列实现栈。\" class=\"headerlink\" title=\"代码随想录算法训练营第十天 232.用栈实现队列、225. 用队列实现栈。\"></a>代码随想录算法训练营第十天 232.用栈实现队列、225. 用队列实现栈。</h1><h2 id=\"232-用栈实现队列\"><a href=\"#232-用栈实现队列\" class=\"headerlink\" title=\"232.用栈实现队列\"></a>232.用栈实现队列</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/implement-queue-using-stacks/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1nY4y1w7VC\">栈的基本操作！ | LeetCode：232.用栈实现队列</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>初始化两个栈，一个作为主栈<code>Stack1</code>、一个作为副栈<code>Stack2</code></li>\n<li>主栈存放数据、副栈临时放数据</li>\n<li><code>Push</code>操作：将数据放入<code>Stack1</code>中</li>\n<li><code>Pop</code>操作：<ul>\n<li>将<code>Stack1</code>中所有元素退栈，并入栈<code>Stack2</code>。</li>\n<li>将<code>Stack2</code>的栈顶元素出栈</li>\n<li>将<code>Stack2</code>中所有元素退栈，并入栈<code>Stack1</code>。</li>\n</ul>\n</li>\n<li><code>Peek</code>操作：<ul>\n<li>将<code>Stack1</code>中所有元素退栈，并入栈<code>Stack2</code>。</li>\n<li>取<code>Stack2</code>的栈顶元素</li>\n<li>将<code>Stack2</code>中所有元素退栈，并入栈<code>Stack1</code>。</li>\n</ul>\n</li>\n<li><code>Empty</code>操作：<ul>\n<li>查看<code>Stack1</code>是否为空即可</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> MyQueue <span class=\"hljs-keyword\">struct</span> &#123;<br>\tStack1 arraystack.Stack<br>\tStack2 arraystack.Stack<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">()</span></span> MyQueue &#123;<br>\t<span class=\"hljs-keyword\">return</span> MyQueue&#123;<br>\t\tStack1: *arraystack.New(),<br>\t\tStack2: *arraystack.New(),<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyQueue)</span></span> Push(x <span class=\"hljs-type\">int</span>) &#123;<br>\tthis.Stack1.Push(x)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyQueue)</span></span> Pop() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">for</span> !this.Stack1.Empty() &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v, ok := this.Stack1.Pop(); ok &#123;<br>\t\t\tthis.Stack2.Push(v)<br>\t\t&#125;<br>\t&#125;<br>\tvalue, _ := this.Stack2.Pop()<br>\t<span class=\"hljs-keyword\">for</span> !this.Stack2.Empty() &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v, ok := this.Stack2.Pop(); ok &#123;<br>\t\t\tthis.Stack1.Push(v)<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> value.(<span class=\"hljs-type\">int</span>)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyQueue)</span></span> Peek() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">for</span> !this.Stack1.Empty() &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v, ok := this.Stack1.Pop(); ok &#123;<br>\t\t\tthis.Stack2.Push(v)<br>\t\t&#125;<br>\t&#125;<br>\tvalue, _ := this.Stack2.Peek()<br>\t<span class=\"hljs-keyword\">for</span> !this.Stack2.Empty() &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v, ok := this.Stack2.Pop(); ok &#123;<br>\t\t\tthis.Stack1.Push(v)<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> value.(<span class=\"hljs-type\">int</span>)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyQueue)</span></span> Empty() <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> this.Stack1.Empty()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"225-用队列实现栈\"><a href=\"#225-用队列实现栈\" class=\"headerlink\" title=\"225. 用队列实现栈\"></a>225. 用队列实现栈</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/implement-stack-using-queues/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1Fd4y1K7sm\">队列的基本操作！ | LeetCode：225. 用队列实现栈</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>初始化一个队列<code>Queue1</code></li>\n<li>主栈存放数据、副栈临时放数据</li>\n<li><code>Push</code>操作：将数据入队<code>Queue1</code></li>\n<li><code>Pop</code>操作：<ul>\n<li>将<code>Queue1</code>前<code>n-1</code>个元素出队，随后入队在队尾</li>\n<li>最后一个元素出队，返回</li>\n</ul>\n</li>\n<li><code>Top</code>操作：<ul>\n<li>将<code>Queue</code>每个出队，随后入队在队尾</li>\n<li>如果是最后一个元素出队，保存该值，并入队</li>\n<li>返回那个值</li>\n</ul>\n</li>\n<li><code>Empty</code>操作：<ul>\n<li>查看<code>Queue1</code>是否为空即可</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> MyStack <span class=\"hljs-keyword\">struct</span> &#123;<br>\tQueue1 arrayqueue.Queue<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">()</span></span> MyStack &#123;<br>\t<span class=\"hljs-keyword\">return</span> MyStack&#123;<br>\t\tQueue1: *arrayqueue.New(),<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyStack)</span></span> Push(x <span class=\"hljs-type\">int</span>) &#123;<br>\tthis.Queue1.Enqueue(x)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyStack)</span></span> Pop() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; this.Queue1.Size()<span class=\"hljs-number\">-1</span>; i++ &#123;<br>\t\tv, _ := this.Queue1.Dequeue()<br>\t\tvalue := v.(<span class=\"hljs-type\">int</span>)<br>\t\tthis.Queue1.Enqueue(value)<br>\t&#125;<br>\tv, _ := this.Queue1.Dequeue()<br>\tvalue := v.(<span class=\"hljs-type\">int</span>)<br>\t<span class=\"hljs-keyword\">return</span> value<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyStack)</span></span> Top() <span class=\"hljs-type\">int</span> &#123;<br>\ttop := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; this.Queue1.Size(); i++ &#123;<br>\t\tv, _ := this.Queue1.Dequeue()<br>\t\tvalue := v.(<span class=\"hljs-type\">int</span>)<br>\t\tthis.Queue1.Enqueue(value)<br>\t\t<span class=\"hljs-keyword\">if</span> i == this.Queue1.Size()<span class=\"hljs-number\">-1</span> &#123;<br>\t\t\ttop = value<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> top<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *MyStack)</span></span> Empty() <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> this.Queue1.Empty()<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Your MyStack object will be instantiated and called as such:</span><br><span class=\"hljs-comment\"> * obj := Constructor();</span><br><span class=\"hljs-comment\"> * obj.Push(x);</span><br><span class=\"hljs-comment\"> * param_2 := obj.Pop();</span><br><span class=\"hljs-comment\"> * param_3 := obj.Top();</span><br><span class=\"hljs-comment\"> * param_4 := obj.Empty();</span><br><span class=\"hljs-comment\"> */</span><br><br></code></pre></td></tr></table></figure>\n\n"},{"title":"代码随想录算法训练营第十一天 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值。","abbrlink":"bdbe1e6e","date":"2023-10-03T11:58:17.000Z","_content":"\n# 代码随想录算法训练营第十一天 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值。\n\n## 20.有效的括号\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/valid-parentheses/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html)\n>\n> 视频讲解：[栈的拿手好戏！| LeetCode：20. 有效的括号](https://www.bilibili.com/video/BV1AF411w78g)\n>\n> 状态：AC\n\n### 思路\n\n题目保证了输入的字符串只有括号。遇到左括号入栈，遇到右括号出栈，但是要比较出栈的元素和当前的右括号是否匹配，不匹配直接`return false`。最终判断栈是否为空即可。\n\n### 代码\n\n``` go\nfunc isValid(s string) bool {\n\tstack := arraystack.New()\n\tfor _, v := range s {\n\t\tswitch v {\n\t\tcase '(', '[', '{':\n\t\t\tstack.Push(v)\n\t\tcase ')':\n\t\t\ttemp, _ := stack.Pop()\n\t\t\tif temp == '(' {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase ']':\n\t\t\ttemp, _ := stack.Pop()\n\t\t\tif temp == '[' {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase '}':\n\t\t\ttemp, _ := stack.Pop()\n\t\t\tif temp == '{' {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn stack.Empty()\n}\n\n```\n\n## 1047.删除字符串中的所有相邻重复项\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html)\n>\n> 视频讲解：[栈的好戏还要继续！| LeetCode：1047. 删除字符串中的所有相邻重复项](https://www.bilibili.com/video/BV12a411P7mw)\n>\n> 状态：AC\n\n### 思路\n\n将每个元素与栈顶元素进行比较（前提是栈非空、如果空直接入栈即可），比较相等元素出栈。\n\n### 代码\n\n``` go\nfunc removeDuplicates(s string) string {\n\tif len(s) == 1 {\n\t\treturn s\n\t}\n\tbyteString := []rune(s)\n\tstack := arraystack.New()\n\tstack.Push(byteString[0])\n\n\tfor i := 1; i < len(byteString); i++ {\n\t\ttemp, _ := stack.Peek()\n\t\tif temp == byteString[i] {\n\t\t\tstack.Pop()\n\t\t} else {\n\t\t\tstack.Push(byteString[i])\n\t\t}\n\t}\n\tvar newByte []rune\n\tlength := stack.Size()\n\tfor i := 0; i < length; i++ {\n\t\ttemp, _ := stack.Pop()\n\t\ttemp1 := temp.(rune)\n\t\tnewByte = append(newByte, temp1)\n\t}\n\tfor i := 0; i < len(newByte)/2; i++ {\n\t\tnewByte[i], newByte[len(newByte)-1-i] = newByte[len(newByte)-1-i], newByte[i]\n\t}\n\treturn string(newByte)\n}\n```\n\n此处用的是一个真正意义上的数据结构的栈，存储的是单个字符，写起来还是很长，看了题解之后发现只用字符数组即可，改正后代码\n\n``` go\nfunc removeDuplicates(s string) string {\n\tvar stack []rune\n\tfor _, v := range s {\n\t\tif len(stack) > 0 && stack[len(stack)-1] == v {\n\t\t\tstack = stack[:len(stack)-1]\n\t\t} else {\n\t\t\tstack = append(stack, v)\n\t\t}\n\t}\n\treturn string(stack)\n}\n```\n\n## 150.逆波兰表达式\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html)\n>\n> 视频讲解：栈的最后表演！ | LeetCode：150. 逆波兰表达式求值](https://www.bilibili.com/video/BV1kd4y1o7on)\n>\n> 状态：AC\n\n### 思路\n\n明白题意之后，发现每次到运算符时候需要将前面两个数进行计算，如：`[\"a\", \"b\", \"+\"]`运算结果是`a+b`。不难想到要使用栈。\n\n先将字符串数组转换为数字，可以成功转换则入栈，否则出栈两个元素，并且将两个元素相加之后再重新入栈。\n\n### 代码\n\n``` go\n\nfunc EvalRPN(tokens []string) int {\n\tstack := arraystack.New()\n\tfor _, v := range tokens {\n\t\tnum, err := strconv.Atoi(v)\n\t\tif err == nil {  // 如果成功转换数字\n\t\t\tstack.Push(num)\n\t\t} else {  // 否则计算后重新入栈\n\t\t\tb, _ := stack.Pop()\n\t\t\ta, _ := stack.Pop()\n\t\t\tif v == \"+\" {\n\t\t\t\tstack.Push(a.(int) + b.(int))\n\t\t\t} else if v == \"-\" {\n\t\t\t\tstack.Push(a.(int) - b.(int))\n\t\t\t} else if v == \"*\" {\n\t\t\t\tstack.Push(a.(int) * b.(int))\n\t\t\t} else if v == \"/\" {\n\t\t\t\tstack.Push(a.(int) / b.(int))\n\t\t\t}\n\t\t}\n\t}\n\tresult, _ := stack.Peek()  // 此刻的栈顶为结果\n\treturn result.(int)\n}\n\n```\n\n","source":"_posts/day11.md","raw":"---\ntitle: 代码随想录算法训练营第十一天 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值。\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: bdbe1e6e\ndate: 2023-10-03 19:58:17\n---\n\n# 代码随想录算法训练营第十一天 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值。\n\n## 20.有效的括号\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/valid-parentheses/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html)\n>\n> 视频讲解：[栈的拿手好戏！| LeetCode：20. 有效的括号](https://www.bilibili.com/video/BV1AF411w78g)\n>\n> 状态：AC\n\n### 思路\n\n题目保证了输入的字符串只有括号。遇到左括号入栈，遇到右括号出栈，但是要比较出栈的元素和当前的右括号是否匹配，不匹配直接`return false`。最终判断栈是否为空即可。\n\n### 代码\n\n``` go\nfunc isValid(s string) bool {\n\tstack := arraystack.New()\n\tfor _, v := range s {\n\t\tswitch v {\n\t\tcase '(', '[', '{':\n\t\t\tstack.Push(v)\n\t\tcase ')':\n\t\t\ttemp, _ := stack.Pop()\n\t\t\tif temp == '(' {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase ']':\n\t\t\ttemp, _ := stack.Pop()\n\t\t\tif temp == '[' {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase '}':\n\t\t\ttemp, _ := stack.Pop()\n\t\t\tif temp == '{' {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn stack.Empty()\n}\n\n```\n\n## 1047.删除字符串中的所有相邻重复项\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html)\n>\n> 视频讲解：[栈的好戏还要继续！| LeetCode：1047. 删除字符串中的所有相邻重复项](https://www.bilibili.com/video/BV12a411P7mw)\n>\n> 状态：AC\n\n### 思路\n\n将每个元素与栈顶元素进行比较（前提是栈非空、如果空直接入栈即可），比较相等元素出栈。\n\n### 代码\n\n``` go\nfunc removeDuplicates(s string) string {\n\tif len(s) == 1 {\n\t\treturn s\n\t}\n\tbyteString := []rune(s)\n\tstack := arraystack.New()\n\tstack.Push(byteString[0])\n\n\tfor i := 1; i < len(byteString); i++ {\n\t\ttemp, _ := stack.Peek()\n\t\tif temp == byteString[i] {\n\t\t\tstack.Pop()\n\t\t} else {\n\t\t\tstack.Push(byteString[i])\n\t\t}\n\t}\n\tvar newByte []rune\n\tlength := stack.Size()\n\tfor i := 0; i < length; i++ {\n\t\ttemp, _ := stack.Pop()\n\t\ttemp1 := temp.(rune)\n\t\tnewByte = append(newByte, temp1)\n\t}\n\tfor i := 0; i < len(newByte)/2; i++ {\n\t\tnewByte[i], newByte[len(newByte)-1-i] = newByte[len(newByte)-1-i], newByte[i]\n\t}\n\treturn string(newByte)\n}\n```\n\n此处用的是一个真正意义上的数据结构的栈，存储的是单个字符，写起来还是很长，看了题解之后发现只用字符数组即可，改正后代码\n\n``` go\nfunc removeDuplicates(s string) string {\n\tvar stack []rune\n\tfor _, v := range s {\n\t\tif len(stack) > 0 && stack[len(stack)-1] == v {\n\t\t\tstack = stack[:len(stack)-1]\n\t\t} else {\n\t\t\tstack = append(stack, v)\n\t\t}\n\t}\n\treturn string(stack)\n}\n```\n\n## 150.逆波兰表达式\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)\n>\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html)\n>\n> 视频讲解：栈的最后表演！ | LeetCode：150. 逆波兰表达式求值](https://www.bilibili.com/video/BV1kd4y1o7on)\n>\n> 状态：AC\n\n### 思路\n\n明白题意之后，发现每次到运算符时候需要将前面两个数进行计算，如：`[\"a\", \"b\", \"+\"]`运算结果是`a+b`。不难想到要使用栈。\n\n先将字符串数组转换为数字，可以成功转换则入栈，否则出栈两个元素，并且将两个元素相加之后再重新入栈。\n\n### 代码\n\n``` go\n\nfunc EvalRPN(tokens []string) int {\n\tstack := arraystack.New()\n\tfor _, v := range tokens {\n\t\tnum, err := strconv.Atoi(v)\n\t\tif err == nil {  // 如果成功转换数字\n\t\t\tstack.Push(num)\n\t\t} else {  // 否则计算后重新入栈\n\t\t\tb, _ := stack.Pop()\n\t\t\ta, _ := stack.Pop()\n\t\t\tif v == \"+\" {\n\t\t\t\tstack.Push(a.(int) + b.(int))\n\t\t\t} else if v == \"-\" {\n\t\t\t\tstack.Push(a.(int) - b.(int))\n\t\t\t} else if v == \"*\" {\n\t\t\t\tstack.Push(a.(int) * b.(int))\n\t\t\t} else if v == \"/\" {\n\t\t\t\tstack.Push(a.(int) / b.(int))\n\t\t\t}\n\t\t}\n\t}\n\tresult, _ := stack.Peek()  // 此刻的栈顶为结果\n\treturn result.(int)\n}\n\n```\n\n","slug":"day11","published":1,"updated":"2023-10-03T12:15:36.432Z","_id":"clnaa9ei20000fowh95tf648u","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第十一天-20-有效的括号、1047-删除字符串中的所有相邻重复项、150-逆波兰表达式求值。\"><a href=\"#代码随想录算法训练营第十一天-20-有效的括号、1047-删除字符串中的所有相邻重复项、150-逆波兰表达式求值。\" class=\"headerlink\" title=\"代码随想录算法训练营第十一天 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值。\"></a>代码随想录算法训练营第十一天 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值。</h1><h2 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20.有效的括号\"></a>20.有效的括号</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/valid-parentheses/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1AF411w78g\">栈的拿手好戏！| LeetCode：20. 有效的括号</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>题目保证了输入的字符串只有括号。遇到左括号入栈，遇到右括号出栈，但是要比较出栈的元素和当前的右括号是否匹配，不匹配直接<code>return false</code>。最终判断栈是否为空即可。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isValid</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\tstack := arraystack.New()<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> s &#123;<br>\t\t<span class=\"hljs-keyword\">switch</span> v &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;(&#x27;</span>, <span class=\"hljs-string\">&#x27;[&#x27;</span>, <span class=\"hljs-string\">&#x27;&#123;&#x27;</span>:<br>\t\t\tstack.Push(v)<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;)&#x27;</span>:<br>\t\t\ttemp, _ := stack.Pop()<br>\t\t\t<span class=\"hljs-keyword\">if</span> temp == <span class=\"hljs-string\">&#x27;(&#x27;</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;]&#x27;</span>:<br>\t\t\ttemp, _ := stack.Pop()<br>\t\t\t<span class=\"hljs-keyword\">if</span> temp == <span class=\"hljs-string\">&#x27;[&#x27;</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;&#125;&#x27;</span>:<br>\t\t\ttemp, _ := stack.Pop()<br>\t\t\t<span class=\"hljs-keyword\">if</span> temp == <span class=\"hljs-string\">&#x27;&#123;&#x27;</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> stack.Empty()<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"1047-删除字符串中的所有相邻重复项\"><a href=\"#1047-删除字符串中的所有相邻重复项\" class=\"headerlink\" title=\"1047.删除字符串中的所有相邻重复项\"></a>1047.删除字符串中的所有相邻重复项</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV12a411P7mw\">栈的好戏还要继续！| LeetCode：1047. 删除字符串中的所有相邻重复项</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>将每个元素与栈顶元素进行比较（前提是栈非空、如果空直接入栈即可），比较相等元素出栈。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">removeDuplicates</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(s) == <span class=\"hljs-number\">1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> s<br>\t&#125;<br>\tbyteString := []<span class=\"hljs-type\">rune</span>(s)<br>\tstack := arraystack.New()<br>\tstack.Push(byteString[<span class=\"hljs-number\">0</span>])<br><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(byteString); i++ &#123;<br>\t\ttemp, _ := stack.Peek()<br>\t\t<span class=\"hljs-keyword\">if</span> temp == byteString[i] &#123;<br>\t\t\tstack.Pop()<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tstack.Push(byteString[i])<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">var</span> newByte []<span class=\"hljs-type\">rune</span><br>\tlength := stack.Size()<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; length; i++ &#123;<br>\t\ttemp, _ := stack.Pop()<br>\t\ttemp1 := temp.(<span class=\"hljs-type\">rune</span>)<br>\t\tnewByte = <span class=\"hljs-built_in\">append</span>(newByte, temp1)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(newByte)/<span class=\"hljs-number\">2</span>; i++ &#123;<br>\t\tnewByte[i], newByte[<span class=\"hljs-built_in\">len</span>(newByte)<span class=\"hljs-number\">-1</span>-i] = newByte[<span class=\"hljs-built_in\">len</span>(newByte)<span class=\"hljs-number\">-1</span>-i], newByte[i]<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">string</span>(newByte)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>此处用的是一个真正意义上的数据结构的栈，存储的是单个字符，写起来还是很长，看了题解之后发现只用字符数组即可，改正后代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">removeDuplicates</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> stack []<span class=\"hljs-type\">rune</span><br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> s &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(stack) &gt; <span class=\"hljs-number\">0</span> &amp;&amp; stack[<span class=\"hljs-built_in\">len</span>(stack)<span class=\"hljs-number\">-1</span>] == v &#123;<br>\t\t\tstack = stack[:<span class=\"hljs-built_in\">len</span>(stack)<span class=\"hljs-number\">-1</span>]<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tstack = <span class=\"hljs-built_in\">append</span>(stack, v)<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">string</span>(stack)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"150-逆波兰表达式\"><a href=\"#150-逆波兰表达式\" class=\"headerlink\" title=\"150.逆波兰表达式\"></a>150.逆波兰表达式</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/evaluate-reverse-polish-notation/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：栈的最后表演！ | LeetCode：150. 逆波兰表达式求值](<a href=\"https://www.bilibili.com/video/BV1kd4y1o7on\">https://www.bilibili.com/video/BV1kd4y1o7on</a>)</p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>明白题意之后，发现每次到运算符时候需要将前面两个数进行计算，如：<code>[&quot;a&quot;, &quot;b&quot;, &quot;+&quot;]</code>运算结果是<code>a+b</code>。不难想到要使用栈。</p>\n<p>先将字符串数组转换为数字，可以成功转换则入栈，否则出栈两个元素，并且将两个元素相加之后再重新入栈。</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">EvalRPN</span><span class=\"hljs-params\">(tokens []<span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tstack := arraystack.New()<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> tokens &#123;<br>\t\tnum, err := strconv.Atoi(v)<br>\t\t<span class=\"hljs-keyword\">if</span> err == <span class=\"hljs-literal\">nil</span> &#123;  <span class=\"hljs-comment\">// 如果成功转换数字</span><br>\t\t\tstack.Push(num)<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;  <span class=\"hljs-comment\">// 否则计算后重新入栈</span><br>\t\t\tb, _ := stack.Pop()<br>\t\t\ta, _ := stack.Pop()<br>\t\t\t<span class=\"hljs-keyword\">if</span> v == <span class=\"hljs-string\">&quot;+&quot;</span> &#123;<br>\t\t\t\tstack.Push(a.(<span class=\"hljs-type\">int</span>) + b.(<span class=\"hljs-type\">int</span>))<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> v == <span class=\"hljs-string\">&quot;-&quot;</span> &#123;<br>\t\t\t\tstack.Push(a.(<span class=\"hljs-type\">int</span>) - b.(<span class=\"hljs-type\">int</span>))<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> v == <span class=\"hljs-string\">&quot;*&quot;</span> &#123;<br>\t\t\t\tstack.Push(a.(<span class=\"hljs-type\">int</span>) * b.(<span class=\"hljs-type\">int</span>))<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> v == <span class=\"hljs-string\">&quot;/&quot;</span> &#123;<br>\t\t\t\tstack.Push(a.(<span class=\"hljs-type\">int</span>) / b.(<span class=\"hljs-type\">int</span>))<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\tresult, _ := stack.Peek()  <span class=\"hljs-comment\">// 此刻的栈顶为结果</span><br>\t<span class=\"hljs-keyword\">return</span> result.(<span class=\"hljs-type\">int</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第十一天-20-有效的括号、1047-删除字符串中的所有相邻重复项、150-逆波兰表达式求值。\"><a href=\"#代码随想录算法训练营第十一天-20-有效的括号、1047-删除字符串中的所有相邻重复项、150-逆波兰表达式求值。\" class=\"headerlink\" title=\"代码随想录算法训练营第十一天 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值。\"></a>代码随想录算法训练营第十一天 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值。</h1><h2 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20.有效的括号\"></a>20.有效的括号</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/valid-parentheses/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1AF411w78g\">栈的拿手好戏！| LeetCode：20. 有效的括号</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>题目保证了输入的字符串只有括号。遇到左括号入栈，遇到右括号出栈，但是要比较出栈的元素和当前的右括号是否匹配，不匹配直接<code>return false</code>。最终判断栈是否为空即可。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isValid</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\tstack := arraystack.New()<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> s &#123;<br>\t\t<span class=\"hljs-keyword\">switch</span> v &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;(&#x27;</span>, <span class=\"hljs-string\">&#x27;[&#x27;</span>, <span class=\"hljs-string\">&#x27;&#123;&#x27;</span>:<br>\t\t\tstack.Push(v)<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;)&#x27;</span>:<br>\t\t\ttemp, _ := stack.Pop()<br>\t\t\t<span class=\"hljs-keyword\">if</span> temp == <span class=\"hljs-string\">&#x27;(&#x27;</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;]&#x27;</span>:<br>\t\t\ttemp, _ := stack.Pop()<br>\t\t\t<span class=\"hljs-keyword\">if</span> temp == <span class=\"hljs-string\">&#x27;[&#x27;</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;&#125;&#x27;</span>:<br>\t\t\ttemp, _ := stack.Pop()<br>\t\t\t<span class=\"hljs-keyword\">if</span> temp == <span class=\"hljs-string\">&#x27;&#123;&#x27;</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">continue</span><br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> stack.Empty()<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"1047-删除字符串中的所有相邻重复项\"><a href=\"#1047-删除字符串中的所有相邻重复项\" class=\"headerlink\" title=\"1047.删除字符串中的所有相邻重复项\"></a>1047.删除字符串中的所有相邻重复项</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV12a411P7mw\">栈的好戏还要继续！| LeetCode：1047. 删除字符串中的所有相邻重复项</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>将每个元素与栈顶元素进行比较（前提是栈非空、如果空直接入栈即可），比较相等元素出栈。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">removeDuplicates</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(s) == <span class=\"hljs-number\">1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> s<br>\t&#125;<br>\tbyteString := []<span class=\"hljs-type\">rune</span>(s)<br>\tstack := arraystack.New()<br>\tstack.Push(byteString[<span class=\"hljs-number\">0</span>])<br><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(byteString); i++ &#123;<br>\t\ttemp, _ := stack.Peek()<br>\t\t<span class=\"hljs-keyword\">if</span> temp == byteString[i] &#123;<br>\t\t\tstack.Pop()<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tstack.Push(byteString[i])<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">var</span> newByte []<span class=\"hljs-type\">rune</span><br>\tlength := stack.Size()<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; length; i++ &#123;<br>\t\ttemp, _ := stack.Pop()<br>\t\ttemp1 := temp.(<span class=\"hljs-type\">rune</span>)<br>\t\tnewByte = <span class=\"hljs-built_in\">append</span>(newByte, temp1)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(newByte)/<span class=\"hljs-number\">2</span>; i++ &#123;<br>\t\tnewByte[i], newByte[<span class=\"hljs-built_in\">len</span>(newByte)<span class=\"hljs-number\">-1</span>-i] = newByte[<span class=\"hljs-built_in\">len</span>(newByte)<span class=\"hljs-number\">-1</span>-i], newByte[i]<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">string</span>(newByte)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>此处用的是一个真正意义上的数据结构的栈，存储的是单个字符，写起来还是很长，看了题解之后发现只用字符数组即可，改正后代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">removeDuplicates</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">string</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> stack []<span class=\"hljs-type\">rune</span><br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> s &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(stack) &gt; <span class=\"hljs-number\">0</span> &amp;&amp; stack[<span class=\"hljs-built_in\">len</span>(stack)<span class=\"hljs-number\">-1</span>] == v &#123;<br>\t\t\tstack = stack[:<span class=\"hljs-built_in\">len</span>(stack)<span class=\"hljs-number\">-1</span>]<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tstack = <span class=\"hljs-built_in\">append</span>(stack, v)<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">string</span>(stack)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"150-逆波兰表达式\"><a href=\"#150-逆波兰表达式\" class=\"headerlink\" title=\"150.逆波兰表达式\"></a>150.逆波兰表达式</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/evaluate-reverse-polish-notation/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：栈的最后表演！ | LeetCode：150. 逆波兰表达式求值](<a href=\"https://www.bilibili.com/video/BV1kd4y1o7on\">https://www.bilibili.com/video/BV1kd4y1o7on</a>)</p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>明白题意之后，发现每次到运算符时候需要将前面两个数进行计算，如：<code>[&quot;a&quot;, &quot;b&quot;, &quot;+&quot;]</code>运算结果是<code>a+b</code>。不难想到要使用栈。</p>\n<p>先将字符串数组转换为数字，可以成功转换则入栈，否则出栈两个元素，并且将两个元素相加之后再重新入栈。</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">EvalRPN</span><span class=\"hljs-params\">(tokens []<span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tstack := arraystack.New()<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> tokens &#123;<br>\t\tnum, err := strconv.Atoi(v)<br>\t\t<span class=\"hljs-keyword\">if</span> err == <span class=\"hljs-literal\">nil</span> &#123;  <span class=\"hljs-comment\">// 如果成功转换数字</span><br>\t\t\tstack.Push(num)<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;  <span class=\"hljs-comment\">// 否则计算后重新入栈</span><br>\t\t\tb, _ := stack.Pop()<br>\t\t\ta, _ := stack.Pop()<br>\t\t\t<span class=\"hljs-keyword\">if</span> v == <span class=\"hljs-string\">&quot;+&quot;</span> &#123;<br>\t\t\t\tstack.Push(a.(<span class=\"hljs-type\">int</span>) + b.(<span class=\"hljs-type\">int</span>))<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> v == <span class=\"hljs-string\">&quot;-&quot;</span> &#123;<br>\t\t\t\tstack.Push(a.(<span class=\"hljs-type\">int</span>) - b.(<span class=\"hljs-type\">int</span>))<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> v == <span class=\"hljs-string\">&quot;*&quot;</span> &#123;<br>\t\t\t\tstack.Push(a.(<span class=\"hljs-type\">int</span>) * b.(<span class=\"hljs-type\">int</span>))<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> v == <span class=\"hljs-string\">&quot;/&quot;</span> &#123;<br>\t\t\t\tstack.Push(a.(<span class=\"hljs-type\">int</span>) / b.(<span class=\"hljs-type\">int</span>))<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\tresult, _ := stack.Peek()  <span class=\"hljs-comment\">// 此刻的栈顶为结果</span><br>\t<span class=\"hljs-keyword\">return</span> result.(<span class=\"hljs-type\">int</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n"},{"title":"【study】Leetcode中Go语言第三方包","abbrlink":"2360e101","date":"2023-10-03T12:17:03.000Z","_content":"\n# 【study】Leetcode中Go语言第三方包\n\n在刷Leetcode时，发现Go并不像其他语言有原生的栈、队列等等结构。虽然很多操作都可以用**切片**或**数组**代替，但还是想知道如果自己想使用这些数据结构应该怎么办。\n\n![Leetcode中的Go](../images/【study】Leetcode中Go语言第三方包/Leetcode中的Go.png)\n\n![Leetcode支持Go的第三方库](../images/【study】Leetcode中Go语言第三方包/Leetcode支持Go的第三方库.png)\n\n[支持的库的连接](https://github.com/emirpasic/gods/tree/v1.18.1)\n\n\n\n包含的数据结构如下\n\n\n- Containers\n  - Lists\n    - ArrayList\n    - SinglyLinkedList\n    - DoublyLinkedList\n  - Sets\n    - HashSet\n    - TreeSet\n    - LinkedHashSet\n  - Stacks\n    - LinkedListStack\n    - ArrayStack\n  - Maps\n    - HashMap\n    - TreeMap\n    - LinkedHashMap\n    - HashBidiMap\n    - TreeBidiMap\n  - Trees\n    - RedBlackTree\n    - AVLTree\n    - BTree\n    - BinaryHeap\n  - Queues\n    - LinkedListQueue\n    - ArrayQueue\n    - CircularBuffer\n    - PriorityQueue\n- Functions\n    - Comparator\n    - Iterator\n      - IteratorWithIndex\n      - IteratorWithKey\n      - ReverseIteratorWithIndex\n      - ReverseIteratorWithKey\n    - Enumerable\n      - EnumerableWithIndex\n      - EnumerableWithKey\n    - Serialization\n      - JSONSerializer\n      - JSONDeserializer\n    - Sort\n    - Container\n- Appendix\n\n所有数据结构都依赖`Container`接口，调用起来也很方便\n\n### 以栈举例\n\n``` go\nimport \"github.com/emirpasic/gods/stacks/arraystack\"\n\nfunc main() {\n    stack = arraystack.New()  // 初始化一个栈\n    stack.Push(1)  // 入栈\n    value, _ := stack.Peek()  // 查看站定元素\n    value, _ := stack.Pop()  // 出栈\n    size := stack.Size()  // 栈的大小\n    isEmpty := stack.Empty()  // 是否为空栈\n    stack.Clear()  // 清空栈\n}\n```\n\n更多操作可以看github中的`README.md`文件或者看源码\n","source":"_posts/【study】Leetcode中Go语言第三方包.md","raw":"---\ntitle: 【study】Leetcode中Go语言第三方包\ntags:\n  - Study\n  - LeetCode\n  - Go\ncategories: Study\nabbrlink: '2360e101'\ndate: 2023-10-03 20:17:03\n---\n\n# 【study】Leetcode中Go语言第三方包\n\n在刷Leetcode时，发现Go并不像其他语言有原生的栈、队列等等结构。虽然很多操作都可以用**切片**或**数组**代替，但还是想知道如果自己想使用这些数据结构应该怎么办。\n\n![Leetcode中的Go](../images/【study】Leetcode中Go语言第三方包/Leetcode中的Go.png)\n\n![Leetcode支持Go的第三方库](../images/【study】Leetcode中Go语言第三方包/Leetcode支持Go的第三方库.png)\n\n[支持的库的连接](https://github.com/emirpasic/gods/tree/v1.18.1)\n\n\n\n包含的数据结构如下\n\n\n- Containers\n  - Lists\n    - ArrayList\n    - SinglyLinkedList\n    - DoublyLinkedList\n  - Sets\n    - HashSet\n    - TreeSet\n    - LinkedHashSet\n  - Stacks\n    - LinkedListStack\n    - ArrayStack\n  - Maps\n    - HashMap\n    - TreeMap\n    - LinkedHashMap\n    - HashBidiMap\n    - TreeBidiMap\n  - Trees\n    - RedBlackTree\n    - AVLTree\n    - BTree\n    - BinaryHeap\n  - Queues\n    - LinkedListQueue\n    - ArrayQueue\n    - CircularBuffer\n    - PriorityQueue\n- Functions\n    - Comparator\n    - Iterator\n      - IteratorWithIndex\n      - IteratorWithKey\n      - ReverseIteratorWithIndex\n      - ReverseIteratorWithKey\n    - Enumerable\n      - EnumerableWithIndex\n      - EnumerableWithKey\n    - Serialization\n      - JSONSerializer\n      - JSONDeserializer\n    - Sort\n    - Container\n- Appendix\n\n所有数据结构都依赖`Container`接口，调用起来也很方便\n\n### 以栈举例\n\n``` go\nimport \"github.com/emirpasic/gods/stacks/arraystack\"\n\nfunc main() {\n    stack = arraystack.New()  // 初始化一个栈\n    stack.Push(1)  // 入栈\n    value, _ := stack.Peek()  // 查看站定元素\n    value, _ := stack.Pop()  // 出栈\n    size := stack.Size()  // 栈的大小\n    isEmpty := stack.Empty()  // 是否为空栈\n    stack.Clear()  // 清空栈\n}\n```\n\n更多操作可以看github中的`README.md`文件或者看源码\n","slug":"【study】Leetcode中Go语言第三方包","published":1,"updated":"2023-10-03T12:35:50.313Z","_id":"clnaazf5b0000r4whg2w0by34","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"【study】Leetcode中Go语言第三方包\"><a href=\"#【study】Leetcode中Go语言第三方包\" class=\"headerlink\" title=\"【study】Leetcode中Go语言第三方包\"></a>【study】Leetcode中Go语言第三方包</h1><p>在刷Leetcode时，发现Go并不像其他语言有原生的栈、队列等等结构。虽然很多操作都可以用<strong>切片</strong>或<strong>数组</strong>代替，但还是想知道如果自己想使用这些数据结构应该怎么办。</p>\n<p><img src=\"/../images/%E3%80%90study%E3%80%91Leetcode%E4%B8%ADGo%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/Leetcode%E4%B8%AD%E7%9A%84Go.png\" alt=\"Leetcode中的Go\"></p>\n<p><img src=\"/../images/%E3%80%90study%E3%80%91Leetcode%E4%B8%ADGo%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/Leetcode%E6%94%AF%E6%8C%81Go%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93.png\" alt=\"Leetcode支持Go的第三方库\"></p>\n<p><a href=\"https://github.com/emirpasic/gods/tree/v1.18.1\">支持的库的连接</a></p>\n<p>包含的数据结构如下</p>\n<ul>\n<li>Containers<ul>\n<li>Lists<ul>\n<li>ArrayList</li>\n<li>SinglyLinkedList</li>\n<li>DoublyLinkedList</li>\n</ul>\n</li>\n<li>Sets<ul>\n<li>HashSet</li>\n<li>TreeSet</li>\n<li>LinkedHashSet</li>\n</ul>\n</li>\n<li>Stacks<ul>\n<li>LinkedListStack</li>\n<li>ArrayStack</li>\n</ul>\n</li>\n<li>Maps<ul>\n<li>HashMap</li>\n<li>TreeMap</li>\n<li>LinkedHashMap</li>\n<li>HashBidiMap</li>\n<li>TreeBidiMap</li>\n</ul>\n</li>\n<li>Trees<ul>\n<li>RedBlackTree</li>\n<li>AVLTree</li>\n<li>BTree</li>\n<li>BinaryHeap</li>\n</ul>\n</li>\n<li>Queues<ul>\n<li>LinkedListQueue</li>\n<li>ArrayQueue</li>\n<li>CircularBuffer</li>\n<li>PriorityQueue</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Functions<ul>\n<li>Comparator</li>\n<li>Iterator<ul>\n<li>IteratorWithIndex</li>\n<li>IteratorWithKey</li>\n<li>ReverseIteratorWithIndex</li>\n<li>ReverseIteratorWithKey</li>\n</ul>\n</li>\n<li>Enumerable<ul>\n<li>EnumerableWithIndex</li>\n<li>EnumerableWithKey</li>\n</ul>\n</li>\n<li>Serialization<ul>\n<li>JSONSerializer</li>\n<li>JSONDeserializer</li>\n</ul>\n</li>\n<li>Sort</li>\n<li>Container</li>\n</ul>\n</li>\n<li>Appendix</li>\n</ul>\n<p>所有数据结构都依赖<code>Container</code>接口，调用起来也很方便</p>\n<h3 id=\"以栈举例\"><a href=\"#以栈举例\" class=\"headerlink\" title=\"以栈举例\"></a>以栈举例</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;github.com/emirpasic/gods/stacks/arraystack&quot;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    stack = arraystack.New()  <span class=\"hljs-comment\">// 初始化一个栈</span><br>    stack.Push(<span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\">// 入栈</span><br>    value, _ := stack.Peek()  <span class=\"hljs-comment\">// 查看站定元素</span><br>    value, _ := stack.Pop()  <span class=\"hljs-comment\">// 出栈</span><br>    size := stack.Size()  <span class=\"hljs-comment\">// 栈的大小</span><br>    isEmpty := stack.Empty()  <span class=\"hljs-comment\">// 是否为空栈</span><br>    stack.Clear()  <span class=\"hljs-comment\">// 清空栈</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>更多操作可以看github中的<code>README.md</code>文件或者看源码</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"【study】Leetcode中Go语言第三方包\"><a href=\"#【study】Leetcode中Go语言第三方包\" class=\"headerlink\" title=\"【study】Leetcode中Go语言第三方包\"></a>【study】Leetcode中Go语言第三方包</h1><p>在刷Leetcode时，发现Go并不像其他语言有原生的栈、队列等等结构。虽然很多操作都可以用<strong>切片</strong>或<strong>数组</strong>代替，但还是想知道如果自己想使用这些数据结构应该怎么办。</p>\n<p><img src=\"/../images/%E3%80%90study%E3%80%91Leetcode%E4%B8%ADGo%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/Leetcode%E4%B8%AD%E7%9A%84Go.png\" alt=\"Leetcode中的Go\"></p>\n<p><img src=\"/../images/%E3%80%90study%E3%80%91Leetcode%E4%B8%ADGo%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/Leetcode%E6%94%AF%E6%8C%81Go%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93.png\" alt=\"Leetcode支持Go的第三方库\"></p>\n<p><a href=\"https://github.com/emirpasic/gods/tree/v1.18.1\">支持的库的连接</a></p>\n<p>包含的数据结构如下</p>\n<ul>\n<li>Containers<ul>\n<li>Lists<ul>\n<li>ArrayList</li>\n<li>SinglyLinkedList</li>\n<li>DoublyLinkedList</li>\n</ul>\n</li>\n<li>Sets<ul>\n<li>HashSet</li>\n<li>TreeSet</li>\n<li>LinkedHashSet</li>\n</ul>\n</li>\n<li>Stacks<ul>\n<li>LinkedListStack</li>\n<li>ArrayStack</li>\n</ul>\n</li>\n<li>Maps<ul>\n<li>HashMap</li>\n<li>TreeMap</li>\n<li>LinkedHashMap</li>\n<li>HashBidiMap</li>\n<li>TreeBidiMap</li>\n</ul>\n</li>\n<li>Trees<ul>\n<li>RedBlackTree</li>\n<li>AVLTree</li>\n<li>BTree</li>\n<li>BinaryHeap</li>\n</ul>\n</li>\n<li>Queues<ul>\n<li>LinkedListQueue</li>\n<li>ArrayQueue</li>\n<li>CircularBuffer</li>\n<li>PriorityQueue</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Functions<ul>\n<li>Comparator</li>\n<li>Iterator<ul>\n<li>IteratorWithIndex</li>\n<li>IteratorWithKey</li>\n<li>ReverseIteratorWithIndex</li>\n<li>ReverseIteratorWithKey</li>\n</ul>\n</li>\n<li>Enumerable<ul>\n<li>EnumerableWithIndex</li>\n<li>EnumerableWithKey</li>\n</ul>\n</li>\n<li>Serialization<ul>\n<li>JSONSerializer</li>\n<li>JSONDeserializer</li>\n</ul>\n</li>\n<li>Sort</li>\n<li>Container</li>\n</ul>\n</li>\n<li>Appendix</li>\n</ul>\n<p>所有数据结构都依赖<code>Container</code>接口，调用起来也很方便</p>\n<h3 id=\"以栈举例\"><a href=\"#以栈举例\" class=\"headerlink\" title=\"以栈举例\"></a>以栈举例</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;github.com/emirpasic/gods/stacks/arraystack&quot;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    stack = arraystack.New()  <span class=\"hljs-comment\">// 初始化一个栈</span><br>    stack.Push(<span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\">// 入栈</span><br>    value, _ := stack.Peek()  <span class=\"hljs-comment\">// 查看站定元素</span><br>    value, _ := stack.Pop()  <span class=\"hljs-comment\">// 出栈</span><br>    size := stack.Size()  <span class=\"hljs-comment\">// 栈的大小</span><br>    isEmpty := stack.Empty()  <span class=\"hljs-comment\">// 是否为空栈</span><br>    stack.Clear()  <span class=\"hljs-comment\">// 清空栈</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>更多操作可以看github中的<code>README.md</code>文件或者看源码</p>\n"},{"title":"代码随想录算法训练营第十二天 239.滑动窗口最大值、347.前K个高频元素。","abbrlink":"9ab3b9d2","date":"2023-10-04T11:45:02.000Z","_content":"\n# 代码随想录算法训练营第十二天 239.滑动窗口最大值、347.前K个高频元素。\n\n## 239.滑动窗口最大值\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/sliding-window-maximum/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html)\n>\n>   视频讲解：[单调队列正式登场！| LeetCode：239. 滑动窗口最大值](https://www.bilibili.com/video/BV1XS4y1p7qj)\n>\n>   状态：TLE\n\n### 思路\n\n#### 方法一\n\n遍历每个滑动窗口（看作一个队列），升序排序后取最大（复制一段新的数组，在新的里面排序）。时间复杂度为O(n^2log n)。超时\n\n#### 方法二（卡哥讲解）\n\n1.   准备一个自定义的双向队列数据结构，让其中的`front`端保持最大值，并且重构`Pop()`和`Push()`操作。\n2.   先将前K的元素`Push()`入队，但是要进行判断。如果后入队的元素大于之前入队的元素，那么之前的元素`PopBack()`。可以保持`front`端一直为最大。\n3.   `Pop()`除了最大值的所有元素\n4.   `Push()`一个新的元素\n5.   `GetMaxValue()`，并且加入到结果切片中\n6.   重复3\\~5直至`nums`结尾\n\n### 代码\n\n#### 重构两个函数，新增功能GetMaxValue()\n\n-   `GetMaxValue()`：会保持在队列`front`的位置，可以使用`Front()`操作取代。\n\n``` go\nfunc (this *Deque) Front() int {\n\treturn this.queue[0]\n}\n```\n\n-   `Pop()`：出队时，只有一种情况，旧的最大值不在新的滑动窗口内，旧的最大值出队（切片舍去第一个元素）\n\n``` go\nfunc (this *Deque) Pop(value int) {\n\tif !this.Empty() && value == this.Front() {\n\t\tthis.queue = this.queue[1:]\n\t}\n}\n```\n\n-   `Push()`：入队时，如果入队的值`value`大于队列`back`位置的元素，让该元素`PopBack()`（切片舍去最后一个元素）\n\n``` go\nfunc (this *Deque) Push(value int) {\n\tfor !this.Empty() && value > this.Back() {\n\t\tthis.queue = this.queue[:len(this.queue)-1]\n\t}\n\tthis.queue = append(this.queue, value)\n}\n```\n\n### 代码\n\n``` go\ntype Deque struct {\n\tqueue []int\n}\n\nfunc Constructor() *Deque {\n\treturn &Deque{queue: make([]int, 0)}\n}\n\nfunc (this *Deque) Front() int {\n\treturn this.queue[0]\n}\n\nfunc (this *Deque) Back() int {\n\treturn this.queue[len(this.queue)-1]\n}\n\nfunc (this *Deque) Empty() bool {\n\treturn len(this.queue) == 0\n}\n\nfunc (this *Deque) Push(value int) {\n\tfor !this.Empty() && value > this.Back() {\n\t\tthis.queue = this.queue[:len(this.queue)-1]\n\t}\n\tthis.queue = append(this.queue, value)\n}\n\nfunc (this *Deque) Pop(value int) {\n\tif !this.Empty() && value == this.Front() {\n\t\tthis.queue = this.queue[1:]\n\t}\n}\n\nfunc maxSlidingWindow(nums []int, k int) []int {\n\tdeque := Constructor()\n\tvar result []int\n\tfor i := 0; i < k; i++ {\n\t\tdeque.Push(nums[i])\n\t}\n\tresult = append(result, deque.Front())\n\tfor i := k; i < len(nums); i++ {\n\t\tdeque.Pop(nums[i-k])\n\t\tdeque.Push(nums[i])\n\t\tresult = append(result, deque.Front())\n\t}\n\treturn result\n}\n```\n\n## 347. 前K个高频元素\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/top-k-frequent-elements/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html)\n>\n>   视频讲解：[优先级队列正式登场！大顶堆、小顶堆该怎么用？| LeetCode：347.前 K 个高频元素](https://www.bilibili.com/video/BV1Xg41167Lz)\n>\n>   状态：AC\n\n### 思路\n\n1.   构建键值对<key, value>，`key`为数字，`value`为该数字出现的次数。\n2.   生成优先队列，优先级为`value`\n3.   取优先队列的前K个元素\n\n### 代码\n\n``` go\n// 优先队列中的条目\ntype Element struct {\n\tNum     int\n\tCount   int\n}\n// 比较器函数，根据Count降序\nfunc byPriority(a, b interface{}) int {\n\tpriorityA := a.(Element).Count\n\tpriorityB := b.(Element).Count\n\treturn -utils.IntComparator(priorityA, priorityB) // \"-\" 代表降序\n}\n\nfunc topKFrequent(nums []int, k int) []int {\n\t// 构建键值对\n    maps := map[int]int{}\n\tfor _, v := range nums {\n\t\tmaps[v]++\n\t}\n    // 初始化优先队列\n\tpq := priorityqueue.NewWith(byPriority)\n\tfor k, v := range maps {\n\t\tpq.Enqueue(Element{\n\t\t\tNum:     k,\n\t\t\tCount: v,\n\t\t})\n\t}\n\tvar result []int\n    // 取前k个元素保存到result中\n\tfor i := 0; i < k; i++ {\n\t\tvalue, _ := pq.Dequeue()\n\t\tresult = append(result, value.(Element).Num)\n\t}\n\treturn result\n}\n```\n\n","source":"_posts/day12.md","raw":"---\ntitle: 代码随想录算法训练营第十二天 239.滑动窗口最大值、347.前K个高频元素。\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: 9ab3b9d2\ndate: 2023-10-04 19:45:02\n---\n\n# 代码随想录算法训练营第十二天 239.滑动窗口最大值、347.前K个高频元素。\n\n## 239.滑动窗口最大值\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/sliding-window-maximum/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html)\n>\n>   视频讲解：[单调队列正式登场！| LeetCode：239. 滑动窗口最大值](https://www.bilibili.com/video/BV1XS4y1p7qj)\n>\n>   状态：TLE\n\n### 思路\n\n#### 方法一\n\n遍历每个滑动窗口（看作一个队列），升序排序后取最大（复制一段新的数组，在新的里面排序）。时间复杂度为O(n^2log n)。超时\n\n#### 方法二（卡哥讲解）\n\n1.   准备一个自定义的双向队列数据结构，让其中的`front`端保持最大值，并且重构`Pop()`和`Push()`操作。\n2.   先将前K的元素`Push()`入队，但是要进行判断。如果后入队的元素大于之前入队的元素，那么之前的元素`PopBack()`。可以保持`front`端一直为最大。\n3.   `Pop()`除了最大值的所有元素\n4.   `Push()`一个新的元素\n5.   `GetMaxValue()`，并且加入到结果切片中\n6.   重复3\\~5直至`nums`结尾\n\n### 代码\n\n#### 重构两个函数，新增功能GetMaxValue()\n\n-   `GetMaxValue()`：会保持在队列`front`的位置，可以使用`Front()`操作取代。\n\n``` go\nfunc (this *Deque) Front() int {\n\treturn this.queue[0]\n}\n```\n\n-   `Pop()`：出队时，只有一种情况，旧的最大值不在新的滑动窗口内，旧的最大值出队（切片舍去第一个元素）\n\n``` go\nfunc (this *Deque) Pop(value int) {\n\tif !this.Empty() && value == this.Front() {\n\t\tthis.queue = this.queue[1:]\n\t}\n}\n```\n\n-   `Push()`：入队时，如果入队的值`value`大于队列`back`位置的元素，让该元素`PopBack()`（切片舍去最后一个元素）\n\n``` go\nfunc (this *Deque) Push(value int) {\n\tfor !this.Empty() && value > this.Back() {\n\t\tthis.queue = this.queue[:len(this.queue)-1]\n\t}\n\tthis.queue = append(this.queue, value)\n}\n```\n\n### 代码\n\n``` go\ntype Deque struct {\n\tqueue []int\n}\n\nfunc Constructor() *Deque {\n\treturn &Deque{queue: make([]int, 0)}\n}\n\nfunc (this *Deque) Front() int {\n\treturn this.queue[0]\n}\n\nfunc (this *Deque) Back() int {\n\treturn this.queue[len(this.queue)-1]\n}\n\nfunc (this *Deque) Empty() bool {\n\treturn len(this.queue) == 0\n}\n\nfunc (this *Deque) Push(value int) {\n\tfor !this.Empty() && value > this.Back() {\n\t\tthis.queue = this.queue[:len(this.queue)-1]\n\t}\n\tthis.queue = append(this.queue, value)\n}\n\nfunc (this *Deque) Pop(value int) {\n\tif !this.Empty() && value == this.Front() {\n\t\tthis.queue = this.queue[1:]\n\t}\n}\n\nfunc maxSlidingWindow(nums []int, k int) []int {\n\tdeque := Constructor()\n\tvar result []int\n\tfor i := 0; i < k; i++ {\n\t\tdeque.Push(nums[i])\n\t}\n\tresult = append(result, deque.Front())\n\tfor i := k; i < len(nums); i++ {\n\t\tdeque.Pop(nums[i-k])\n\t\tdeque.Push(nums[i])\n\t\tresult = append(result, deque.Front())\n\t}\n\treturn result\n}\n```\n\n## 347. 前K个高频元素\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/top-k-frequent-elements/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html)\n>\n>   视频讲解：[优先级队列正式登场！大顶堆、小顶堆该怎么用？| LeetCode：347.前 K 个高频元素](https://www.bilibili.com/video/BV1Xg41167Lz)\n>\n>   状态：AC\n\n### 思路\n\n1.   构建键值对<key, value>，`key`为数字，`value`为该数字出现的次数。\n2.   生成优先队列，优先级为`value`\n3.   取优先队列的前K个元素\n\n### 代码\n\n``` go\n// 优先队列中的条目\ntype Element struct {\n\tNum     int\n\tCount   int\n}\n// 比较器函数，根据Count降序\nfunc byPriority(a, b interface{}) int {\n\tpriorityA := a.(Element).Count\n\tpriorityB := b.(Element).Count\n\treturn -utils.IntComparator(priorityA, priorityB) // \"-\" 代表降序\n}\n\nfunc topKFrequent(nums []int, k int) []int {\n\t// 构建键值对\n    maps := map[int]int{}\n\tfor _, v := range nums {\n\t\tmaps[v]++\n\t}\n    // 初始化优先队列\n\tpq := priorityqueue.NewWith(byPriority)\n\tfor k, v := range maps {\n\t\tpq.Enqueue(Element{\n\t\t\tNum:     k,\n\t\t\tCount: v,\n\t\t})\n\t}\n\tvar result []int\n    // 取前k个元素保存到result中\n\tfor i := 0; i < k; i++ {\n\t\tvalue, _ := pq.Dequeue()\n\t\tresult = append(result, value.(Element).Num)\n\t}\n\treturn result\n}\n```\n\n","slug":"day12","published":1,"updated":"2023-10-04T16:30:05.000Z","_id":"clnbysihy0000zez810crdqln","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第十二天-239-滑动窗口最大值、347-前K个高频元素。\"><a href=\"#代码随想录算法训练营第十二天-239-滑动窗口最大值、347-前K个高频元素。\" class=\"headerlink\" title=\"代码随想录算法训练营第十二天 239.滑动窗口最大值、347.前K个高频元素。\"></a>代码随想录算法训练营第十二天 239.滑动窗口最大值、347.前K个高频元素。</h1><h2 id=\"239-滑动窗口最大值\"><a href=\"#239-滑动窗口最大值\" class=\"headerlink\" title=\"239.滑动窗口最大值\"></a>239.滑动窗口最大值</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/sliding-window-maximum/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1XS4y1p7qj\">单调队列正式登场！| LeetCode：239. 滑动窗口最大值</a></p>\n<p>  状态：TLE</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>遍历每个滑动窗口（看作一个队列），升序排序后取最大（复制一段新的数组，在新的里面排序）。时间复杂度为O(n^2log n)。超时</p>\n<h4 id=\"方法二（卡哥讲解）\"><a href=\"#方法二（卡哥讲解）\" class=\"headerlink\" title=\"方法二（卡哥讲解）\"></a>方法二（卡哥讲解）</h4><ol>\n<li>准备一个自定义的双向队列数据结构，让其中的<code>front</code>端保持最大值，并且重构<code>Pop()</code>和<code>Push()</code>操作。</li>\n<li>先将前K的元素<code>Push()</code>入队，但是要进行判断。如果后入队的元素大于之前入队的元素，那么之前的元素<code>PopBack()</code>。可以保持<code>front</code>端一直为最大。</li>\n<li><code>Pop()</code>除了最大值的所有元素</li>\n<li><code>Push()</code>一个新的元素</li>\n<li><code>GetMaxValue()</code>，并且加入到结果切片中</li>\n<li>重复3~5直至<code>nums</code>结尾</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><h4 id=\"重构两个函数，新增功能GetMaxValue\"><a href=\"#重构两个函数，新增功能GetMaxValue\" class=\"headerlink\" title=\"重构两个函数，新增功能GetMaxValue()\"></a>重构两个函数，新增功能GetMaxValue()</h4><ul>\n<li><code>GetMaxValue()</code>：会保持在队列<code>front</code>的位置，可以使用<code>Front()</code>操作取代。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Front() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> this.queue[<span class=\"hljs-number\">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Pop()</code>：出队时，只有一种情况，旧的最大值不在新的滑动窗口内，旧的最大值出队（切片舍去第一个元素）</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Pop(value <span class=\"hljs-type\">int</span>) &#123;<br>\t<span class=\"hljs-keyword\">if</span> !this.Empty() &amp;&amp; value == this.Front() &#123;<br>\t\tthis.queue = this.queue[<span class=\"hljs-number\">1</span>:]<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Push()</code>：入队时，如果入队的值<code>value</code>大于队列<code>back</code>位置的元素，让该元素<code>PopBack()</code>（切片舍去最后一个元素）</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Push(value <span class=\"hljs-type\">int</span>) &#123;<br>\t<span class=\"hljs-keyword\">for</span> !this.Empty() &amp;&amp; value &gt; this.Back() &#123;<br>\t\tthis.queue = this.queue[:<span class=\"hljs-built_in\">len</span>(this.queue)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>\tthis.queue = <span class=\"hljs-built_in\">append</span>(this.queue, value)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Deque <span class=\"hljs-keyword\">struct</span> &#123;<br>\tqueue []<span class=\"hljs-type\">int</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">()</span></span> *Deque &#123;<br>\t<span class=\"hljs-keyword\">return</span> &amp;Deque&#123;queue: <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">0</span>)&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Front() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> this.queue[<span class=\"hljs-number\">0</span>]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Back() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> this.queue[<span class=\"hljs-built_in\">len</span>(this.queue)<span class=\"hljs-number\">-1</span>]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Empty() <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(this.queue) == <span class=\"hljs-number\">0</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Push(value <span class=\"hljs-type\">int</span>) &#123;<br>\t<span class=\"hljs-keyword\">for</span> !this.Empty() &amp;&amp; value &gt; this.Back() &#123;<br>\t\tthis.queue = this.queue[:<span class=\"hljs-built_in\">len</span>(this.queue)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>\tthis.queue = <span class=\"hljs-built_in\">append</span>(this.queue, value)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Pop(value <span class=\"hljs-type\">int</span>) &#123;<br>\t<span class=\"hljs-keyword\">if</span> !this.Empty() &amp;&amp; value == this.Front() &#123;<br>\t\tthis.queue = this.queue[<span class=\"hljs-number\">1</span>:]<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxSlidingWindow</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, k <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tdeque := Constructor()<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; k; i++ &#123;<br>\t\tdeque.Push(nums[i])<br>\t&#125;<br>\tresult = <span class=\"hljs-built_in\">append</span>(result, deque.Front())<br>\t<span class=\"hljs-keyword\">for</span> i := k; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>\t\tdeque.Pop(nums[i-k])<br>\t\tdeque.Push(nums[i])<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, deque.Front())<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"347-前K个高频元素\"><a href=\"#347-前K个高频元素\" class=\"headerlink\" title=\"347. 前K个高频元素\"></a>347. 前K个高频元素</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/top-k-frequent-elements/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1Xg41167Lz\">优先级队列正式登场！大顶堆、小顶堆该怎么用？| LeetCode：347.前 K 个高频元素</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>构建键值对&lt;key, value&gt;，<code>key</code>为数字，<code>value</code>为该数字出现的次数。</li>\n<li>生成优先队列，优先级为<code>value</code></li>\n<li>取优先队列的前K个元素</li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 优先队列中的条目</span><br><span class=\"hljs-keyword\">type</span> Element <span class=\"hljs-keyword\">struct</span> &#123;<br>\tNum     <span class=\"hljs-type\">int</span><br>\tCount   <span class=\"hljs-type\">int</span><br>&#125;<br><span class=\"hljs-comment\">// 比较器函数，根据Count降序</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">byPriority</span><span class=\"hljs-params\">(a, b <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tpriorityA := a.(Element).Count<br>\tpriorityB := b.(Element).Count<br>\t<span class=\"hljs-keyword\">return</span> -utils.IntComparator(priorityA, priorityB) <span class=\"hljs-comment\">// &quot;-&quot; 代表降序</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">topKFrequent</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, k <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-comment\">// 构建键值对</span><br>    maps := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>\t\tmaps[v]++<br>\t&#125;<br>    <span class=\"hljs-comment\">// 初始化优先队列</span><br>\tpq := priorityqueue.NewWith(byPriority)<br>\t<span class=\"hljs-keyword\">for</span> k, v := <span class=\"hljs-keyword\">range</span> maps &#123;<br>\t\tpq.Enqueue(Element&#123;<br>\t\t\tNum:     k,<br>\t\t\tCount: v,<br>\t\t&#125;)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>    <span class=\"hljs-comment\">// 取前k个元素保存到result中</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; k; i++ &#123;<br>\t\tvalue, _ := pq.Dequeue()<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, value.(Element).Num)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第十二天-239-滑动窗口最大值、347-前K个高频元素。\"><a href=\"#代码随想录算法训练营第十二天-239-滑动窗口最大值、347-前K个高频元素。\" class=\"headerlink\" title=\"代码随想录算法训练营第十二天 239.滑动窗口最大值、347.前K个高频元素。\"></a>代码随想录算法训练营第十二天 239.滑动窗口最大值、347.前K个高频元素。</h1><h2 id=\"239-滑动窗口最大值\"><a href=\"#239-滑动窗口最大值\" class=\"headerlink\" title=\"239.滑动窗口最大值\"></a>239.滑动窗口最大值</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/sliding-window-maximum/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1XS4y1p7qj\">单调队列正式登场！| LeetCode：239. 滑动窗口最大值</a></p>\n<p>  状态：TLE</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>遍历每个滑动窗口（看作一个队列），升序排序后取最大（复制一段新的数组，在新的里面排序）。时间复杂度为O(n^2log n)。超时</p>\n<h4 id=\"方法二（卡哥讲解）\"><a href=\"#方法二（卡哥讲解）\" class=\"headerlink\" title=\"方法二（卡哥讲解）\"></a>方法二（卡哥讲解）</h4><ol>\n<li>准备一个自定义的双向队列数据结构，让其中的<code>front</code>端保持最大值，并且重构<code>Pop()</code>和<code>Push()</code>操作。</li>\n<li>先将前K的元素<code>Push()</code>入队，但是要进行判断。如果后入队的元素大于之前入队的元素，那么之前的元素<code>PopBack()</code>。可以保持<code>front</code>端一直为最大。</li>\n<li><code>Pop()</code>除了最大值的所有元素</li>\n<li><code>Push()</code>一个新的元素</li>\n<li><code>GetMaxValue()</code>，并且加入到结果切片中</li>\n<li>重复3~5直至<code>nums</code>结尾</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><h4 id=\"重构两个函数，新增功能GetMaxValue\"><a href=\"#重构两个函数，新增功能GetMaxValue\" class=\"headerlink\" title=\"重构两个函数，新增功能GetMaxValue()\"></a>重构两个函数，新增功能GetMaxValue()</h4><ul>\n<li><code>GetMaxValue()</code>：会保持在队列<code>front</code>的位置，可以使用<code>Front()</code>操作取代。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Front() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> this.queue[<span class=\"hljs-number\">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Pop()</code>：出队时，只有一种情况，旧的最大值不在新的滑动窗口内，旧的最大值出队（切片舍去第一个元素）</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Pop(value <span class=\"hljs-type\">int</span>) &#123;<br>\t<span class=\"hljs-keyword\">if</span> !this.Empty() &amp;&amp; value == this.Front() &#123;<br>\t\tthis.queue = this.queue[<span class=\"hljs-number\">1</span>:]<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Push()</code>：入队时，如果入队的值<code>value</code>大于队列<code>back</code>位置的元素，让该元素<code>PopBack()</code>（切片舍去最后一个元素）</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Push(value <span class=\"hljs-type\">int</span>) &#123;<br>\t<span class=\"hljs-keyword\">for</span> !this.Empty() &amp;&amp; value &gt; this.Back() &#123;<br>\t\tthis.queue = this.queue[:<span class=\"hljs-built_in\">len</span>(this.queue)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>\tthis.queue = <span class=\"hljs-built_in\">append</span>(this.queue, value)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Deque <span class=\"hljs-keyword\">struct</span> &#123;<br>\tqueue []<span class=\"hljs-type\">int</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Constructor</span><span class=\"hljs-params\">()</span></span> *Deque &#123;<br>\t<span class=\"hljs-keyword\">return</span> &amp;Deque&#123;queue: <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">0</span>)&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Front() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> this.queue[<span class=\"hljs-number\">0</span>]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Back() <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> this.queue[<span class=\"hljs-built_in\">len</span>(this.queue)<span class=\"hljs-number\">-1</span>]<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Empty() <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(this.queue) == <span class=\"hljs-number\">0</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Push(value <span class=\"hljs-type\">int</span>) &#123;<br>\t<span class=\"hljs-keyword\">for</span> !this.Empty() &amp;&amp; value &gt; this.Back() &#123;<br>\t\tthis.queue = this.queue[:<span class=\"hljs-built_in\">len</span>(this.queue)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>\tthis.queue = <span class=\"hljs-built_in\">append</span>(this.queue, value)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(this *Deque)</span></span> Pop(value <span class=\"hljs-type\">int</span>) &#123;<br>\t<span class=\"hljs-keyword\">if</span> !this.Empty() &amp;&amp; value == this.Front() &#123;<br>\t\tthis.queue = this.queue[<span class=\"hljs-number\">1</span>:]<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxSlidingWindow</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, k <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tdeque := Constructor()<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; k; i++ &#123;<br>\t\tdeque.Push(nums[i])<br>\t&#125;<br>\tresult = <span class=\"hljs-built_in\">append</span>(result, deque.Front())<br>\t<span class=\"hljs-keyword\">for</span> i := k; i &lt; <span class=\"hljs-built_in\">len</span>(nums); i++ &#123;<br>\t\tdeque.Pop(nums[i-k])<br>\t\tdeque.Push(nums[i])<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, deque.Front())<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"347-前K个高频元素\"><a href=\"#347-前K个高频元素\" class=\"headerlink\" title=\"347. 前K个高频元素\"></a>347. 前K个高频元素</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/top-k-frequent-elements/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1Xg41167Lz\">优先级队列正式登场！大顶堆、小顶堆该怎么用？| LeetCode：347.前 K 个高频元素</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>构建键值对&lt;key, value&gt;，<code>key</code>为数字，<code>value</code>为该数字出现的次数。</li>\n<li>生成优先队列，优先级为<code>value</code></li>\n<li>取优先队列的前K个元素</li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 优先队列中的条目</span><br><span class=\"hljs-keyword\">type</span> Element <span class=\"hljs-keyword\">struct</span> &#123;<br>\tNum     <span class=\"hljs-type\">int</span><br>\tCount   <span class=\"hljs-type\">int</span><br>&#125;<br><span class=\"hljs-comment\">// 比较器函数，根据Count降序</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">byPriority</span><span class=\"hljs-params\">(a, b <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tpriorityA := a.(Element).Count<br>\tpriorityB := b.(Element).Count<br>\t<span class=\"hljs-keyword\">return</span> -utils.IntComparator(priorityA, priorityB) <span class=\"hljs-comment\">// &quot;-&quot; 代表降序</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">topKFrequent</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, k <span class=\"hljs-type\">int</span>)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-comment\">// 构建键值对</span><br>    maps := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>\t\tmaps[v]++<br>\t&#125;<br>    <span class=\"hljs-comment\">// 初始化优先队列</span><br>\tpq := priorityqueue.NewWith(byPriority)<br>\t<span class=\"hljs-keyword\">for</span> k, v := <span class=\"hljs-keyword\">range</span> maps &#123;<br>\t\tpq.Enqueue(Element&#123;<br>\t\t\tNum:     k,<br>\t\t\tCount: v,<br>\t\t&#125;)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>    <span class=\"hljs-comment\">// 取前k个元素保存到result中</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; k; i++ &#123;<br>\t\tvalue, _ := pq.Dequeue()<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, value.(Element).Num)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"代码随想录算法训练营第十三天 144.二叉树的前序遍历、145.二叉树的后序遍历、94.二叉树的中序遍历","abbrlink":"5d0ef500","date":"2023-10-06T11:14:44.000Z","_content":"\n# 代码随想录算法训练营第十三天 144.二叉树的前序遍历、145.二叉树的后序遍历、94.二叉树的中序遍历\n\n## 二叉树的遍历\n\n>   题目链接：\n>\n>   -   [144.二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)\n>   -   [145.二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)\n>   -   [94.二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html)\n>\n>   视频讲解：[每次写递归都要靠直觉？ 这次带你学透二叉树的递归遍历！](https://www.bilibili.com/video/BV1Wh411S7xt)\n>\n>   状态：AC\n\n### 递归思路\n\n递归还是比较简单的，直接按照遍历规则写递归代码即可\n\n### 代码\n\n``` go\n// 递归前序遍历\nfunc preorderTraversal(root *TreeNode) []int {\n\tvar result []int\n\tgetResultPreorder(root, &result)\n\treturn result\n}\n\nfunc getResultPreorder(root *TreeNode, result *[]int) {\n\tif root == nil {\n\t\treturn\n\t}\n\t*result = append(*result, root.Val)\n\tgetResultPreorder(root.Left, result)\n\tgetResultPreorder(root.Right, result)\n}\n```\n\n``` go\n// 递归后序遍历\nfunc postorderTraversal(root *TreeNode) []int {\n\tvar result []int\n\tgetResultPostorder(root, &result)\n\treturn result\n}\n\nfunc getResultPostorder(root *TreeNode, result *[]int) {\n\tif root == nil {\n\t\treturn\n\t}\n\tgetResultPostorder(root.Left, result)\n\tgetResultPostorder(root.Right, result)\n\t*result = append(*result, root.Val)\n}\n```\n\n``` go\n// 递归中序遍历\nfunc inorderTraversal(root *TreeNode) []int {\n\tvar result []int\n\tgetResultInorder(root, &result)\n\treturn result\n}\n\nfunc getResultInorder(root *TreeNode, result *[]int) {\n\tif root == nil {\n\t\treturn\n\t}\n\tgetResultInorder(root.Left, result)\n\t*result = append(*result, root.Val)\n\tgetResultInorder(root.Right, result)\n}\n```\n\n### 非递归思路\n\n非递归需要借助栈来实现，每次存放树的左右节点（若存在），并判断根节点应该在什么时候存入结果数组。\n\n``` go\n// 非递归前序遍历\nfunc preorderTraversal(root *TreeNode) []int {\n\tstack := arraystack.New()\n\tresult := []int{}\n\tif root == nil {\n\t\treturn result\n\t}\n\tstack.Push(root)\n\tfor !stack.Empty() {\n\t\tvalue, _ := stack.Pop()\n\t\tresult = append(result, value.(*TreeNode).Val)\n\t\tif value.(*TreeNode).Right != nil {\n\t\t\tstack.Push(value.(*TreeNode).Right)\n\t\t}\n\t\tif value.(*TreeNode).Left != nil {\n\t\t\tstack.Push(value.(*TreeNode).Left)\n\t\t}\n\t}\n\treturn result\n}\n```\n\n``` go\n// 非递归后序遍历\nfunc postorderTraversal(root *TreeNode) []int {\n\tstack := arraystack.New()\n\tresult := []int{}\n\tif root == nil {\n\t\treturn result\n\t}\n\tstack.Push(root)\n\tfor !stack.Empty() {\n\t\tvalue, _ := stack.Pop()\n\t\tresult = append(result, value.(*TreeNode).Val)\n\t\tif value.(*TreeNode).Left != nil {\n\t\t\tstack.Push(value.(*TreeNode).Left)\n\t\t}\n\t\tif value.(*TreeNode).Right != nil {\n\t\t\tstack.Push(value.(*TreeNode).Right)\n\t\t}\n\t}\n\tfor i := 0; i < len(result)/2; i++ {\n\t\tresult[i], result[len(result)-1-i] = result[len(result)-1-i], result[i]\n\t}\n\treturn result\n}\n\n```\n\n``` go\n// 非递归中序遍历\nfunc InorderTraversal1(root *TreeNode) []int {\n\tstack := arraystack.New()\n\tresult := []int{}\n\tif root == nil {\n\t\treturn result\n\t}\n\tp := root\n\tfor !stack.Empty() || p != nil {\n\t\tif p != nil {\n\t\t\tstack.Push(p)\n\t\t\tp = p.Left\n\t\t} else {\n\t\t\tnode, _ := stack.Pop()\n\t\t\tp = node.(*TreeNode)\n\t\t\tresult = append(result, p.Val)\n\t\t\tp = p.Right\n\t\t}\n\t}\n\treturn result\n}\n\n```\n\n","source":"_posts/day13.md","raw":"---\ntitle: 代码随想录算法训练营第十三天 144.二叉树的前序遍历、145.二叉树的后序遍历、94.二叉树的中序遍历\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: 5d0ef500\ndate: 2023-10-06 19:14:44\n---\n\n# 代码随想录算法训练营第十三天 144.二叉树的前序遍历、145.二叉树的后序遍历、94.二叉树的中序遍历\n\n## 二叉树的遍历\n\n>   题目链接：\n>\n>   -   [144.二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)\n>   -   [145.二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)\n>   -   [94.二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\n>\n>   文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html)\n>\n>   视频讲解：[每次写递归都要靠直觉？ 这次带你学透二叉树的递归遍历！](https://www.bilibili.com/video/BV1Wh411S7xt)\n>\n>   状态：AC\n\n### 递归思路\n\n递归还是比较简单的，直接按照遍历规则写递归代码即可\n\n### 代码\n\n``` go\n// 递归前序遍历\nfunc preorderTraversal(root *TreeNode) []int {\n\tvar result []int\n\tgetResultPreorder(root, &result)\n\treturn result\n}\n\nfunc getResultPreorder(root *TreeNode, result *[]int) {\n\tif root == nil {\n\t\treturn\n\t}\n\t*result = append(*result, root.Val)\n\tgetResultPreorder(root.Left, result)\n\tgetResultPreorder(root.Right, result)\n}\n```\n\n``` go\n// 递归后序遍历\nfunc postorderTraversal(root *TreeNode) []int {\n\tvar result []int\n\tgetResultPostorder(root, &result)\n\treturn result\n}\n\nfunc getResultPostorder(root *TreeNode, result *[]int) {\n\tif root == nil {\n\t\treturn\n\t}\n\tgetResultPostorder(root.Left, result)\n\tgetResultPostorder(root.Right, result)\n\t*result = append(*result, root.Val)\n}\n```\n\n``` go\n// 递归中序遍历\nfunc inorderTraversal(root *TreeNode) []int {\n\tvar result []int\n\tgetResultInorder(root, &result)\n\treturn result\n}\n\nfunc getResultInorder(root *TreeNode, result *[]int) {\n\tif root == nil {\n\t\treturn\n\t}\n\tgetResultInorder(root.Left, result)\n\t*result = append(*result, root.Val)\n\tgetResultInorder(root.Right, result)\n}\n```\n\n### 非递归思路\n\n非递归需要借助栈来实现，每次存放树的左右节点（若存在），并判断根节点应该在什么时候存入结果数组。\n\n``` go\n// 非递归前序遍历\nfunc preorderTraversal(root *TreeNode) []int {\n\tstack := arraystack.New()\n\tresult := []int{}\n\tif root == nil {\n\t\treturn result\n\t}\n\tstack.Push(root)\n\tfor !stack.Empty() {\n\t\tvalue, _ := stack.Pop()\n\t\tresult = append(result, value.(*TreeNode).Val)\n\t\tif value.(*TreeNode).Right != nil {\n\t\t\tstack.Push(value.(*TreeNode).Right)\n\t\t}\n\t\tif value.(*TreeNode).Left != nil {\n\t\t\tstack.Push(value.(*TreeNode).Left)\n\t\t}\n\t}\n\treturn result\n}\n```\n\n``` go\n// 非递归后序遍历\nfunc postorderTraversal(root *TreeNode) []int {\n\tstack := arraystack.New()\n\tresult := []int{}\n\tif root == nil {\n\t\treturn result\n\t}\n\tstack.Push(root)\n\tfor !stack.Empty() {\n\t\tvalue, _ := stack.Pop()\n\t\tresult = append(result, value.(*TreeNode).Val)\n\t\tif value.(*TreeNode).Left != nil {\n\t\t\tstack.Push(value.(*TreeNode).Left)\n\t\t}\n\t\tif value.(*TreeNode).Right != nil {\n\t\t\tstack.Push(value.(*TreeNode).Right)\n\t\t}\n\t}\n\tfor i := 0; i < len(result)/2; i++ {\n\t\tresult[i], result[len(result)-1-i] = result[len(result)-1-i], result[i]\n\t}\n\treturn result\n}\n\n```\n\n``` go\n// 非递归中序遍历\nfunc InorderTraversal1(root *TreeNode) []int {\n\tstack := arraystack.New()\n\tresult := []int{}\n\tif root == nil {\n\t\treturn result\n\t}\n\tp := root\n\tfor !stack.Empty() || p != nil {\n\t\tif p != nil {\n\t\t\tstack.Push(p)\n\t\t\tp = p.Left\n\t\t} else {\n\t\t\tnode, _ := stack.Pop()\n\t\t\tp = node.(*TreeNode)\n\t\t\tresult = append(result, p.Val)\n\t\t\tp = p.Right\n\t\t}\n\t}\n\treturn result\n}\n\n```\n\n","slug":"day13","published":1,"updated":"2023-10-06T11:23:19.009Z","_id":"clneippor0000vez88eiyex1t","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第十三天-144-二叉树的前序遍历、145-二叉树的后序遍历、94-二叉树的中序遍历\"><a href=\"#代码随想录算法训练营第十三天-144-二叉树的前序遍历、145-二叉树的后序遍历、94-二叉树的中序遍历\" class=\"headerlink\" title=\"代码随想录算法训练营第十三天 144.二叉树的前序遍历、145.二叉树的后序遍历、94.二叉树的中序遍历\"></a>代码随想录算法训练营第十三天 144.二叉树的前序遍历、145.二叉树的后序遍历、94.二叉树的中序遍历</h1><h2 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h2><blockquote>\n<p>  题目链接：</p>\n<ul>\n<li><a href=\"https://leetcode.cn/problems/binary-tree-preorder-traversal/\">144.二叉树的前序遍历</a></li>\n<li><a href=\"https://leetcode.cn/problems/binary-tree-postorder-traversal/\">145.二叉树的后序遍历</a></li>\n<li><a href=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/\">94.二叉树的中序遍历</a></li>\n</ul>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1Wh411S7xt\">每次写递归都要靠直觉？ 这次带你学透二叉树的递归遍历！</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"递归思路\"><a href=\"#递归思路\" class=\"headerlink\" title=\"递归思路\"></a>递归思路</h3><p>递归还是比较简单的，直接按照遍历规则写递归代码即可</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 递归前序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">preorderTraversal</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>\tgetResultPreorder(root, &amp;result)<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getResultPreorder</span><span class=\"hljs-params\">(root *TreeNode, result *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\t*result = <span class=\"hljs-built_in\">append</span>(*result, root.Val)<br>\tgetResultPreorder(root.Left, result)<br>\tgetResultPreorder(root.Right, result)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 递归后序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">postorderTraversal</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>\tgetResultPostorder(root, &amp;result)<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getResultPostorder</span><span class=\"hljs-params\">(root *TreeNode, result *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\tgetResultPostorder(root.Left, result)<br>\tgetResultPostorder(root.Right, result)<br>\t*result = <span class=\"hljs-built_in\">append</span>(*result, root.Val)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 递归中序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">inorderTraversal</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>\tgetResultInorder(root, &amp;result)<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getResultInorder</span><span class=\"hljs-params\">(root *TreeNode, result *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\tgetResultInorder(root.Left, result)<br>\t*result = <span class=\"hljs-built_in\">append</span>(*result, root.Val)<br>\tgetResultInorder(root.Right, result)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"非递归思路\"><a href=\"#非递归思路\" class=\"headerlink\" title=\"非递归思路\"></a>非递归思路</h3><p>非递归需要借助栈来实现，每次存放树的左右节点（若存在），并判断根节点应该在什么时候存入结果数组。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 非递归前序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">preorderTraversal</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tstack := arraystack.New()<br>\tresult := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tstack.Push(root)<br>\t<span class=\"hljs-keyword\">for</span> !stack.Empty() &#123;<br>\t\tvalue, _ := stack.Pop()<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, value.(*TreeNode).Val)<br>\t\t<span class=\"hljs-keyword\">if</span> value.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\tstack.Push(value.(*TreeNode).Right)<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> value.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\tstack.Push(value.(*TreeNode).Left)<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 非递归后序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">postorderTraversal</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tstack := arraystack.New()<br>\tresult := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tstack.Push(root)<br>\t<span class=\"hljs-keyword\">for</span> !stack.Empty() &#123;<br>\t\tvalue, _ := stack.Pop()<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, value.(*TreeNode).Val)<br>\t\t<span class=\"hljs-keyword\">if</span> value.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\tstack.Push(value.(*TreeNode).Left)<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> value.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\tstack.Push(value.(*TreeNode).Right)<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(result)/<span class=\"hljs-number\">2</span>; i++ &#123;<br>\t\tresult[i], result[<span class=\"hljs-built_in\">len</span>(result)<span class=\"hljs-number\">-1</span>-i] = result[<span class=\"hljs-built_in\">len</span>(result)<span class=\"hljs-number\">-1</span>-i], result[i]<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 非递归中序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">InorderTraversal1</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tstack := arraystack.New()<br>\tresult := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tp := root<br>\t<span class=\"hljs-keyword\">for</span> !stack.Empty() || p != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> p != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\tstack.Push(p)<br>\t\t\tp = p.Left<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tnode, _ := stack.Pop()<br>\t\t\tp = node.(*TreeNode)<br>\t\t\tresult = <span class=\"hljs-built_in\">append</span>(result, p.Val)<br>\t\t\tp = p.Right<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第十三天-144-二叉树的前序遍历、145-二叉树的后序遍历、94-二叉树的中序遍历\"><a href=\"#代码随想录算法训练营第十三天-144-二叉树的前序遍历、145-二叉树的后序遍历、94-二叉树的中序遍历\" class=\"headerlink\" title=\"代码随想录算法训练营第十三天 144.二叉树的前序遍历、145.二叉树的后序遍历、94.二叉树的中序遍历\"></a>代码随想录算法训练营第十三天 144.二叉树的前序遍历、145.二叉树的后序遍历、94.二叉树的中序遍历</h1><h2 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h2><blockquote>\n<p>  题目链接：</p>\n<ul>\n<li><a href=\"https://leetcode.cn/problems/binary-tree-preorder-traversal/\">144.二叉树的前序遍历</a></li>\n<li><a href=\"https://leetcode.cn/problems/binary-tree-postorder-traversal/\">145.二叉树的后序遍历</a></li>\n<li><a href=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/\">94.二叉树的中序遍历</a></li>\n</ul>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html\">代码随想录(programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1Wh411S7xt\">每次写递归都要靠直觉？ 这次带你学透二叉树的递归遍历！</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"递归思路\"><a href=\"#递归思路\" class=\"headerlink\" title=\"递归思路\"></a>递归思路</h3><p>递归还是比较简单的，直接按照遍历规则写递归代码即可</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 递归前序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">preorderTraversal</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>\tgetResultPreorder(root, &amp;result)<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getResultPreorder</span><span class=\"hljs-params\">(root *TreeNode, result *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\t*result = <span class=\"hljs-built_in\">append</span>(*result, root.Val)<br>\tgetResultPreorder(root.Left, result)<br>\tgetResultPreorder(root.Right, result)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 递归后序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">postorderTraversal</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>\tgetResultPostorder(root, &amp;result)<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getResultPostorder</span><span class=\"hljs-params\">(root *TreeNode, result *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\tgetResultPostorder(root.Left, result)<br>\tgetResultPostorder(root.Right, result)<br>\t*result = <span class=\"hljs-built_in\">append</span>(*result, root.Val)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 递归中序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">inorderTraversal</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>\tgetResultInorder(root, &amp;result)<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getResultInorder</span><span class=\"hljs-params\">(root *TreeNode, result *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\tgetResultInorder(root.Left, result)<br>\t*result = <span class=\"hljs-built_in\">append</span>(*result, root.Val)<br>\tgetResultInorder(root.Right, result)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"非递归思路\"><a href=\"#非递归思路\" class=\"headerlink\" title=\"非递归思路\"></a>非递归思路</h3><p>非递归需要借助栈来实现，每次存放树的左右节点（若存在），并判断根节点应该在什么时候存入结果数组。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 非递归前序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">preorderTraversal</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tstack := arraystack.New()<br>\tresult := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tstack.Push(root)<br>\t<span class=\"hljs-keyword\">for</span> !stack.Empty() &#123;<br>\t\tvalue, _ := stack.Pop()<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, value.(*TreeNode).Val)<br>\t\t<span class=\"hljs-keyword\">if</span> value.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\tstack.Push(value.(*TreeNode).Right)<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> value.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\tstack.Push(value.(*TreeNode).Left)<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 非递归后序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">postorderTraversal</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tstack := arraystack.New()<br>\tresult := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tstack.Push(root)<br>\t<span class=\"hljs-keyword\">for</span> !stack.Empty() &#123;<br>\t\tvalue, _ := stack.Pop()<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, value.(*TreeNode).Val)<br>\t\t<span class=\"hljs-keyword\">if</span> value.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\tstack.Push(value.(*TreeNode).Left)<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> value.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\tstack.Push(value.(*TreeNode).Right)<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(result)/<span class=\"hljs-number\">2</span>; i++ &#123;<br>\t\tresult[i], result[<span class=\"hljs-built_in\">len</span>(result)<span class=\"hljs-number\">-1</span>-i] = result[<span class=\"hljs-built_in\">len</span>(result)<span class=\"hljs-number\">-1</span>-i], result[i]<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 非递归中序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">InorderTraversal1</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\tstack := arraystack.New()<br>\tresult := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tp := root<br>\t<span class=\"hljs-keyword\">for</span> !stack.Empty() || p != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> p != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\tstack.Push(p)<br>\t\t\tp = p.Left<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tnode, _ := stack.Pop()<br>\t\t\tp = node.(*TreeNode)<br>\t\t\tresult = <span class=\"hljs-built_in\">append</span>(result, p.Val)<br>\t\t\tp = p.Right<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n"},{"title":"代码随想录算法训练营第十四天 102.二叉树的层序遍历、107.二叉树的层次遍历II、199.二叉树的右视图、637.二叉树的层平均值、429.N叉树的层序遍历、515.在每个树行中找最大值、116.填充每个节点的下一个右侧节点指、117.填充每个节点的下一个右侧节点指针II、104.二叉树的最大深度、111.二叉树的最小深度、226.翻转二叉树、101.对称二叉树","abbrlink":"e1408dd4","date":"2023-10-07T13:33:44.000Z","_content":"# 代码随想录算法训练营第十四天 102.二叉树的层序遍历、107.二叉树的层次遍历II、199.二叉树的右视图、637.二叉树的层平均值、429.N叉树的层序遍历、515.在每个树行中找最大值、116.填充每个节点的下一个右侧节点指、117.填充每个节点的下一个右侧节点指针II、104.二叉树的最大深度、111.二叉树的最小深度\n\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html)\n>\n> 视频讲解：[讲透二叉树的层序遍历 | 广度优先搜索 | LeetCode：102.二叉树的层序遍历](https://www.bilibili.com/video/BV1GY4y1u7b2)\n\n## 102. 二叉树的层序遍历\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal/)\n>\n> 状态：AC\n\n### 思路\n\n层序遍历顾名思义就是要一层一层的输出树的结点，父节点输出后还要将子节点保存一下，到下一层继续使用，这种依次使用，队列的数据结构是最合适的。父节点先入队，将两个子节点依次入队。这一层的父节点入队过后要统计有多少个，为了输出每层分别是谁\n\n### 代码\n\n```go\nfunc levelOrder(root *TreeNode) [][]int {\n\tvar result [][]int\n\tif root == nil {\n\t\treturn result\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*TreeNode).Val)\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\treturn result\n}\n```\n\n## 107. 二叉树的层序遍历II\n\n> 题目链接：[107.二叉树的层次遍历II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)\n>\n> 状态：AC\n\n### 思路\n\n基本同上，这次不过要从下向上输出，翻转最后上一题的`result`即可\n\n### 代码\n\n``` go\nfunc levelOrderBottom(root *TreeNode) [][]int {\n\tvar result [][]int\n\tif root == nil {\n\t\treturn result\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*TreeNode).Val)\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\tfor i := 0; i < len(result)/2; i++ {\n\t\tresult[i], result[len(result)-1-i] = result[len(result)-1-i], result[i]\n\t}\n\treturn result\n}\n```\n\n## 199.二叉树的右视图\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/binary-tree-right-side-view/)\n>\n> 状态：AC\n\n### 思路\n\n将第一次层序遍历的结果使用二维数组逐行写出来，不难发现右视图就是二维数组每一行的最后一个元素\n\n### 代码\n\n``` go\nfunc rightSideView(root *TreeNode) []int {\n\tvar results [][]int\n\tif root == nil {\n\t\treturn []int{}\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*TreeNode).Val)\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresults = append(results, temp)\n\t}\n\tresult := []int{}\n\tfor _, v := range results {\n\t\tresult = append(result, v[len(v)-1])\n\t}\n\treturn result\n}\n\n```\n\n## 637.二叉树的层平均值\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)\n>\n> 状态：AC\n\n### 思路\n\n层序每一层之后求平均值\n\n### 代码\n\n``` go\nfunc averageOfLevels(root *TreeNode) []float64 {\n\tvar result []float64\n\tif root == nil {\n\t\treturn result\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\tsum := 0\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\tsum += node.(*TreeNode).Val\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, float64(sum)/float64(size))\n\t}\n\treturn result\n}\n```\n\n## 429.N叉树的层序遍历\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)\n>\n> 状态：AC\n\n### 思路\n\n层序添加子节点改为循环遍历`Children`数组即可\n\n### 代码\n\n``` go\ntype Node struct {\n\tVal      int\n\tChildren []*Node\n}\n\nfunc levelOrder(root *Node) [][]int {\n\tvar result [][]int\n\tif root == nil {\n\t\treturn result\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*Node).Val)\n\t\t\tfor j := 0; j < len(node.(*Node).Children); j++ {\n\t\t\t\tif node.(*Node).Children[j] != nil {\n\t\t\t\t\tqueue.Enqueue(node.(*Node).Children[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\treturn result\n}\n\n```\n\n## 515.在每个树行中找最大值\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)\n>\n> 状态：AC\n\n### 思路\n\n每一层找最大，模版依旧\n\n### 代码\n\n``` go\nfunc largestValues(root *TreeNode) []int {\n\tvar result []int\n\tif root == nil {\n\t\treturn result\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\tmaxNum := math.MinInt32\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\tif node.(*TreeNode).Val > maxNum {\n\t\t\t\tmaxNum = node.(*TreeNode).Val\n\t\t\t}\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, maxNum)\n\t}\n\treturn result\n}\n\n```\n\n##  116.填充每个节点的下一个右侧节点指针、 117.填充每个节点的下一个右侧节点指针II\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)\n>\n> 状态：AC\n\n### 思路\n\n每行遍历出来看做一个链表，两道题代码思路一样\n\n### 代码\n\n``` go\n\n// 与117题代码相同\ntype Node struct {\n\tVal   int\n\tLeft  *Node\n\tRight *Node\n\tNext  *Node\n}\n\nfunc Connect(root *Node) *Node {\n\tif root == nil {\n\t\treturn nil\n\t}\n\tqueue := arrayqueue.New()\n\troot.Next = nil\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\tvar p *Node = nil\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\n\t\t\tif node.(*Node).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*Node).Left)\n\t\t\t}\n\t\t\tif node.(*Node).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*Node).Right)\n\t\t\t}\n\t\t\tif p == nil {\n\t\t\t\tp = node.(*Node)\n\t\t\t} else {\n\t\t\t\tp.Next = node.(*Node)\n\t\t\t\tp = p.Next\n\t\t\t}\n\t\t}\n\t\tp.Next = nil\n\t}\n\treturn root\n}\n\n```\n\n##  104.二叉树的最大深度\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n>\n> 状态：AC\n\n### 思路\n\n#### 方法一\n\n使用递归法，如果递归到叶子节点则返回0，否则使用左右叶子结点继续向下递归，深度加一。取左右结点的最大值\n\n#### 方法二\n\n层序遍历，看`result`二维数组的行数\n\n### 代码\n\n``` go\n// 递归\nfunc maxNum(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\treturn maxNum(maxDepth(root.Left), maxDepth(root.Right)) + 1\n}\n```\n\n``` go\n// 层序\nfunc maxDepth1(root *TreeNode) int {\n\tvar result [][]int\n\tif root == nil {\n\t\treturn 0\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*TreeNode).Val)\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\treturn len(result)\n}\n```\n\n## 111.二叉树的最小深度\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\n>\n> 状态：AC\n\n### 思路\n\n#### 方法一\n\n使用递归法，递归终止条件如下：到达了叶子节点`return 1`。到达空节点`return 0`。分别向左和右结点继续递归，计算更小的层数，当前层递归完成后`return 层数加一`\n\n#### 方法二\n\n使用层序遍历。遍历时如果遇到叶子节点说明到达了最低点，直接`return 当前层数`\n\n``` go\n//递归\nfunc minNum(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc minDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tif root.Left == nil && root.Right == nil {\n\t\treturn 1\n\t}\n\tminN := math.MaxInt32\n\tif root.Left != nil {\n\t\tminN = minNum(minDepth(root.Left), minN)\n\t}\n\tif root.Right != nil {\n\t\tminN = minNum(minDepth(root.Right), minN)\n\t}\n\treturn minN + 1\n}\n```\n\n``` go\n//层序\nfunc minDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tcount := 0\n\tfor !queue.Empty() {\n\t\tcount++\n\t\tsize := queue.Size()\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Left == nil && node.(*TreeNode).Right == nil {\n\t\t\t\treturn count\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n```\n\n## 226.翻转二叉树\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/invert-binary-tree/)\n>\n> 状态：AC\n\n### 思路\n\n交换当前结点左右子节点，向下递归\n\n### 代码\n\n``` go\nfunc invertTree(root *TreeNode) *TreeNode {\n\tif root == nil {\n\t\treturn root\n\t}\n\troot.Left, root.Right = root.Right, root.Left\n\tinvertTree(root.Left)\n\tinvertTree(root.Right)\n\treturn root\n}\n```\n\n##  101. 对称二叉树\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/symmetric-tree/)\n>\n> 文章链接：[代码随想录(programmercarl.com)](https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html)\n>\n> 视频链接：[同时操作两个二叉树 | LeetCode：101. 对称二叉树](https://www.bilibili.com/video/BV1ue4y1Y7Mf)\n>\n> 状态：AC\n\n### 思路\n\n<font color=\"red\">错误思路如下</font>\n\n最开始想的是输出中序遍历的结果，根节点一定是最中间的数，比较两端是否对称即可。但是这种情况没考虑到\n\n``` go\n//      1\n//     / \\\n//    2   2\n//   /   /\n//  2   2\n```\n\n所以这个思路是错的\n\n---\n\n<font color=\"green\">正确思路如下</font>\n\n用后序遍历和“伪后序遍历”依次比较子树。后序遍历是左右根，伪后序比那里是右左根，这样可以比较相同的结点。\n\n使用递归需要做如下判断\n\n- 递归函数的构造\n    - 比较左右结点，传参是两个节点`func compare(left, right *TreeNode) bool`\n- 递归终止条件\n    - 两个节点均为空节点，对称`return true`\n    - 左空右不空，或，左不空右空，不对称`return false`\n    - 左右均不空，但是值不同，不对称`return false`\n- 单次递归逻辑\n    - 左节点的左 和 右结点的右  向下递归\n    - 且 左节点的右 和 右结点的左  向下递归\n    - 且二者值均为`true`\n\n### 代码\n\n``` go\nfunc compare(left, right *TreeNode) bool {\n\tif left == nil && right == nil {\n\t\treturn true\n\t}\n\tif left != nil && right == nil {\n\t\treturn false\n\t}\n\tif left == nil && right != nil {\n\t\treturn false\n\t}\n\tif left.Val != right.Val {\n\t\treturn false\n\t}\n\treturn compare(left.Left, right.Right) && compare(left.Right, right.Left)\n\n}\n\nfunc isSymmetric(root *TreeNode) bool {\n\tif root == nil {\n\t\treturn true\n\t}\n\treturn compare(root.Left, root.Right)\n}\n```\n\n","source":"_posts/day14.md","raw":"---\ntitle: 代码随想录算法训练营第十四天 102.二叉树的层序遍历、107.二叉树的层次遍历II、199.二叉树的右视图、637.二叉树的层平均值、429.N叉树的层序遍历、515.在每个树行中找最大值、116.填充每个节点的下一个右侧节点指、117.填充每个节点的下一个右侧节点指针II、104.二叉树的最大深度、111.二叉树的最小深度、226.翻转二叉树、101.对称二叉树\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: e1408dd4\ndate: 2023-10-07 21:33:44\n---\n# 代码随想录算法训练营第十四天 102.二叉树的层序遍历、107.二叉树的层次遍历II、199.二叉树的右视图、637.二叉树的层平均值、429.N叉树的层序遍历、515.在每个树行中找最大值、116.填充每个节点的下一个右侧节点指、117.填充每个节点的下一个右侧节点指针II、104.二叉树的最大深度、111.二叉树的最小深度\n\n> 文章讲解：[代码随想录(programmercarl.com)](https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html)\n>\n> 视频讲解：[讲透二叉树的层序遍历 | 广度优先搜索 | LeetCode：102.二叉树的层序遍历](https://www.bilibili.com/video/BV1GY4y1u7b2)\n\n## 102. 二叉树的层序遍历\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal/)\n>\n> 状态：AC\n\n### 思路\n\n层序遍历顾名思义就是要一层一层的输出树的结点，父节点输出后还要将子节点保存一下，到下一层继续使用，这种依次使用，队列的数据结构是最合适的。父节点先入队，将两个子节点依次入队。这一层的父节点入队过后要统计有多少个，为了输出每层分别是谁\n\n### 代码\n\n```go\nfunc levelOrder(root *TreeNode) [][]int {\n\tvar result [][]int\n\tif root == nil {\n\t\treturn result\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*TreeNode).Val)\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\treturn result\n}\n```\n\n## 107. 二叉树的层序遍历II\n\n> 题目链接：[107.二叉树的层次遍历II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)\n>\n> 状态：AC\n\n### 思路\n\n基本同上，这次不过要从下向上输出，翻转最后上一题的`result`即可\n\n### 代码\n\n``` go\nfunc levelOrderBottom(root *TreeNode) [][]int {\n\tvar result [][]int\n\tif root == nil {\n\t\treturn result\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*TreeNode).Val)\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\tfor i := 0; i < len(result)/2; i++ {\n\t\tresult[i], result[len(result)-1-i] = result[len(result)-1-i], result[i]\n\t}\n\treturn result\n}\n```\n\n## 199.二叉树的右视图\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/binary-tree-right-side-view/)\n>\n> 状态：AC\n\n### 思路\n\n将第一次层序遍历的结果使用二维数组逐行写出来，不难发现右视图就是二维数组每一行的最后一个元素\n\n### 代码\n\n``` go\nfunc rightSideView(root *TreeNode) []int {\n\tvar results [][]int\n\tif root == nil {\n\t\treturn []int{}\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*TreeNode).Val)\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresults = append(results, temp)\n\t}\n\tresult := []int{}\n\tfor _, v := range results {\n\t\tresult = append(result, v[len(v)-1])\n\t}\n\treturn result\n}\n\n```\n\n## 637.二叉树的层平均值\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)\n>\n> 状态：AC\n\n### 思路\n\n层序每一层之后求平均值\n\n### 代码\n\n``` go\nfunc averageOfLevels(root *TreeNode) []float64 {\n\tvar result []float64\n\tif root == nil {\n\t\treturn result\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\tsum := 0\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\tsum += node.(*TreeNode).Val\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, float64(sum)/float64(size))\n\t}\n\treturn result\n}\n```\n\n## 429.N叉树的层序遍历\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)\n>\n> 状态：AC\n\n### 思路\n\n层序添加子节点改为循环遍历`Children`数组即可\n\n### 代码\n\n``` go\ntype Node struct {\n\tVal      int\n\tChildren []*Node\n}\n\nfunc levelOrder(root *Node) [][]int {\n\tvar result [][]int\n\tif root == nil {\n\t\treturn result\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*Node).Val)\n\t\t\tfor j := 0; j < len(node.(*Node).Children); j++ {\n\t\t\t\tif node.(*Node).Children[j] != nil {\n\t\t\t\t\tqueue.Enqueue(node.(*Node).Children[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\treturn result\n}\n\n```\n\n## 515.在每个树行中找最大值\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)\n>\n> 状态：AC\n\n### 思路\n\n每一层找最大，模版依旧\n\n### 代码\n\n``` go\nfunc largestValues(root *TreeNode) []int {\n\tvar result []int\n\tif root == nil {\n\t\treturn result\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\tmaxNum := math.MinInt32\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\tif node.(*TreeNode).Val > maxNum {\n\t\t\t\tmaxNum = node.(*TreeNode).Val\n\t\t\t}\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, maxNum)\n\t}\n\treturn result\n}\n\n```\n\n##  116.填充每个节点的下一个右侧节点指针、 117.填充每个节点的下一个右侧节点指针II\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)\n>\n> 状态：AC\n\n### 思路\n\n每行遍历出来看做一个链表，两道题代码思路一样\n\n### 代码\n\n``` go\n\n// 与117题代码相同\ntype Node struct {\n\tVal   int\n\tLeft  *Node\n\tRight *Node\n\tNext  *Node\n}\n\nfunc Connect(root *Node) *Node {\n\tif root == nil {\n\t\treturn nil\n\t}\n\tqueue := arrayqueue.New()\n\troot.Next = nil\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\tvar p *Node = nil\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\n\t\t\tif node.(*Node).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*Node).Left)\n\t\t\t}\n\t\t\tif node.(*Node).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*Node).Right)\n\t\t\t}\n\t\t\tif p == nil {\n\t\t\t\tp = node.(*Node)\n\t\t\t} else {\n\t\t\t\tp.Next = node.(*Node)\n\t\t\t\tp = p.Next\n\t\t\t}\n\t\t}\n\t\tp.Next = nil\n\t}\n\treturn root\n}\n\n```\n\n##  104.二叉树的最大深度\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n>\n> 状态：AC\n\n### 思路\n\n#### 方法一\n\n使用递归法，如果递归到叶子节点则返回0，否则使用左右叶子结点继续向下递归，深度加一。取左右结点的最大值\n\n#### 方法二\n\n层序遍历，看`result`二维数组的行数\n\n### 代码\n\n``` go\n// 递归\nfunc maxNum(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\treturn maxNum(maxDepth(root.Left), maxDepth(root.Right)) + 1\n}\n```\n\n``` go\n// 层序\nfunc maxDepth1(root *TreeNode) int {\n\tvar result [][]int\n\tif root == nil {\n\t\treturn 0\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*TreeNode).Val)\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\treturn len(result)\n}\n```\n\n## 111.二叉树的最小深度\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\n>\n> 状态：AC\n\n### 思路\n\n#### 方法一\n\n使用递归法，递归终止条件如下：到达了叶子节点`return 1`。到达空节点`return 0`。分别向左和右结点继续递归，计算更小的层数，当前层递归完成后`return 层数加一`\n\n#### 方法二\n\n使用层序遍历。遍历时如果遇到叶子节点说明到达了最低点，直接`return 当前层数`\n\n``` go\n//递归\nfunc minNum(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc minDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tif root.Left == nil && root.Right == nil {\n\t\treturn 1\n\t}\n\tminN := math.MaxInt32\n\tif root.Left != nil {\n\t\tminN = minNum(minDepth(root.Left), minN)\n\t}\n\tif root.Right != nil {\n\t\tminN = minNum(minDepth(root.Right), minN)\n\t}\n\treturn minN + 1\n}\n```\n\n``` go\n//层序\nfunc minDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tcount := 0\n\tfor !queue.Empty() {\n\t\tcount++\n\t\tsize := queue.Size()\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Left == nil && node.(*TreeNode).Right == nil {\n\t\t\t\treturn count\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n```\n\n## 226.翻转二叉树\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/invert-binary-tree/)\n>\n> 状态：AC\n\n### 思路\n\n交换当前结点左右子节点，向下递归\n\n### 代码\n\n``` go\nfunc invertTree(root *TreeNode) *TreeNode {\n\tif root == nil {\n\t\treturn root\n\t}\n\troot.Left, root.Right = root.Right, root.Left\n\tinvertTree(root.Left)\n\tinvertTree(root.Right)\n\treturn root\n}\n```\n\n##  101. 对称二叉树\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/symmetric-tree/)\n>\n> 文章链接：[代码随想录(programmercarl.com)](https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html)\n>\n> 视频链接：[同时操作两个二叉树 | LeetCode：101. 对称二叉树](https://www.bilibili.com/video/BV1ue4y1Y7Mf)\n>\n> 状态：AC\n\n### 思路\n\n<font color=\"red\">错误思路如下</font>\n\n最开始想的是输出中序遍历的结果，根节点一定是最中间的数，比较两端是否对称即可。但是这种情况没考虑到\n\n``` go\n//      1\n//     / \\\n//    2   2\n//   /   /\n//  2   2\n```\n\n所以这个思路是错的\n\n---\n\n<font color=\"green\">正确思路如下</font>\n\n用后序遍历和“伪后序遍历”依次比较子树。后序遍历是左右根，伪后序比那里是右左根，这样可以比较相同的结点。\n\n使用递归需要做如下判断\n\n- 递归函数的构造\n    - 比较左右结点，传参是两个节点`func compare(left, right *TreeNode) bool`\n- 递归终止条件\n    - 两个节点均为空节点，对称`return true`\n    - 左空右不空，或，左不空右空，不对称`return false`\n    - 左右均不空，但是值不同，不对称`return false`\n- 单次递归逻辑\n    - 左节点的左 和 右结点的右  向下递归\n    - 且 左节点的右 和 右结点的左  向下递归\n    - 且二者值均为`true`\n\n### 代码\n\n``` go\nfunc compare(left, right *TreeNode) bool {\n\tif left == nil && right == nil {\n\t\treturn true\n\t}\n\tif left != nil && right == nil {\n\t\treturn false\n\t}\n\tif left == nil && right != nil {\n\t\treturn false\n\t}\n\tif left.Val != right.Val {\n\t\treturn false\n\t}\n\treturn compare(left.Left, right.Right) && compare(left.Right, right.Left)\n\n}\n\nfunc isSymmetric(root *TreeNode) bool {\n\tif root == nil {\n\t\treturn true\n\t}\n\treturn compare(root.Left, root.Right)\n}\n```\n\n","slug":"day14","published":1,"updated":"2023-10-07T14:28:10.169Z","_id":"clng3wbhs0000t4whcaffbolr","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第十四天-102-二叉树的层序遍历、107-二叉树的层次遍历II、199-二叉树的右视图、637-二叉树的层平均值、429-N叉树的层序遍历、515-在每个树行中找最大值、116-填充每个节点的下一个右侧节点指、117-填充每个节点的下一个右侧节点指针II、104-二叉树的最大深度、111-二叉树的最小深度\"><a href=\"#代码随想录算法训练营第十四天-102-二叉树的层序遍历、107-二叉树的层次遍历II、199-二叉树的右视图、637-二叉树的层平均值、429-N叉树的层序遍历、515-在每个树行中找最大值、116-填充每个节点的下一个右侧节点指、117-填充每个节点的下一个右侧节点指针II、104-二叉树的最大深度、111-二叉树的最小深度\" class=\"headerlink\" title=\"代码随想录算法训练营第十四天 102.二叉树的层序遍历、107.二叉树的层次遍历II、199.二叉树的右视图、637.二叉树的层平均值、429.N叉树的层序遍历、515.在每个树行中找最大值、116.填充每个节点的下一个右侧节点指、117.填充每个节点的下一个右侧节点指针II、104.二叉树的最大深度、111.二叉树的最小深度\"></a>代码随想录算法训练营第十四天 102.二叉树的层序遍历、107.二叉树的层次遍历II、199.二叉树的右视图、637.二叉树的层平均值、429.N叉树的层序遍历、515.在每个树行中找最大值、116.填充每个节点的下一个右侧节点指、117.填充每个节点的下一个右侧节点指针II、104.二叉树的最大深度、111.二叉树的最小深度</h1><blockquote>\n<p>文章讲解：<a href=\"https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1GY4y1u7b2\">讲透二叉树的层序遍历 | 广度优先搜索 | LeetCode：102.二叉树的层序遍历</a></p>\n</blockquote>\n<h2 id=\"102-二叉树的层序遍历\"><a href=\"#102-二叉树的层序遍历\" class=\"headerlink\" title=\"102. 二叉树的层序遍历\"></a>102. 二叉树的层序遍历</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>层序遍历顾名思义就是要一层一层的输出树的结点，父节点输出后还要将子节点保存一下，到下一层继续使用，这种依次使用，队列的数据结构是最合适的。父节点先入队，将两个子节点依次入队。这一层的父节点入队过后要统计有多少个，为了输出每层分别是谁</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">levelOrder</span><span class=\"hljs-params\">(root *TreeNode)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*TreeNode).Val)<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"107-二叉树的层序遍历II\"><a href=\"#107-二叉树的层序遍历II\" class=\"headerlink\" title=\"107. 二叉树的层序遍历II\"></a>107. 二叉树的层序遍历II</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/\">107.二叉树的层次遍历II</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>基本同上，这次不过要从下向上输出，翻转最后上一题的<code>result</code>即可</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">levelOrderBottom</span><span class=\"hljs-params\">(root *TreeNode)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*TreeNode).Val)<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(result)/<span class=\"hljs-number\">2</span>; i++ &#123;<br>\t\tresult[i], result[<span class=\"hljs-built_in\">len</span>(result)<span class=\"hljs-number\">-1</span>-i] = result[<span class=\"hljs-built_in\">len</span>(result)<span class=\"hljs-number\">-1</span>-i], result[i]<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"199-二叉树的右视图\"><a href=\"#199-二叉树的右视图\" class=\"headerlink\" title=\"199.二叉树的右视图\"></a>199.二叉树的右视图</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-right-side-view/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>将第一次层序遍历的结果使用二维数组逐行写出来，不难发现右视图就是二维数组每一行的最后一个元素</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">rightSideView</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> results [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*TreeNode).Val)<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresults = <span class=\"hljs-built_in\">append</span>(results, temp)<br>\t&#125;<br>\tresult := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> results &#123;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, v[<span class=\"hljs-built_in\">len</span>(v)<span class=\"hljs-number\">-1</span>])<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"637-二叉树的层平均值\"><a href=\"#637-二叉树的层平均值\" class=\"headerlink\" title=\"637.二叉树的层平均值\"></a>637.二叉树的层平均值</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/average-of-levels-in-binary-tree/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>层序每一层之后求平均值</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">averageOfLevels</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">float64</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">float64</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\tsum := <span class=\"hljs-number\">0</span><br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\tsum += node.(*TreeNode).Val<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, <span class=\"hljs-type\">float64</span>(sum)/<span class=\"hljs-type\">float64</span>(size))<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"429-N叉树的层序遍历\"><a href=\"#429-N叉树的层序遍历\" class=\"headerlink\" title=\"429.N叉树的层序遍历\"></a>429.N叉树的层序遍历</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/n-ary-tree-level-order-traversal/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>层序添加子节点改为循环遍历<code>Children</code>数组即可</p>\n<h3 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Node <span class=\"hljs-keyword\">struct</span> &#123;<br>\tVal      <span class=\"hljs-type\">int</span><br>\tChildren []*Node<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">levelOrder</span><span class=\"hljs-params\">(root *Node)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*Node).Val)<br>\t\t\t<span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-built_in\">len</span>(node.(*Node).Children); j++ &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> node.(*Node).Children[j] != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\t\tqueue.Enqueue(node.(*Node).Children[j])<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"515-在每个树行中找最大值\"><a href=\"#515-在每个树行中找最大值\" class=\"headerlink\" title=\"515.在每个树行中找最大值\"></a>515.在每个树行中找最大值</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/find-largest-value-in-each-tree-row/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-5\"><a href=\"#思路-5\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>每一层找最大，模版依旧</p>\n<h3 id=\"代码-5\"><a href=\"#代码-5\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">largestValues</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\tmaxNum := math.MinInt32<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Val &gt; maxNum &#123;<br>\t\t\t\tmaxNum = node.(*TreeNode).Val<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, maxNum)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"116-填充每个节点的下一个右侧节点指针、-117-填充每个节点的下一个右侧节点指针II\"><a href=\"#116-填充每个节点的下一个右侧节点指针、-117-填充每个节点的下一个右侧节点指针II\" class=\"headerlink\" title=\"116.填充每个节点的下一个右侧节点指针、 117.填充每个节点的下一个右侧节点指针II\"></a>116.填充每个节点的下一个右侧节点指针、 117.填充每个节点的下一个右侧节点指针II</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-6\"><a href=\"#思路-6\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>每行遍历出来看做一个链表，两道题代码思路一样</p>\n<h3 id=\"代码-6\"><a href=\"#代码-6\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><br><span class=\"hljs-comment\">// 与117题代码相同</span><br><span class=\"hljs-keyword\">type</span> Node <span class=\"hljs-keyword\">struct</span> &#123;<br>\tVal   <span class=\"hljs-type\">int</span><br>\tLeft  *Node<br>\tRight *Node<br>\tNext  *Node<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Connect</span><span class=\"hljs-params\">(root *Node)</span></span> *Node &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\troot.Next = <span class=\"hljs-literal\">nil</span><br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\t<span class=\"hljs-keyword\">var</span> p *Node = <span class=\"hljs-literal\">nil</span><br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br><br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*Node).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*Node).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*Node).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*Node).Right)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> p == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tp = node.(*Node)<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tp.Next = node.(*Node)<br>\t\t\t\tp = p.Next<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tp.Next = <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> root<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"104-二叉树的最大深度\"><a href=\"#104-二叉树的最大深度\" class=\"headerlink\" title=\"104.二叉树的最大深度\"></a>104.二叉树的最大深度</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/maximum-depth-of-binary-tree/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-7\"><a href=\"#思路-7\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>使用递归法，如果递归到叶子节点则返回0，否则使用左右叶子结点继续向下递归，深度加一。取左右结点的最大值</p>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>层序遍历，看<code>result</code>二维数组的行数</p>\n<h3 id=\"代码-7\"><a href=\"#代码-7\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 递归</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxNum</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> b<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxDepth</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> maxNum(maxDepth(root.Left), maxDepth(root.Right)) + <span class=\"hljs-number\">1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 层序</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxDepth1</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*TreeNode).Val)<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"111-二叉树的最小深度\"><a href=\"#111-二叉树的最小深度\" class=\"headerlink\" title=\"111.二叉树的最小深度\"></a>111.二叉树的最小深度</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/minimum-depth-of-binary-tree/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-8\"><a href=\"#思路-8\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一-1\"><a href=\"#方法一-1\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>使用递归法，递归终止条件如下：到达了叶子节点<code>return 1</code>。到达空节点<code>return 0</code>。分别向左和右结点继续递归，计算更小的层数，当前层递归完成后<code>return 层数加一</code></p>\n<h4 id=\"方法二-1\"><a href=\"#方法二-1\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>使用层序遍历。遍历时如果遇到叶子节点说明到达了最低点，直接<code>return 当前层数</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//递归</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minNum</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> a &lt; b &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> b<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minDepth</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>\t&#125;<br>\tminN := math.MaxInt32<br>\t<span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tminN = minNum(minDepth(root.Left), minN)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tminN = minNum(minDepth(root.Right), minN)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> minN + <span class=\"hljs-number\">1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//层序</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minDepth</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\tcount := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tcount++<br>\t\tsize := queue.Size()<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; node.(*TreeNode).Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> count<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"226-翻转二叉树\"><a href=\"#226-翻转二叉树\" class=\"headerlink\" title=\"226.翻转二叉树\"></a>226.翻转二叉树</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/invert-binary-tree/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-9\"><a href=\"#思路-9\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>交换当前结点左右子节点，向下递归</p>\n<h3 id=\"代码-8\"><a href=\"#代码-8\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">invertTree</span><span class=\"hljs-params\">(root *TreeNode)</span></span> *TreeNode &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> root<br>\t&#125;<br>\troot.Left, root.Right = root.Right, root.Left<br>\tinvertTree(root.Left)<br>\tinvertTree(root.Right)<br>\t<span class=\"hljs-keyword\">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"101-对称二叉树\"><a href=\"#101-对称二叉树\" class=\"headerlink\" title=\"101. 对称二叉树\"></a>101. 对称二叉树</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/symmetric-tree/\">力扣题目链接</a></p>\n<p>文章链接：<a href=\"https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频链接：<a href=\"https://www.bilibili.com/video/BV1ue4y1Y7Mf\">同时操作两个二叉树 | LeetCode：101. 对称二叉树</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-10\"><a href=\"#思路-10\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p><font color=\"red\">错误思路如下</font></p>\n<p>最开始想的是输出中序遍历的结果，根节点一定是最中间的数，比较两端是否对称即可。但是这种情况没考虑到</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//      1</span><br><span class=\"hljs-comment\">//     / \\</span><br><span class=\"hljs-comment\">//    2   2</span><br><span class=\"hljs-comment\">//   /   /</span><br><span class=\"hljs-comment\">//  2   2</span><br></code></pre></td></tr></table></figure>\n\n<p>所以这个思路是错的</p>\n<hr>\n<p><font color=\"green\">正确思路如下</font></p>\n<p>用后序遍历和“伪后序遍历”依次比较子树。后序遍历是左右根，伪后序比那里是右左根，这样可以比较相同的结点。</p>\n<p>使用递归需要做如下判断</p>\n<ul>\n<li>递归函数的构造<ul>\n<li>比较左右结点，传参是两个节点<code>func compare(left, right *TreeNode) bool</code></li>\n</ul>\n</li>\n<li>递归终止条件<ul>\n<li>两个节点均为空节点，对称<code>return true</code></li>\n<li>左空右不空，或，左不空右空，不对称<code>return false</code></li>\n<li>左右均不空，但是值不同，不对称<code>return false</code></li>\n</ul>\n</li>\n<li>单次递归逻辑<ul>\n<li>左节点的左 和 右结点的右  向下递归</li>\n<li>且 左节点的右 和 右结点的左  向下递归</li>\n<li>且二者值均为<code>true</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码-9\"><a href=\"#代码-9\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(left, right *TreeNode)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> left == <span class=\"hljs-literal\">nil</span> &amp;&amp; right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> left != <span class=\"hljs-literal\">nil</span> &amp;&amp; right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> left == <span class=\"hljs-literal\">nil</span> &amp;&amp; right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> left.Val != right.Val &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> compare(left.Left, right.Right) &amp;&amp; compare(left.Right, right.Left)<br><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isSymmetric</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> compare(root.Left, root.Right)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第十四天-102-二叉树的层序遍历、107-二叉树的层次遍历II、199-二叉树的右视图、637-二叉树的层平均值、429-N叉树的层序遍历、515-在每个树行中找最大值、116-填充每个节点的下一个右侧节点指、117-填充每个节点的下一个右侧节点指针II、104-二叉树的最大深度、111-二叉树的最小深度\"><a href=\"#代码随想录算法训练营第十四天-102-二叉树的层序遍历、107-二叉树的层次遍历II、199-二叉树的右视图、637-二叉树的层平均值、429-N叉树的层序遍历、515-在每个树行中找最大值、116-填充每个节点的下一个右侧节点指、117-填充每个节点的下一个右侧节点指针II、104-二叉树的最大深度、111-二叉树的最小深度\" class=\"headerlink\" title=\"代码随想录算法训练营第十四天 102.二叉树的层序遍历、107.二叉树的层次遍历II、199.二叉树的右视图、637.二叉树的层平均值、429.N叉树的层序遍历、515.在每个树行中找最大值、116.填充每个节点的下一个右侧节点指、117.填充每个节点的下一个右侧节点指针II、104.二叉树的最大深度、111.二叉树的最小深度\"></a>代码随想录算法训练营第十四天 102.二叉树的层序遍历、107.二叉树的层次遍历II、199.二叉树的右视图、637.二叉树的层平均值、429.N叉树的层序遍历、515.在每个树行中找最大值、116.填充每个节点的下一个右侧节点指、117.填充每个节点的下一个右侧节点指针II、104.二叉树的最大深度、111.二叉树的最小深度</h1><blockquote>\n<p>文章讲解：<a href=\"https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1GY4y1u7b2\">讲透二叉树的层序遍历 | 广度优先搜索 | LeetCode：102.二叉树的层序遍历</a></p>\n</blockquote>\n<h2 id=\"102-二叉树的层序遍历\"><a href=\"#102-二叉树的层序遍历\" class=\"headerlink\" title=\"102. 二叉树的层序遍历\"></a>102. 二叉树的层序遍历</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>层序遍历顾名思义就是要一层一层的输出树的结点，父节点输出后还要将子节点保存一下，到下一层继续使用，这种依次使用，队列的数据结构是最合适的。父节点先入队，将两个子节点依次入队。这一层的父节点入队过后要统计有多少个，为了输出每层分别是谁</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">levelOrder</span><span class=\"hljs-params\">(root *TreeNode)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*TreeNode).Val)<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"107-二叉树的层序遍历II\"><a href=\"#107-二叉树的层序遍历II\" class=\"headerlink\" title=\"107. 二叉树的层序遍历II\"></a>107. 二叉树的层序遍历II</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/\">107.二叉树的层次遍历II</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>基本同上，这次不过要从下向上输出，翻转最后上一题的<code>result</code>即可</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">levelOrderBottom</span><span class=\"hljs-params\">(root *TreeNode)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*TreeNode).Val)<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(result)/<span class=\"hljs-number\">2</span>; i++ &#123;<br>\t\tresult[i], result[<span class=\"hljs-built_in\">len</span>(result)<span class=\"hljs-number\">-1</span>-i] = result[<span class=\"hljs-built_in\">len</span>(result)<span class=\"hljs-number\">-1</span>-i], result[i]<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"199-二叉树的右视图\"><a href=\"#199-二叉树的右视图\" class=\"headerlink\" title=\"199.二叉树的右视图\"></a>199.二叉树的右视图</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-right-side-view/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>将第一次层序遍历的结果使用二维数组逐行写出来，不难发现右视图就是二维数组每一行的最后一个元素</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">rightSideView</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> results [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*TreeNode).Val)<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresults = <span class=\"hljs-built_in\">append</span>(results, temp)<br>\t&#125;<br>\tresult := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> results &#123;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, v[<span class=\"hljs-built_in\">len</span>(v)<span class=\"hljs-number\">-1</span>])<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"637-二叉树的层平均值\"><a href=\"#637-二叉树的层平均值\" class=\"headerlink\" title=\"637.二叉树的层平均值\"></a>637.二叉树的层平均值</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/average-of-levels-in-binary-tree/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>层序每一层之后求平均值</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">averageOfLevels</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">float64</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">float64</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\tsum := <span class=\"hljs-number\">0</span><br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\tsum += node.(*TreeNode).Val<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, <span class=\"hljs-type\">float64</span>(sum)/<span class=\"hljs-type\">float64</span>(size))<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"429-N叉树的层序遍历\"><a href=\"#429-N叉树的层序遍历\" class=\"headerlink\" title=\"429.N叉树的层序遍历\"></a>429.N叉树的层序遍历</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/n-ary-tree-level-order-traversal/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>层序添加子节点改为循环遍历<code>Children</code>数组即可</p>\n<h3 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Node <span class=\"hljs-keyword\">struct</span> &#123;<br>\tVal      <span class=\"hljs-type\">int</span><br>\tChildren []*Node<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">levelOrder</span><span class=\"hljs-params\">(root *Node)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*Node).Val)<br>\t\t\t<span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-built_in\">len</span>(node.(*Node).Children); j++ &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> node.(*Node).Children[j] != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\t\tqueue.Enqueue(node.(*Node).Children[j])<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"515-在每个树行中找最大值\"><a href=\"#515-在每个树行中找最大值\" class=\"headerlink\" title=\"515.在每个树行中找最大值\"></a>515.在每个树行中找最大值</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/find-largest-value-in-each-tree-row/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-5\"><a href=\"#思路-5\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>每一层找最大，模版依旧</p>\n<h3 id=\"代码-5\"><a href=\"#代码-5\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">largestValues</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result []<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> result<br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\tmaxNum := math.MinInt32<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Val &gt; maxNum &#123;<br>\t\t\t\tmaxNum = node.(*TreeNode).Val<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, maxNum)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"116-填充每个节点的下一个右侧节点指针、-117-填充每个节点的下一个右侧节点指针II\"><a href=\"#116-填充每个节点的下一个右侧节点指针、-117-填充每个节点的下一个右侧节点指针II\" class=\"headerlink\" title=\"116.填充每个节点的下一个右侧节点指针、 117.填充每个节点的下一个右侧节点指针II\"></a>116.填充每个节点的下一个右侧节点指针、 117.填充每个节点的下一个右侧节点指针II</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-6\"><a href=\"#思路-6\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>每行遍历出来看做一个链表，两道题代码思路一样</p>\n<h3 id=\"代码-6\"><a href=\"#代码-6\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><br><span class=\"hljs-comment\">// 与117题代码相同</span><br><span class=\"hljs-keyword\">type</span> Node <span class=\"hljs-keyword\">struct</span> &#123;<br>\tVal   <span class=\"hljs-type\">int</span><br>\tLeft  *Node<br>\tRight *Node<br>\tNext  *Node<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Connect</span><span class=\"hljs-params\">(root *Node)</span></span> *Node &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\troot.Next = <span class=\"hljs-literal\">nil</span><br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\t<span class=\"hljs-keyword\">var</span> p *Node = <span class=\"hljs-literal\">nil</span><br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br><br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*Node).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*Node).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*Node).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*Node).Right)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> p == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tp = node.(*Node)<br>\t\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\tp.Next = node.(*Node)<br>\t\t\t\tp = p.Next<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tp.Next = <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> root<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"104-二叉树的最大深度\"><a href=\"#104-二叉树的最大深度\" class=\"headerlink\" title=\"104.二叉树的最大深度\"></a>104.二叉树的最大深度</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/maximum-depth-of-binary-tree/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-7\"><a href=\"#思路-7\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>使用递归法，如果递归到叶子节点则返回0，否则使用左右叶子结点继续向下递归，深度加一。取左右结点的最大值</p>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>层序遍历，看<code>result</code>二维数组的行数</p>\n<h3 id=\"代码-7\"><a href=\"#代码-7\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 递归</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxNum</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> b<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxDepth</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> maxNum(maxDepth(root.Left), maxDepth(root.Right)) + <span class=\"hljs-number\">1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 层序</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxDepth1</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*TreeNode).Val)<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"111-二叉树的最小深度\"><a href=\"#111-二叉树的最小深度\" class=\"headerlink\" title=\"111.二叉树的最小深度\"></a>111.二叉树的最小深度</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/minimum-depth-of-binary-tree/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-8\"><a href=\"#思路-8\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一-1\"><a href=\"#方法一-1\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>使用递归法，递归终止条件如下：到达了叶子节点<code>return 1</code>。到达空节点<code>return 0</code>。分别向左和右结点继续递归，计算更小的层数，当前层递归完成后<code>return 层数加一</code></p>\n<h4 id=\"方法二-1\"><a href=\"#方法二-1\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>使用层序遍历。遍历时如果遇到叶子节点说明到达了最低点，直接<code>return 当前层数</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//递归</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minNum</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> a &lt; b &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> b<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minDepth</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>\t&#125;<br>\tminN := math.MaxInt32<br>\t<span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tminN = minNum(minDepth(root.Left), minN)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tminN = minNum(minDepth(root.Right), minN)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> minN + <span class=\"hljs-number\">1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//层序</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minDepth</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\tcount := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tcount++<br>\t\tsize := queue.Size()<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; node.(*TreeNode).Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> count<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"226-翻转二叉树\"><a href=\"#226-翻转二叉树\" class=\"headerlink\" title=\"226.翻转二叉树\"></a>226.翻转二叉树</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/invert-binary-tree/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-9\"><a href=\"#思路-9\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>交换当前结点左右子节点，向下递归</p>\n<h3 id=\"代码-8\"><a href=\"#代码-8\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">invertTree</span><span class=\"hljs-params\">(root *TreeNode)</span></span> *TreeNode &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> root<br>\t&#125;<br>\troot.Left, root.Right = root.Right, root.Left<br>\tinvertTree(root.Left)<br>\tinvertTree(root.Right)<br>\t<span class=\"hljs-keyword\">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"101-对称二叉树\"><a href=\"#101-对称二叉树\" class=\"headerlink\" title=\"101. 对称二叉树\"></a>101. 对称二叉树</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/symmetric-tree/\">力扣题目链接</a></p>\n<p>文章链接：<a href=\"https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html\">代码随想录(programmercarl.com)</a></p>\n<p>视频链接：<a href=\"https://www.bilibili.com/video/BV1ue4y1Y7Mf\">同时操作两个二叉树 | LeetCode：101. 对称二叉树</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-10\"><a href=\"#思路-10\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p><font color=\"red\">错误思路如下</font></p>\n<p>最开始想的是输出中序遍历的结果，根节点一定是最中间的数，比较两端是否对称即可。但是这种情况没考虑到</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//      1</span><br><span class=\"hljs-comment\">//     / \\</span><br><span class=\"hljs-comment\">//    2   2</span><br><span class=\"hljs-comment\">//   /   /</span><br><span class=\"hljs-comment\">//  2   2</span><br></code></pre></td></tr></table></figure>\n\n<p>所以这个思路是错的</p>\n<hr>\n<p><font color=\"green\">正确思路如下</font></p>\n<p>用后序遍历和“伪后序遍历”依次比较子树。后序遍历是左右根，伪后序比那里是右左根，这样可以比较相同的结点。</p>\n<p>使用递归需要做如下判断</p>\n<ul>\n<li>递归函数的构造<ul>\n<li>比较左右结点，传参是两个节点<code>func compare(left, right *TreeNode) bool</code></li>\n</ul>\n</li>\n<li>递归终止条件<ul>\n<li>两个节点均为空节点，对称<code>return true</code></li>\n<li>左空右不空，或，左不空右空，不对称<code>return false</code></li>\n<li>左右均不空，但是值不同，不对称<code>return false</code></li>\n</ul>\n</li>\n<li>单次递归逻辑<ul>\n<li>左节点的左 和 右结点的右  向下递归</li>\n<li>且 左节点的右 和 右结点的左  向下递归</li>\n<li>且二者值均为<code>true</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码-9\"><a href=\"#代码-9\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(left, right *TreeNode)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> left == <span class=\"hljs-literal\">nil</span> &amp;&amp; right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> left != <span class=\"hljs-literal\">nil</span> &amp;&amp; right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> left == <span class=\"hljs-literal\">nil</span> &amp;&amp; right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> left.Val != right.Val &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> compare(left.Left, right.Right) &amp;&amp; compare(left.Right, right.Left)<br><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isSymmetric</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> compare(root.Left, root.Right)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"代码随想录算法训练营第十五天 104.二叉树的最大深度、559.n叉树的最大深度","abbrlink":"e2c426b8","date":"2023-10-07T13:33:49.000Z","_content":"\n# 代码随想录算法训练营第十五天 104.二叉树的最大深度、559.n叉树的最大深度\n\n##  104.二叉树的最大深度\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n>\n> 文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html)\n>\n> 视频讲解：[二叉树的高度和深度有啥区别？究竟用什么遍历顺序？很多录友搞不懂 | 104.二叉树的最大深度](https://www.bilibili.com/video/BV1Gd4y1V75u)\n>\n> 状态：AC\n\n### 思路\n\n#### 方法一\n\n使用递归法，如果递归到叶子节点则返回0，否则使用左右叶子结点继续向下递归，深度加一。取左右结点的最大值\n\n#### 方法二\n\n层序遍历，看`result`二维数组的行数\n\n### 代码\n\n``` go\n// 递归\nfunc maxNum(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\treturn maxNum(maxDepth(root.Left), maxDepth(root.Right)) + 1\n}\n```\n\n``` go\n// 层序\nfunc maxDepth1(root *TreeNode) int {\n\tvar result [][]int\n\tif root == nil {\n\t\treturn 0\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*TreeNode).Val)\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\treturn len(result)\n}\n```\n\n## 559. N 叉树的最大深度\n\n> 题目链接：[559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)\n>\n> 状态：AC\n\n### 思路\n\n#### 方法一\n\n递归遍历每个子树，叶子节点时候`return 0`，否则下一层深度加一\n\n#### 方法二\n\n每一层遍历时候入队的不是`Left`和`Right`，而是每一个`Children[i]`节点，最后输出`result`的大小\n\n### 代码\n\n``` go\n// 递归法\nfunc maxNum(a, b int) int {\n     if a > b {\n         return a\n     }\n     return b\n }\n\nfunc maxDepth(root *Node) int {\n    if root == nil {\n\t\treturn 0\n\t}\n\tdepth := 1\n\tfor _, v := range root.Children {\n\t\tdepth = maxNum(depth, maxDepth(v)+1)\n\t}\n\treturn depth\n}\n```\n\n\n\n``` go\n//层先法\nfunc maxDepth(root *Node) int {\n    var result [][]int\n\tif root == nil {\n\t\treturn 0\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\tvar temp []int\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*Node).Val)\n\t\t\tfor j := 0; j < len(node.(*Node).Children); j++ {\n\t\t\t\tif node.(*Node).Children[j] != nil {\n\t\t\t\t\tqueue.Enqueue(node.(*Node).Children[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\treturn len(result)\n}\n```\n\n## 111.二叉树的最小深度\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\n>\n> 状态：AC\n\n### 思路\n\n#### 方法一\n\n使用递归法，递归终止条件如下：到达了叶子节点`return 1`。到达空节点`return 0`。分别向左和右结点继续递归，计算更小的层数，当前层递归完成后`return 层数加一`\n\n#### 方法二\n\n使用层序遍历。遍历时如果遇到叶子节点说明到达了最低点，直接`return 当前层数`\n\n``` go\n//递归\nfunc minNum(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc minDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tif root.Left == nil && root.Right == nil {\n\t\treturn 1\n\t}\n\tminN := math.MaxInt32\n\tif root.Left != nil {\n\t\tminN = minNum(minDepth(root.Left), minN)\n\t}\n\tif root.Right != nil {\n\t\tminN = minNum(minDepth(root.Right), minN)\n\t}\n\treturn minN + 1\n}\n```\n\n``` go\n//层序\nfunc minDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tcount := 0\n\tfor !queue.Empty() {\n\t\tcount++\n\t\tsize := queue.Size()\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Left == nil && node.(*TreeNode).Right == nil {\n\t\t\t\treturn count\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n```\n\n## 222. 完全二叉树的节点个数\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/count-complete-tree-nodes/)\n>\n> 文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%80%9D%E8%B7%AF)\n>\n> 视频讲解：[要理解普通二叉树和完全二叉树的区别！ | LeetCode：222.完全二叉树节点的数量](https://www.bilibili.com/video/BV1eW4y1B7pD)\n>\n> 状态：AC\n\n### 思路\n\n#### 方法一\n\n使用前序、中序、后序、前序遍历都可，输出节点个数\n\n### 代码\n\n``` go\n// 前序遍历\nfunc countNodes(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tcount := 0\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\tcount++\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n```\n\n","source":"_posts/day15.md","raw":"---\ntitle: 代码随想录算法训练营第十五天 104.二叉树的最大深度、559.n叉树的最大深度\nabbrlink: e2c426b8\ndate: 2023-10-07 21:33:49\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\n---\n\n# 代码随想录算法训练营第十五天 104.二叉树的最大深度、559.n叉树的最大深度\n\n##  104.二叉树的最大深度\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n>\n> 文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html)\n>\n> 视频讲解：[二叉树的高度和深度有啥区别？究竟用什么遍历顺序？很多录友搞不懂 | 104.二叉树的最大深度](https://www.bilibili.com/video/BV1Gd4y1V75u)\n>\n> 状态：AC\n\n### 思路\n\n#### 方法一\n\n使用递归法，如果递归到叶子节点则返回0，否则使用左右叶子结点继续向下递归，深度加一。取左右结点的最大值\n\n#### 方法二\n\n层序遍历，看`result`二维数组的行数\n\n### 代码\n\n``` go\n// 递归\nfunc maxNum(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\treturn maxNum(maxDepth(root.Left), maxDepth(root.Right)) + 1\n}\n```\n\n``` go\n// 层序\nfunc maxDepth1(root *TreeNode) int {\n\tvar result [][]int\n\tif root == nil {\n\t\treturn 0\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*TreeNode).Val)\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\treturn len(result)\n}\n```\n\n## 559. N 叉树的最大深度\n\n> 题目链接：[559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)\n>\n> 状态：AC\n\n### 思路\n\n#### 方法一\n\n递归遍历每个子树，叶子节点时候`return 0`，否则下一层深度加一\n\n#### 方法二\n\n每一层遍历时候入队的不是`Left`和`Right`，而是每一个`Children[i]`节点，最后输出`result`的大小\n\n### 代码\n\n``` go\n// 递归法\nfunc maxNum(a, b int) int {\n     if a > b {\n         return a\n     }\n     return b\n }\n\nfunc maxDepth(root *Node) int {\n    if root == nil {\n\t\treturn 0\n\t}\n\tdepth := 1\n\tfor _, v := range root.Children {\n\t\tdepth = maxNum(depth, maxDepth(v)+1)\n\t}\n\treturn depth\n}\n```\n\n\n\n``` go\n//层先法\nfunc maxDepth(root *Node) int {\n    var result [][]int\n\tif root == nil {\n\t\treturn 0\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\tvar temp []int\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*Node).Val)\n\t\t\tfor j := 0; j < len(node.(*Node).Children); j++ {\n\t\t\t\tif node.(*Node).Children[j] != nil {\n\t\t\t\t\tqueue.Enqueue(node.(*Node).Children[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\treturn len(result)\n}\n```\n\n## 111.二叉树的最小深度\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\n>\n> 状态：AC\n\n### 思路\n\n#### 方法一\n\n使用递归法，递归终止条件如下：到达了叶子节点`return 1`。到达空节点`return 0`。分别向左和右结点继续递归，计算更小的层数，当前层递归完成后`return 层数加一`\n\n#### 方法二\n\n使用层序遍历。遍历时如果遇到叶子节点说明到达了最低点，直接`return 当前层数`\n\n``` go\n//递归\nfunc minNum(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc minDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tif root.Left == nil && root.Right == nil {\n\t\treturn 1\n\t}\n\tminN := math.MaxInt32\n\tif root.Left != nil {\n\t\tminN = minNum(minDepth(root.Left), minN)\n\t}\n\tif root.Right != nil {\n\t\tminN = minNum(minDepth(root.Right), minN)\n\t}\n\treturn minN + 1\n}\n```\n\n``` go\n//层序\nfunc minDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tcount := 0\n\tfor !queue.Empty() {\n\t\tcount++\n\t\tsize := queue.Size()\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Left == nil && node.(*TreeNode).Right == nil {\n\t\t\t\treturn count\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n```\n\n## 222. 完全二叉树的节点个数\n\n> 题目链接：[力扣题目链接](https://leetcode.cn/problems/count-complete-tree-nodes/)\n>\n> 文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%80%9D%E8%B7%AF)\n>\n> 视频讲解：[要理解普通二叉树和完全二叉树的区别！ | LeetCode：222.完全二叉树节点的数量](https://www.bilibili.com/video/BV1eW4y1B7pD)\n>\n> 状态：AC\n\n### 思路\n\n#### 方法一\n\n使用前序、中序、后序、前序遍历都可，输出节点个数\n\n### 代码\n\n``` go\n// 前序遍历\nfunc countNodes(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tqueue := arrayqueue.New()\n\tqueue.Enqueue(root)\n\tcount := 0\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\tcount++\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n```\n\n","slug":"day15","published":1,"updated":"2023-10-07T15:13:36.374Z","_id":"clng3wbhv0001t4wh0pjq02ff","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第十五天-104-二叉树的最大深度、559-n叉树的最大深度\"><a href=\"#代码随想录算法训练营第十五天-104-二叉树的最大深度、559-n叉树的最大深度\" class=\"headerlink\" title=\"代码随想录算法训练营第十五天 104.二叉树的最大深度、559.n叉树的最大深度\"></a>代码随想录算法训练营第十五天 104.二叉树的最大深度、559.n叉树的最大深度</h1><h2 id=\"104-二叉树的最大深度\"><a href=\"#104-二叉树的最大深度\" class=\"headerlink\" title=\"104.二叉树的最大深度\"></a>104.二叉树的最大深度</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/maximum-depth-of-binary-tree/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1Gd4y1V75u\">二叉树的高度和深度有啥区别？究竟用什么遍历顺序？很多录友搞不懂 | 104.二叉树的最大深度</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>使用递归法，如果递归到叶子节点则返回0，否则使用左右叶子结点继续向下递归，深度加一。取左右结点的最大值</p>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>层序遍历，看<code>result</code>二维数组的行数</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 递归</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxNum</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> b<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxDepth</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> maxNum(maxDepth(root.Left), maxDepth(root.Right)) + <span class=\"hljs-number\">1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 层序</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxDepth1</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*TreeNode).Val)<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"559-N-叉树的最大深度\"><a href=\"#559-N-叉树的最大深度\" class=\"headerlink\" title=\"559. N 叉树的最大深度\"></a>559. N 叉树的最大深度</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/\">559. N 叉树的最大深度</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一-1\"><a href=\"#方法一-1\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>递归遍历每个子树，叶子节点时候<code>return 0</code>，否则下一层深度加一</p>\n<h4 id=\"方法二-1\"><a href=\"#方法二-1\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>每一层遍历时候入队的不是<code>Left</code>和<code>Right</code>，而是每一个<code>Children[i]</code>节点，最后输出<code>result</code>的大小</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 递归法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxNum</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>     <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>         <span class=\"hljs-keyword\">return</span> a<br>     &#125;<br>     <span class=\"hljs-keyword\">return</span> b<br> &#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxDepth</span><span class=\"hljs-params\">(root *Node)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tdepth := <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> root.Children &#123;<br>\t\tdepth = maxNum(depth, maxDepth(v)+<span class=\"hljs-number\">1</span>)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//层先法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxDepth</span><span class=\"hljs-params\">(root *Node)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\t<span class=\"hljs-keyword\">var</span> temp []<span class=\"hljs-type\">int</span><br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*Node).Val)<br>\t\t\t<span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-built_in\">len</span>(node.(*Node).Children); j++ &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> node.(*Node).Children[j] != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\t\tqueue.Enqueue(node.(*Node).Children[j])<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"111-二叉树的最小深度\"><a href=\"#111-二叉树的最小深度\" class=\"headerlink\" title=\"111.二叉树的最小深度\"></a>111.二叉树的最小深度</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/minimum-depth-of-binary-tree/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一-2\"><a href=\"#方法一-2\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>使用递归法，递归终止条件如下：到达了叶子节点<code>return 1</code>。到达空节点<code>return 0</code>。分别向左和右结点继续递归，计算更小的层数，当前层递归完成后<code>return 层数加一</code></p>\n<h4 id=\"方法二-2\"><a href=\"#方法二-2\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>使用层序遍历。遍历时如果遇到叶子节点说明到达了最低点，直接<code>return 当前层数</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//递归</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minNum</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> a &lt; b &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> b<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minDepth</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>\t&#125;<br>\tminN := math.MaxInt32<br>\t<span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tminN = minNum(minDepth(root.Left), minN)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tminN = minNum(minDepth(root.Right), minN)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> minN + <span class=\"hljs-number\">1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//层序</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minDepth</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\tcount := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tcount++<br>\t\tsize := queue.Size()<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; node.(*TreeNode).Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> count<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"222-完全二叉树的节点个数\"><a href=\"#222-完全二叉树的节点个数\" class=\"headerlink\" title=\"222. 完全二叉树的节点个数\"></a>222. 完全二叉树的节点个数</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/count-complete-tree-nodes/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%80%9D%E8%B7%AF\">代码随想录(https://programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1eW4y1B7pD\">要理解普通二叉树和完全二叉树的区别！ | LeetCode：222.完全二叉树节点的数量</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一-3\"><a href=\"#方法一-3\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>使用前序、中序、后序、前序遍历都可，输出节点个数</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 前序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">countNodes</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\tcount := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\tcount++<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第十五天-104-二叉树的最大深度、559-n叉树的最大深度\"><a href=\"#代码随想录算法训练营第十五天-104-二叉树的最大深度、559-n叉树的最大深度\" class=\"headerlink\" title=\"代码随想录算法训练营第十五天 104.二叉树的最大深度、559.n叉树的最大深度\"></a>代码随想录算法训练营第十五天 104.二叉树的最大深度、559.n叉树的最大深度</h1><h2 id=\"104-二叉树的最大深度\"><a href=\"#104-二叉树的最大深度\" class=\"headerlink\" title=\"104.二叉树的最大深度\"></a>104.二叉树的最大深度</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/maximum-depth-of-binary-tree/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1Gd4y1V75u\">二叉树的高度和深度有啥区别？究竟用什么遍历顺序？很多录友搞不懂 | 104.二叉树的最大深度</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>使用递归法，如果递归到叶子节点则返回0，否则使用左右叶子结点继续向下递归，深度加一。取左右结点的最大值</p>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>层序遍历，看<code>result</code>二维数组的行数</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 递归</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxNum</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> b<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxDepth</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> maxNum(maxDepth(root.Left), maxDepth(root.Right)) + <span class=\"hljs-number\">1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 层序</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxDepth1</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*TreeNode).Val)<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"559-N-叉树的最大深度\"><a href=\"#559-N-叉树的最大深度\" class=\"headerlink\" title=\"559. N 叉树的最大深度\"></a>559. N 叉树的最大深度</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/\">559. N 叉树的最大深度</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一-1\"><a href=\"#方法一-1\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>递归遍历每个子树，叶子节点时候<code>return 0</code>，否则下一层深度加一</p>\n<h4 id=\"方法二-1\"><a href=\"#方法二-1\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>每一层遍历时候入队的不是<code>Left</code>和<code>Right</code>，而是每一个<code>Children[i]</code>节点，最后输出<code>result</code>的大小</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 递归法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxNum</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>     <span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>         <span class=\"hljs-keyword\">return</span> a<br>     &#125;<br>     <span class=\"hljs-keyword\">return</span> b<br> &#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxDepth</span><span class=\"hljs-params\">(root *Node)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tdepth := <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> root.Children &#123;<br>\t\tdepth = maxNum(depth, maxDepth(v)+<span class=\"hljs-number\">1</span>)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//层先法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxDepth</span><span class=\"hljs-params\">(root *Node)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\t<span class=\"hljs-keyword\">var</span> temp []<span class=\"hljs-type\">int</span><br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*Node).Val)<br>\t\t\t<span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-built_in\">len</span>(node.(*Node).Children); j++ &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> node.(*Node).Children[j] != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\t\tqueue.Enqueue(node.(*Node).Children[j])<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"111-二叉树的最小深度\"><a href=\"#111-二叉树的最小深度\" class=\"headerlink\" title=\"111.二叉树的最小深度\"></a>111.二叉树的最小深度</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/minimum-depth-of-binary-tree/\">力扣题目链接</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一-2\"><a href=\"#方法一-2\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>使用递归法，递归终止条件如下：到达了叶子节点<code>return 1</code>。到达空节点<code>return 0</code>。分别向左和右结点继续递归，计算更小的层数，当前层递归完成后<code>return 层数加一</code></p>\n<h4 id=\"方法二-2\"><a href=\"#方法二-2\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>使用层序遍历。遍历时如果遇到叶子节点说明到达了最低点，直接<code>return 当前层数</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//递归</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minNum</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> a &lt; b &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> b<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minDepth</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>\t&#125;<br>\tminN := math.MaxInt32<br>\t<span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tminN = minNum(minDepth(root.Left), minN)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tminN = minNum(minDepth(root.Right), minN)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> minN + <span class=\"hljs-number\">1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//层序</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minDepth</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\tcount := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tcount++<br>\t\tsize := queue.Size()<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; node.(*TreeNode).Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> count<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"222-完全二叉树的节点个数\"><a href=\"#222-完全二叉树的节点个数\" class=\"headerlink\" title=\"222. 完全二叉树的节点个数\"></a>222. 完全二叉树的节点个数</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode.cn/problems/count-complete-tree-nodes/\">力扣题目链接</a></p>\n<p>文章讲解：<a href=\"https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%80%9D%E8%B7%AF\">代码随想录(https://programmercarl.com)</a></p>\n<p>视频讲解：<a href=\"https://www.bilibili.com/video/BV1eW4y1B7pD\">要理解普通二叉树和完全二叉树的区别！ | LeetCode：222.完全二叉树节点的数量</a></p>\n<p>状态：AC</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"方法一-3\"><a href=\"#方法一-3\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>使用前序、中序、后序、前序遍历都可，输出节点个数</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 前序遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">countNodes</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tqueue := arrayqueue.New()<br>\tqueue.Enqueue(root)<br>\tcount := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\tcount++<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"代码随想录算法训练营第十七天 110.平衡二叉树、257. 二叉树的所有路径、404.左叶子之和","abbrlink":"467977b0","date":"2023-10-09T15:26:52.000Z","_content":"\n# 代码随想录算法训练营第十七天 110.平衡二叉树、257. 二叉树的所有路径、404.左叶子之和\n\n## 110. 平衡二叉树\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/balanced-binary-tree/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html)\n>\n>   视频讲解：[后序遍历求高度，高度判断是否平衡 | LeetCode：110.平衡二叉树](https://www.bilibili.com/video/BV1Ug411S7my)\n>\n>   状态：AC\n\n### 思路\n\n由之前的104题：求二叉树最大深度一讲，卡哥提到过深度和高度的区别，结合这道题的视频看懂了。举个例子，我们现在站在地上，看见一幢楼会说：“这楼有多高？”；看见一个坑，会说：“这坑有多深？”。也就是说高度要从下往上看、深度要从上往下看。从下向上自然就需要后序遍历。\n\n1.   每个叶子节点的高度为1，叶子节点的子节点（也就是两个空节点）高度为0；\n2.   定义左子树高度为`leftHeight`，左子树递归返回左子树的高度，如果高度为`-1`则执行`return -1`；\n3.   定义右子树高度为`rightHeight`，右子树递归返回右子树的高度，如果高度为`-1`则执行`return -1`；\n4.   比较左右子树高度差，差的绝对值小于等于1，说明是平衡二叉树，将最高的子树高度加一，回到2、3步继续。否则不为平衡二叉树，`return -1`。\n\n### 代码\n\n``` go\n// 平衡二叉树\nfunc isBalanced(root *TreeNode) bool {\n\treturn backTracking(root) != -1\n}\n// 返回最大值\nfunc maxNum(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc backTracking(root *TreeNode) int {\n    // 空节点\n\tif root == nil {\n\t\treturn 0\n\t}\n\t// left child\n\tleftHeight := backTracking(root.Left)\n\tif leftHeight == -1 {\n\t\treturn -1\n\t}\n\t// right child\n\trightHeight := backTracking(root.Right)\n\tif rightHeight == -1 {\n\t\treturn -1\n\t}\n\t// 不是平衡二叉树\n\tif rightHeight-leftHeight > 1 || rightHeight-leftHeight < -1 {\n\t\treturn -1\n\t} else {\n\t\treturn maxNum(rightHeight, leftHeight) + 1  //高度加一继续返回\n\t}\n}\n```\n\n## 257. 二叉树的所有路径\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/binary-tree-paths/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html)\n>\n>   视频讲解：[递归中带着回溯，你感受到了没？| LeetCode：257. 二叉树的所有路径](https://www.bilibili.com/video/BV1ZG411G7Dh)\n>\n>   状态：AC\n\n### 思路\n\n回溯算法的比较典型的应用，要输出所有的路径，应该使用先序遍历。走到叶子结点后将路径添加至最后的结果。\n\n卡哥回溯三部曲：\n\n1.   确立函数参数和返回值：由于是Go语言，全局变量在LeetCode中会出现一些问题，具体可以查看这篇我的这篇博客[Go语言刷LeetCode使用全局变量的问题](https://promisewang.github.io/post/bc862a56.html#%E9%81%87%E5%88%B0%E6%9C%80%E5%A4%B4%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81)。函数变量包括：\n     -   根节点`root`\n     -   这道题的结果`result`\n     -   一条路径`path`\n2.   确定终止条件：当前节点为子节点时，保存`path`到`result`，`return`\n3.   单次递归：左节点不为空，向左递归；右节点不为空；向右递归\n\n### 代码\n\n``` go\nfunc binaryTreePaths(root *TreeNode) []string {\n\tresult := []string{}\n\tpath := []int{}\n\tgetResult(root, &result, &path)\n\treturn result\n}\n\nfunc getResult(root *TreeNode, result *[]string, path *[]int) {\n    // 终止条件，并且将切片类型的path按要求写成字符串，添加到result中。\n\tif root.Left == nil && root.Right == nil {\n\t\t*path = append(*path, root.Val) //添加新的节点\n\t\tvar temp string\n\t\tif len(*path) == 1 {\n\t\t\ttemp = \"1\"\n\t\t} else {\n\t\t\ttemp = strconv.Itoa((*path)[0])\n\t\t\tfor i := 1; i < len(*path); i++ {\n\t\t\t\ttemp += \"->\" + strconv.Itoa((*path)[i])\n\t\t\t}\n\t\t}\n\t\t*path = (*path)[:len(*path)-1]\n\t\t*result = append(*result, temp)\n\t\treturn\n\t}\n    // 左节点不为空，向左递归\n\tif root.Left != nil {\n\t\t*path = append(*path, root.Val)\n\t\tgetResult(root.Left, result, path)\n\t\t*path = (*path)[:len(*path)-1]\n\t}\n    \n    // 右节点不为空，向右递归\n\tif root.Right != nil {\n\t\t*path = append(*path, root.Val)\n\t\tgetResult(root.Right, result, path)\n\t\t*path = (*path)[:len(*path)-1]\n\t}\n}\n\n```\n\n## 404.左叶子之和\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/sum-of-left-leaves/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html)\n>\n>   视频讲解：[二叉树的题目中，总有一些规则让你找不到北 | LeetCode：404.左叶子之和](https://www.bilibili.com/video/BV1GY4y1K7z8)\n>\n>   状态：AC\n\n### 思路\n\n要判断的是所有左叶子的和，选择先序遍历。递归三部曲请出来：\n\n1.   确立函数参数和返回值：此处没有用全局变量，需要使用一个指针存放和。如何判断是左节点，我这里引入一个变量`flag`为`bool`类型。如果向左节点递归，则为`true`，否则为`false`。这样当到达叶子节点时候判断`flag`值就能知道是不是左叶子\n     -   根节点`root`\n     -   和指针`sum`\n     -   是否为左节点`flag`\n2.   确定终止条件：如果是叶子节点，并且`flag == true`，`*sum += root.Val`，返回。\n3.   单次递归：如果左节点不为空，向左递归，`flag = true`；如果右结点不为空，向右递归，`flag = false`\n\n### 代码\n\n``` go\nfunc sumOfLeftLeaves(root *TreeNode) int {\n\tif root.Left == nil && root.Right == nil {\n\t\treturn 0\n\t}\n\tsum := 0\n\tgetSum(root, &sum, false)\n\treturn sum\n}\n\n// flag为true, 代表左节点; 否则是右结点\nfunc getSum(root *TreeNode, sum *int, flag bool) { \n\tif root.Left == nil && root.Right == nil && flag {\n\t\t*sum += root.Val\n\t\treturn\n\t}\n\tif root.Left != nil {\n\t\tgetSum(root.Left, sum, true)\n\t}\n\tif root.Right != nil {\n\t\tgetSum(root.Right, sum, false)\n\t}\n}\n```\n\n","source":"_posts/day17.md","raw":"---\ntitle: 代码随想录算法训练营第十七天 110.平衡二叉树、257. 二叉树的所有路径、404.左叶子之和\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: 467977b0\ndate: 2023-10-09 23:26:52\n---\n\n# 代码随想录算法训练营第十七天 110.平衡二叉树、257. 二叉树的所有路径、404.左叶子之和\n\n## 110. 平衡二叉树\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/balanced-binary-tree/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html)\n>\n>   视频讲解：[后序遍历求高度，高度判断是否平衡 | LeetCode：110.平衡二叉树](https://www.bilibili.com/video/BV1Ug411S7my)\n>\n>   状态：AC\n\n### 思路\n\n由之前的104题：求二叉树最大深度一讲，卡哥提到过深度和高度的区别，结合这道题的视频看懂了。举个例子，我们现在站在地上，看见一幢楼会说：“这楼有多高？”；看见一个坑，会说：“这坑有多深？”。也就是说高度要从下往上看、深度要从上往下看。从下向上自然就需要后序遍历。\n\n1.   每个叶子节点的高度为1，叶子节点的子节点（也就是两个空节点）高度为0；\n2.   定义左子树高度为`leftHeight`，左子树递归返回左子树的高度，如果高度为`-1`则执行`return -1`；\n3.   定义右子树高度为`rightHeight`，右子树递归返回右子树的高度，如果高度为`-1`则执行`return -1`；\n4.   比较左右子树高度差，差的绝对值小于等于1，说明是平衡二叉树，将最高的子树高度加一，回到2、3步继续。否则不为平衡二叉树，`return -1`。\n\n### 代码\n\n``` go\n// 平衡二叉树\nfunc isBalanced(root *TreeNode) bool {\n\treturn backTracking(root) != -1\n}\n// 返回最大值\nfunc maxNum(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc backTracking(root *TreeNode) int {\n    // 空节点\n\tif root == nil {\n\t\treturn 0\n\t}\n\t// left child\n\tleftHeight := backTracking(root.Left)\n\tif leftHeight == -1 {\n\t\treturn -1\n\t}\n\t// right child\n\trightHeight := backTracking(root.Right)\n\tif rightHeight == -1 {\n\t\treturn -1\n\t}\n\t// 不是平衡二叉树\n\tif rightHeight-leftHeight > 1 || rightHeight-leftHeight < -1 {\n\t\treturn -1\n\t} else {\n\t\treturn maxNum(rightHeight, leftHeight) + 1  //高度加一继续返回\n\t}\n}\n```\n\n## 257. 二叉树的所有路径\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/binary-tree-paths/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html)\n>\n>   视频讲解：[递归中带着回溯，你感受到了没？| LeetCode：257. 二叉树的所有路径](https://www.bilibili.com/video/BV1ZG411G7Dh)\n>\n>   状态：AC\n\n### 思路\n\n回溯算法的比较典型的应用，要输出所有的路径，应该使用先序遍历。走到叶子结点后将路径添加至最后的结果。\n\n卡哥回溯三部曲：\n\n1.   确立函数参数和返回值：由于是Go语言，全局变量在LeetCode中会出现一些问题，具体可以查看这篇我的这篇博客[Go语言刷LeetCode使用全局变量的问题](https://promisewang.github.io/post/bc862a56.html#%E9%81%87%E5%88%B0%E6%9C%80%E5%A4%B4%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81)。函数变量包括：\n     -   根节点`root`\n     -   这道题的结果`result`\n     -   一条路径`path`\n2.   确定终止条件：当前节点为子节点时，保存`path`到`result`，`return`\n3.   单次递归：左节点不为空，向左递归；右节点不为空；向右递归\n\n### 代码\n\n``` go\nfunc binaryTreePaths(root *TreeNode) []string {\n\tresult := []string{}\n\tpath := []int{}\n\tgetResult(root, &result, &path)\n\treturn result\n}\n\nfunc getResult(root *TreeNode, result *[]string, path *[]int) {\n    // 终止条件，并且将切片类型的path按要求写成字符串，添加到result中。\n\tif root.Left == nil && root.Right == nil {\n\t\t*path = append(*path, root.Val) //添加新的节点\n\t\tvar temp string\n\t\tif len(*path) == 1 {\n\t\t\ttemp = \"1\"\n\t\t} else {\n\t\t\ttemp = strconv.Itoa((*path)[0])\n\t\t\tfor i := 1; i < len(*path); i++ {\n\t\t\t\ttemp += \"->\" + strconv.Itoa((*path)[i])\n\t\t\t}\n\t\t}\n\t\t*path = (*path)[:len(*path)-1]\n\t\t*result = append(*result, temp)\n\t\treturn\n\t}\n    // 左节点不为空，向左递归\n\tif root.Left != nil {\n\t\t*path = append(*path, root.Val)\n\t\tgetResult(root.Left, result, path)\n\t\t*path = (*path)[:len(*path)-1]\n\t}\n    \n    // 右节点不为空，向右递归\n\tif root.Right != nil {\n\t\t*path = append(*path, root.Val)\n\t\tgetResult(root.Right, result, path)\n\t\t*path = (*path)[:len(*path)-1]\n\t}\n}\n\n```\n\n## 404.左叶子之和\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/sum-of-left-leaves/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html)\n>\n>   视频讲解：[二叉树的题目中，总有一些规则让你找不到北 | LeetCode：404.左叶子之和](https://www.bilibili.com/video/BV1GY4y1K7z8)\n>\n>   状态：AC\n\n### 思路\n\n要判断的是所有左叶子的和，选择先序遍历。递归三部曲请出来：\n\n1.   确立函数参数和返回值：此处没有用全局变量，需要使用一个指针存放和。如何判断是左节点，我这里引入一个变量`flag`为`bool`类型。如果向左节点递归，则为`true`，否则为`false`。这样当到达叶子节点时候判断`flag`值就能知道是不是左叶子\n     -   根节点`root`\n     -   和指针`sum`\n     -   是否为左节点`flag`\n2.   确定终止条件：如果是叶子节点，并且`flag == true`，`*sum += root.Val`，返回。\n3.   单次递归：如果左节点不为空，向左递归，`flag = true`；如果右结点不为空，向右递归，`flag = false`\n\n### 代码\n\n``` go\nfunc sumOfLeftLeaves(root *TreeNode) int {\n\tif root.Left == nil && root.Right == nil {\n\t\treturn 0\n\t}\n\tsum := 0\n\tgetSum(root, &sum, false)\n\treturn sum\n}\n\n// flag为true, 代表左节点; 否则是右结点\nfunc getSum(root *TreeNode, sum *int, flag bool) { \n\tif root.Left == nil && root.Right == nil && flag {\n\t\t*sum += root.Val\n\t\treturn\n\t}\n\tif root.Left != nil {\n\t\tgetSum(root.Left, sum, true)\n\t}\n\tif root.Right != nil {\n\t\tgetSum(root.Right, sum, false)\n\t}\n}\n```\n\n","slug":"day17","published":1,"updated":"2023-10-09T16:11:44.947Z","_id":"clnj3c70v0000puz86u7wb17m","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第十七天-110-平衡二叉树、257-二叉树的所有路径、404-左叶子之和\"><a href=\"#代码随想录算法训练营第十七天-110-平衡二叉树、257-二叉树的所有路径、404-左叶子之和\" class=\"headerlink\" title=\"代码随想录算法训练营第十七天 110.平衡二叉树、257. 二叉树的所有路径、404.左叶子之和\"></a>代码随想录算法训练营第十七天 110.平衡二叉树、257. 二叉树的所有路径、404.左叶子之和</h1><h2 id=\"110-平衡二叉树\"><a href=\"#110-平衡二叉树\" class=\"headerlink\" title=\"110. 平衡二叉树\"></a>110. 平衡二叉树</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/balanced-binary-tree/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1Ug411S7my\">后序遍历求高度，高度判断是否平衡 | LeetCode：110.平衡二叉树</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>由之前的104题：求二叉树最大深度一讲，卡哥提到过深度和高度的区别，结合这道题的视频看懂了。举个例子，我们现在站在地上，看见一幢楼会说：“这楼有多高？”；看见一个坑，会说：“这坑有多深？”。也就是说高度要从下往上看、深度要从上往下看。从下向上自然就需要后序遍历。</p>\n<ol>\n<li>每个叶子节点的高度为1，叶子节点的子节点（也就是两个空节点）高度为0；</li>\n<li>定义左子树高度为<code>leftHeight</code>，左子树递归返回左子树的高度，如果高度为<code>-1</code>则执行<code>return -1</code>；</li>\n<li>定义右子树高度为<code>rightHeight</code>，右子树递归返回右子树的高度，如果高度为<code>-1</code>则执行<code>return -1</code>；</li>\n<li>比较左右子树高度差，差的绝对值小于等于1，说明是平衡二叉树，将最高的子树高度加一，回到2、3步继续。否则不为平衡二叉树，<code>return -1</code>。</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 平衡二叉树</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isBalanced</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> backTracking(root) != <span class=\"hljs-number\">-1</span><br>&#125;<br><span class=\"hljs-comment\">// 返回最大值</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxNum</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> b<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">backTracking</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// 空节点</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// left child</span><br>\tleftHeight := backTracking(root.Left)<br>\t<span class=\"hljs-keyword\">if</span> leftHeight == <span class=\"hljs-number\">-1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// right child</span><br>\trightHeight := backTracking(root.Right)<br>\t<span class=\"hljs-keyword\">if</span> rightHeight == <span class=\"hljs-number\">-1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 不是平衡二叉树</span><br>\t<span class=\"hljs-keyword\">if</span> rightHeight-leftHeight &gt; <span class=\"hljs-number\">1</span> || rightHeight-leftHeight &lt; <span class=\"hljs-number\">-1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> maxNum(rightHeight, leftHeight) + <span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\">//高度加一继续返回</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"257-二叉树的所有路径\"><a href=\"#257-二叉树的所有路径\" class=\"headerlink\" title=\"257. 二叉树的所有路径\"></a>257. 二叉树的所有路径</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-paths/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1ZG411G7Dh\">递归中带着回溯，你感受到了没？| LeetCode：257. 二叉树的所有路径</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>回溯算法的比较典型的应用，要输出所有的路径，应该使用先序遍历。走到叶子结点后将路径添加至最后的结果。</p>\n<p>卡哥回溯三部曲：</p>\n<ol>\n<li>确立函数参数和返回值：由于是Go语言，全局变量在LeetCode中会出现一些问题，具体可以查看这篇我的这篇博客<a href=\"https://promisewang.github.io/post/bc862a56.html#%E9%81%87%E5%88%B0%E6%9C%80%E5%A4%B4%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81\">Go语言刷LeetCode使用全局变量的问题</a>。函数变量包括：<ul>\n<li>根节点<code>root</code></li>\n<li>这道题的结果<code>result</code></li>\n<li>一条路径<code>path</code></li>\n</ul>\n</li>\n<li>确定终止条件：当前节点为子节点时，保存<code>path</code>到<code>result</code>，<code>return</code></li>\n<li>单次递归：左节点不为空，向左递归；右节点不为空；向右递归</li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">binaryTreePaths</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">string</span> &#123;<br>\tresult := []<span class=\"hljs-type\">string</span>&#123;&#125;<br>\tpath := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\tgetResult(root, &amp;result, &amp;path)<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getResult</span><span class=\"hljs-params\">(root *TreeNode, result *[]<span class=\"hljs-type\">string</span>, path *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    <span class=\"hljs-comment\">// 终止条件，并且将切片类型的path按要求写成字符串，添加到result中。</span><br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val) <span class=\"hljs-comment\">//添加新的节点</span><br>\t\t<span class=\"hljs-keyword\">var</span> temp <span class=\"hljs-type\">string</span><br>\t\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(*path) == <span class=\"hljs-number\">1</span> &#123;<br>\t\t\ttemp = <span class=\"hljs-string\">&quot;1&quot;</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\ttemp = strconv.Itoa((*path)[<span class=\"hljs-number\">0</span>])<br>\t\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(*path); i++ &#123;<br>\t\t\t\ttemp += <span class=\"hljs-string\">&quot;-&gt;&quot;</span> + strconv.Itoa((*path)[i])<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t\t*result = <span class=\"hljs-built_in\">append</span>(*result, temp)<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>    <span class=\"hljs-comment\">// 左节点不为空，向左递归</span><br>\t<span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tgetResult(root.Left, result, path)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>    <br>    <span class=\"hljs-comment\">// 右节点不为空，向右递归</span><br>\t<span class=\"hljs-keyword\">if</span> root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tgetResult(root.Right, result, path)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"404-左叶子之和\"><a href=\"#404-左叶子之和\" class=\"headerlink\" title=\"404.左叶子之和\"></a>404.左叶子之和</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/sum-of-left-leaves/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1GY4y1K7z8\">二叉树的题目中，总有一些规则让你找不到北 | LeetCode：404.左叶子之和</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>要判断的是所有左叶子的和，选择先序遍历。递归三部曲请出来：</p>\n<ol>\n<li>确立函数参数和返回值：此处没有用全局变量，需要使用一个指针存放和。如何判断是左节点，我这里引入一个变量<code>flag</code>为<code>bool</code>类型。如果向左节点递归，则为<code>true</code>，否则为<code>false</code>。这样当到达叶子节点时候判断<code>flag</code>值就能知道是不是左叶子<ul>\n<li>根节点<code>root</code></li>\n<li>和指针<code>sum</code></li>\n<li>是否为左节点<code>flag</code></li>\n</ul>\n</li>\n<li>确定终止条件：如果是叶子节点，并且<code>flag == true</code>，<code>*sum += root.Val</code>，返回。</li>\n<li>单次递归：如果左节点不为空，向左递归，<code>flag = true</code>；如果右结点不为空，向右递归，<code>flag = false</code></li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sumOfLeftLeaves</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tsum := <span class=\"hljs-number\">0</span><br>\tgetSum(root, &amp;sum, <span class=\"hljs-literal\">false</span>)<br>\t<span class=\"hljs-keyword\">return</span> sum<br>&#125;<br><br><span class=\"hljs-comment\">// flag为true, 代表左节点; 否则是右结点</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getSum</span><span class=\"hljs-params\">(root *TreeNode, sum *<span class=\"hljs-type\">int</span>, flag <span class=\"hljs-type\">bool</span>)</span></span> &#123; <br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &amp;&amp; flag &#123;<br>\t\t*sum += root.Val<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tgetSum(root.Left, sum, <span class=\"hljs-literal\">true</span>)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tgetSum(root.Right, sum, <span class=\"hljs-literal\">false</span>)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第十七天-110-平衡二叉树、257-二叉树的所有路径、404-左叶子之和\"><a href=\"#代码随想录算法训练营第十七天-110-平衡二叉树、257-二叉树的所有路径、404-左叶子之和\" class=\"headerlink\" title=\"代码随想录算法训练营第十七天 110.平衡二叉树、257. 二叉树的所有路径、404.左叶子之和\"></a>代码随想录算法训练营第十七天 110.平衡二叉树、257. 二叉树的所有路径、404.左叶子之和</h1><h2 id=\"110-平衡二叉树\"><a href=\"#110-平衡二叉树\" class=\"headerlink\" title=\"110. 平衡二叉树\"></a>110. 平衡二叉树</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/balanced-binary-tree/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1Ug411S7my\">后序遍历求高度，高度判断是否平衡 | LeetCode：110.平衡二叉树</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>由之前的104题：求二叉树最大深度一讲，卡哥提到过深度和高度的区别，结合这道题的视频看懂了。举个例子，我们现在站在地上，看见一幢楼会说：“这楼有多高？”；看见一个坑，会说：“这坑有多深？”。也就是说高度要从下往上看、深度要从上往下看。从下向上自然就需要后序遍历。</p>\n<ol>\n<li>每个叶子节点的高度为1，叶子节点的子节点（也就是两个空节点）高度为0；</li>\n<li>定义左子树高度为<code>leftHeight</code>，左子树递归返回左子树的高度，如果高度为<code>-1</code>则执行<code>return -1</code>；</li>\n<li>定义右子树高度为<code>rightHeight</code>，右子树递归返回右子树的高度，如果高度为<code>-1</code>则执行<code>return -1</code>；</li>\n<li>比较左右子树高度差，差的绝对值小于等于1，说明是平衡二叉树，将最高的子树高度加一，回到2、3步继续。否则不为平衡二叉树，<code>return -1</code>。</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 平衡二叉树</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isBalanced</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> backTracking(root) != <span class=\"hljs-number\">-1</span><br>&#125;<br><span class=\"hljs-comment\">// 返回最大值</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">maxNum</span><span class=\"hljs-params\">(a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> a &gt; b &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> b<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">backTracking</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-comment\">// 空节点</span><br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// left child</span><br>\tleftHeight := backTracking(root.Left)<br>\t<span class=\"hljs-keyword\">if</span> leftHeight == <span class=\"hljs-number\">-1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// right child</span><br>\trightHeight := backTracking(root.Right)<br>\t<span class=\"hljs-keyword\">if</span> rightHeight == <span class=\"hljs-number\">-1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 不是平衡二叉树</span><br>\t<span class=\"hljs-keyword\">if</span> rightHeight-leftHeight &gt; <span class=\"hljs-number\">1</span> || rightHeight-leftHeight &lt; <span class=\"hljs-number\">-1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> maxNum(rightHeight, leftHeight) + <span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\">//高度加一继续返回</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"257-二叉树的所有路径\"><a href=\"#257-二叉树的所有路径\" class=\"headerlink\" title=\"257. 二叉树的所有路径\"></a>257. 二叉树的所有路径</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-paths/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1ZG411G7Dh\">递归中带着回溯，你感受到了没？| LeetCode：257. 二叉树的所有路径</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>回溯算法的比较典型的应用，要输出所有的路径，应该使用先序遍历。走到叶子结点后将路径添加至最后的结果。</p>\n<p>卡哥回溯三部曲：</p>\n<ol>\n<li>确立函数参数和返回值：由于是Go语言，全局变量在LeetCode中会出现一些问题，具体可以查看这篇我的这篇博客<a href=\"https://promisewang.github.io/post/bc862a56.html#%E9%81%87%E5%88%B0%E6%9C%80%E5%A4%B4%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81\">Go语言刷LeetCode使用全局变量的问题</a>。函数变量包括：<ul>\n<li>根节点<code>root</code></li>\n<li>这道题的结果<code>result</code></li>\n<li>一条路径<code>path</code></li>\n</ul>\n</li>\n<li>确定终止条件：当前节点为子节点时，保存<code>path</code>到<code>result</code>，<code>return</code></li>\n<li>单次递归：左节点不为空，向左递归；右节点不为空；向右递归</li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">binaryTreePaths</span><span class=\"hljs-params\">(root *TreeNode)</span></span> []<span class=\"hljs-type\">string</span> &#123;<br>\tresult := []<span class=\"hljs-type\">string</span>&#123;&#125;<br>\tpath := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\tgetResult(root, &amp;result, &amp;path)<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getResult</span><span class=\"hljs-params\">(root *TreeNode, result *[]<span class=\"hljs-type\">string</span>, path *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    <span class=\"hljs-comment\">// 终止条件，并且将切片类型的path按要求写成字符串，添加到result中。</span><br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val) <span class=\"hljs-comment\">//添加新的节点</span><br>\t\t<span class=\"hljs-keyword\">var</span> temp <span class=\"hljs-type\">string</span><br>\t\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(*path) == <span class=\"hljs-number\">1</span> &#123;<br>\t\t\ttemp = <span class=\"hljs-string\">&quot;1&quot;</span><br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\ttemp = strconv.Itoa((*path)[<span class=\"hljs-number\">0</span>])<br>\t\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(*path); i++ &#123;<br>\t\t\t\ttemp += <span class=\"hljs-string\">&quot;-&gt;&quot;</span> + strconv.Itoa((*path)[i])<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t\t*result = <span class=\"hljs-built_in\">append</span>(*result, temp)<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>    <span class=\"hljs-comment\">// 左节点不为空，向左递归</span><br>\t<span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tgetResult(root.Left, result, path)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>    <br>    <span class=\"hljs-comment\">// 右节点不为空，向右递归</span><br>\t<span class=\"hljs-keyword\">if</span> root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tgetResult(root.Right, result, path)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"404-左叶子之和\"><a href=\"#404-左叶子之和\" class=\"headerlink\" title=\"404.左叶子之和\"></a>404.左叶子之和</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/sum-of-left-leaves/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1GY4y1K7z8\">二叉树的题目中，总有一些规则让你找不到北 | LeetCode：404.左叶子之和</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>要判断的是所有左叶子的和，选择先序遍历。递归三部曲请出来：</p>\n<ol>\n<li>确立函数参数和返回值：此处没有用全局变量，需要使用一个指针存放和。如何判断是左节点，我这里引入一个变量<code>flag</code>为<code>bool</code>类型。如果向左节点递归，则为<code>true</code>，否则为<code>false</code>。这样当到达叶子节点时候判断<code>flag</code>值就能知道是不是左叶子<ul>\n<li>根节点<code>root</code></li>\n<li>和指针<code>sum</code></li>\n<li>是否为左节点<code>flag</code></li>\n</ul>\n</li>\n<li>确定终止条件：如果是叶子节点，并且<code>flag == true</code>，<code>*sum += root.Val</code>，返回。</li>\n<li>单次递归：如果左节点不为空，向左递归，<code>flag = true</code>；如果右结点不为空，向右递归，<code>flag = false</code></li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sumOfLeftLeaves</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>\t&#125;<br>\tsum := <span class=\"hljs-number\">0</span><br>\tgetSum(root, &amp;sum, <span class=\"hljs-literal\">false</span>)<br>\t<span class=\"hljs-keyword\">return</span> sum<br>&#125;<br><br><span class=\"hljs-comment\">// flag为true, 代表左节点; 否则是右结点</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getSum</span><span class=\"hljs-params\">(root *TreeNode, sum *<span class=\"hljs-type\">int</span>, flag <span class=\"hljs-type\">bool</span>)</span></span> &#123; <br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &amp;&amp; flag &#123;<br>\t\t*sum += root.Val<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tgetSum(root.Left, sum, <span class=\"hljs-literal\">true</span>)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tgetSum(root.Right, sum, <span class=\"hljs-literal\">false</span>)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"代码随想录算法训练营第十八天 513.找树左下角的值、112.路径总和、113.路径总和II、106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树","abbrlink":"de527742","date":"2023-10-10T11:56:14.000Z","_content":"\n# 代码随想录算法训练营第十八天  513找树左下角的值、112.路径总和、113.路径总和II、106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树\n\n## 513. 找树左下角的值\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/find-bottom-left-tree-value/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html)\n>\n>   视频讲解：[怎么找二叉树的左下角？ 递归中又带回溯了，怎么办？| LeetCode：513.找二叉树左下角的值](https://www.bilibili.com/video/BV1424y1Z7pn)\n>\n>   状态：AC\n\n### 思路\n\n这道题对左下角的定义是：最后一行，最左面的元素，只需要层序遍历，输出最后一行的第一个元素即可。\n\n### 代码\n\n``` go\nfunc findBottomLeftValue(root *TreeNode) int {\n\tqueue := arrayqueue.New()\n\tvar result [][]int\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*TreeNode).Val)\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\tfmt.Println(result)\n\treturn result[len(result)-1][0]\n}\n\n```\n\n## 112. 路径总和、113. 路径总和II\n\n>   题目链接：\n>\n>   -   [112.路径总和](https://leetcode.cn/problems/path-sum/)\n>   -   [113.路径总和ii](https://leetcode.cn/problems/path-sum-ii/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html)\n>\n>   视频讲解：[拿不准的遍历顺序，搞不清的回溯过程，我太难了！ | LeetCode：112. 路径总和](https://www.bilibili.com/video/BV19t4y1L7CR)\n>\n>   状态：AC\n\n### 思路\n\n1.   找到根节点到叶子节点的路径：这里使用先序遍历（深度搜索）\n2.   将该路径所有节点求和，判断是否等于`targetSum`，有则保存至`result`中\n\n### 代码\n\n``` go\n// 112题\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\n\tvar result [][]int\n\tvar path []int\n\tgetResult(root, &result, &path)\n\tfor i := 0; i < len(result); i++ {\n\t\tsum := 0\n\t\tfor _, v := range result[i] {\n\t\t\tsum += v\n\t\t}\n\t\tif sum == targetSum {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc getResult(root *TreeNode, result *[][]int, path *[]int) {\n\tif root.Left == nil && root.Right == nil {\n\t\t*path = append(*path, root.Val)\n\t\ttemp := make([]int, len(*path))\n\t\tcopy(temp, *path)\n\t\t*result = append(*result, temp)\n\t\t*path = (*path)[:len(*path)-1]\n\t\treturn\n\t}\n\tif root.Left != nil {\n\t\t*path = append(*path, root.Val)\n\t\tgetResult(root.Left, result, path)\n\t\t*path = (*path)[:len(*path)-1]\n\t}\n\tif root.Right != nil {\n\t\t*path = append(*path, root.Val)\n\t\tgetResult(root.Right, result, path)\n\t\t*path = (*path)[:len(*path)-1]\n\t}\n}\n```\n\n``` go\n// 113题\nfunc pathSum(root *TreeNode, targetSum int) [][]int {\n\tvar result [][]int\n\tvar path []int\n\tgetResult1(root, &result, &path, targetSum)\n\treturn result\n}\n\nfunc getResult1(root *TreeNode, result *[][]int, path *[]int, target int) {\n\tif root == nil {\n\t\treturn\n\t}\n\tif root.Left == nil && root.Right == nil {\n\t\t*path = append(*path, root.Val)\n\t\tsum := 0\n\t\tfor _, v := range *path {\n\t\t\tsum += v\n\t\t}\n\t\tif sum == target {\n\t\t\ttemp := make([]int, len(*path))\n\t\t\tcopy(temp, *path)\n\t\t\t*result = append(*result, temp)\n\t\t}\n\t\t*path = (*path)[:len(*path)-1]\n\t\treturn\n\t}\n\tif root.Left != nil {\n\t\t*path = append(*path, root.Val)\n\t\tgetResult1(root.Left, result, path, target)\n\t\t*path = (*path)[:len(*path)-1]\n\t}\n\tif root.Right != nil {\n\t\t*path = append(*path, root.Val)\n\t\tgetResult1(root.Right, result, path, target)\n\t\t*path = (*path)[:len(*path)-1]\n\t}\n}\n```\n\n## 106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树\n\n>   题目链接：\n>\n>   -   [106.从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n>   -   [105.从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html)\n>\n>   视频讲解：[坑很多！来看看你掉过几次坑 | LeetCode：106.从中序与后序遍历序列构造二叉树](https://www.bilibili.com/video/BV1vW4y1i7dn)\n>\n>   状态：AC\n\n### 思路\n\n这道题自己最开始想的不是很明白，而且自己在考试时做这类题也没有固定的套路，看了下卡哥的讲解\n\n- 后序数组长度为0, 空节点\n- 后序数组最后一个元素为父节点元素\n- 寻找中序数组位置  作切割点\n- 切中序数组\n- 切后序数组\n- 递归处理左区间 右区间\n\n<div style=\"position: relative; width: 100%; height: 0;padding-bottom: 100%;\"><iframe \nsrc=\"../images/day18/力扣106.mp4\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n### 代码\n\n``` go\n// 中序后序建立二叉树\nfunc buildTree(inorder []int, postorder []int) *TreeNode {\n\t// 1.后序数组长度为0, 空节点\n\tif len(postorder) == 0 {\n\t\treturn nil\n\t}\n\t// 2.后序数组最后一个元素为父节点元素\n\trootValue := postorder[len(postorder)-1]\n\troot := &TreeNode{\n\t\tVal:   rootValue,\n\t\tLeft:  nil,\n\t\tRight: nil,\n\t}\n\tif len(postorder) == 1 {\n\t\treturn root\n\t}\n\t// 3.寻找中序数组位置  作切割点\n\tindex := 0\n\tfor ; index < len(inorder); index++ {\n\t\tif inorder[index] == rootValue {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// 4.切中序数组\n\tleftInorder := inorder[:index]\n\trightInorder := inorder[index+1:]\n\t// 5.切后序数组\n\tleftPostorder := postorder[:len(leftInorder)]\n\trightPostorder := postorder[len(leftPostorder) : len(leftPostorder)+len(rightInorder)]\n\t// 6.递归处理左区间 右区间\n\troot.Left = buildTree(leftInorder, leftPostorder)\n\troot.Right = buildTree(rightInorder, rightPostorder)\n\treturn root\n}\n```\n\n``` go\n// 前序中序建立二叉树\nfunc buildTree2(preorder []int, inorder []int) *TreeNode {\n\t// 1.前序数组为0, 空节点\n\tif len(preorder) == 0 {\n\t\treturn nil\n\t}\n\t// 2.前序数组第一个元素为节点元素\n\trootValue := preorder[0]\n\troot := &TreeNode{\n\t\tVal:   rootValue,\n\t\tLeft:  nil,\n\t\tRight: nil,\n\t}\n\tif len(preorder) == 1 {\n\t\treturn root\n\t}\n\t// 3.寻找中序数组位置  作切割点\n\tindex := 0\n\tfor ; index < len(inorder); index++ {\n\t\tif inorder[index] == rootValue {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// 4.切中序数组\n\tleftInorder := inorder[:index]\n\trightInorder := inorder[index+1:]\n\t// 5.切前序数组\n\tleftPreorder := preorder[1 : len(leftInorder)+1]\n\trightPreorder := preorder[len(leftPreorder)+1:]\n\t// 6.递归处理左区间 右区间\n\troot.Left = buildTree2(leftPreorder, leftInorder)\n\troot.Right = buildTree2(rightPreorder, rightInorder)\n\treturn root\n}\n\n```\n\n","source":"_posts/day18.md","raw":"---\ntitle: 代码随想录算法训练营第十八天 513.找树左下角的值、112.路径总和、113.路径总和II、106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\nabbrlink: de527742\ndate: 2023-10-10 19:56:14\n---\n\n# 代码随想录算法训练营第十八天  513找树左下角的值、112.路径总和、113.路径总和II、106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树\n\n## 513. 找树左下角的值\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/find-bottom-left-tree-value/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html)\n>\n>   视频讲解：[怎么找二叉树的左下角？ 递归中又带回溯了，怎么办？| LeetCode：513.找二叉树左下角的值](https://www.bilibili.com/video/BV1424y1Z7pn)\n>\n>   状态：AC\n\n### 思路\n\n这道题对左下角的定义是：最后一行，最左面的元素，只需要层序遍历，输出最后一行的第一个元素即可。\n\n### 代码\n\n``` go\nfunc findBottomLeftValue(root *TreeNode) int {\n\tqueue := arrayqueue.New()\n\tvar result [][]int\n\tqueue.Enqueue(root)\n\tfor !queue.Empty() {\n\t\tsize := queue.Size()\n\t\ttemp := []int{}\n\t\tfor i := 0; i < size; i++ {\n\t\t\tnode, _ := queue.Dequeue()\n\t\t\ttemp = append(temp, node.(*TreeNode).Val)\n\t\t\tif node.(*TreeNode).Left != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)\n\t\t\t}\n\t\t\tif node.(*TreeNode).Right != nil {\n\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)\n\t\t\t}\n\t\t}\n\t\tresult = append(result, temp)\n\t}\n\tfmt.Println(result)\n\treturn result[len(result)-1][0]\n}\n\n```\n\n## 112. 路径总和、113. 路径总和II\n\n>   题目链接：\n>\n>   -   [112.路径总和](https://leetcode.cn/problems/path-sum/)\n>   -   [113.路径总和ii](https://leetcode.cn/problems/path-sum-ii/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html)\n>\n>   视频讲解：[拿不准的遍历顺序，搞不清的回溯过程，我太难了！ | LeetCode：112. 路径总和](https://www.bilibili.com/video/BV19t4y1L7CR)\n>\n>   状态：AC\n\n### 思路\n\n1.   找到根节点到叶子节点的路径：这里使用先序遍历（深度搜索）\n2.   将该路径所有节点求和，判断是否等于`targetSum`，有则保存至`result`中\n\n### 代码\n\n``` go\n// 112题\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\n\tvar result [][]int\n\tvar path []int\n\tgetResult(root, &result, &path)\n\tfor i := 0; i < len(result); i++ {\n\t\tsum := 0\n\t\tfor _, v := range result[i] {\n\t\t\tsum += v\n\t\t}\n\t\tif sum == targetSum {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc getResult(root *TreeNode, result *[][]int, path *[]int) {\n\tif root.Left == nil && root.Right == nil {\n\t\t*path = append(*path, root.Val)\n\t\ttemp := make([]int, len(*path))\n\t\tcopy(temp, *path)\n\t\t*result = append(*result, temp)\n\t\t*path = (*path)[:len(*path)-1]\n\t\treturn\n\t}\n\tif root.Left != nil {\n\t\t*path = append(*path, root.Val)\n\t\tgetResult(root.Left, result, path)\n\t\t*path = (*path)[:len(*path)-1]\n\t}\n\tif root.Right != nil {\n\t\t*path = append(*path, root.Val)\n\t\tgetResult(root.Right, result, path)\n\t\t*path = (*path)[:len(*path)-1]\n\t}\n}\n```\n\n``` go\n// 113题\nfunc pathSum(root *TreeNode, targetSum int) [][]int {\n\tvar result [][]int\n\tvar path []int\n\tgetResult1(root, &result, &path, targetSum)\n\treturn result\n}\n\nfunc getResult1(root *TreeNode, result *[][]int, path *[]int, target int) {\n\tif root == nil {\n\t\treturn\n\t}\n\tif root.Left == nil && root.Right == nil {\n\t\t*path = append(*path, root.Val)\n\t\tsum := 0\n\t\tfor _, v := range *path {\n\t\t\tsum += v\n\t\t}\n\t\tif sum == target {\n\t\t\ttemp := make([]int, len(*path))\n\t\t\tcopy(temp, *path)\n\t\t\t*result = append(*result, temp)\n\t\t}\n\t\t*path = (*path)[:len(*path)-1]\n\t\treturn\n\t}\n\tif root.Left != nil {\n\t\t*path = append(*path, root.Val)\n\t\tgetResult1(root.Left, result, path, target)\n\t\t*path = (*path)[:len(*path)-1]\n\t}\n\tif root.Right != nil {\n\t\t*path = append(*path, root.Val)\n\t\tgetResult1(root.Right, result, path, target)\n\t\t*path = (*path)[:len(*path)-1]\n\t}\n}\n```\n\n## 106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树\n\n>   题目链接：\n>\n>   -   [106.从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n>   -   [105.从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html)\n>\n>   视频讲解：[坑很多！来看看你掉过几次坑 | LeetCode：106.从中序与后序遍历序列构造二叉树](https://www.bilibili.com/video/BV1vW4y1i7dn)\n>\n>   状态：AC\n\n### 思路\n\n这道题自己最开始想的不是很明白，而且自己在考试时做这类题也没有固定的套路，看了下卡哥的讲解\n\n- 后序数组长度为0, 空节点\n- 后序数组最后一个元素为父节点元素\n- 寻找中序数组位置  作切割点\n- 切中序数组\n- 切后序数组\n- 递归处理左区间 右区间\n\n<div style=\"position: relative; width: 100%; height: 0;padding-bottom: 100%;\"><iframe \nsrc=\"../images/day18/力扣106.mp4\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n### 代码\n\n``` go\n// 中序后序建立二叉树\nfunc buildTree(inorder []int, postorder []int) *TreeNode {\n\t// 1.后序数组长度为0, 空节点\n\tif len(postorder) == 0 {\n\t\treturn nil\n\t}\n\t// 2.后序数组最后一个元素为父节点元素\n\trootValue := postorder[len(postorder)-1]\n\troot := &TreeNode{\n\t\tVal:   rootValue,\n\t\tLeft:  nil,\n\t\tRight: nil,\n\t}\n\tif len(postorder) == 1 {\n\t\treturn root\n\t}\n\t// 3.寻找中序数组位置  作切割点\n\tindex := 0\n\tfor ; index < len(inorder); index++ {\n\t\tif inorder[index] == rootValue {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// 4.切中序数组\n\tleftInorder := inorder[:index]\n\trightInorder := inorder[index+1:]\n\t// 5.切后序数组\n\tleftPostorder := postorder[:len(leftInorder)]\n\trightPostorder := postorder[len(leftPostorder) : len(leftPostorder)+len(rightInorder)]\n\t// 6.递归处理左区间 右区间\n\troot.Left = buildTree(leftInorder, leftPostorder)\n\troot.Right = buildTree(rightInorder, rightPostorder)\n\treturn root\n}\n```\n\n``` go\n// 前序中序建立二叉树\nfunc buildTree2(preorder []int, inorder []int) *TreeNode {\n\t// 1.前序数组为0, 空节点\n\tif len(preorder) == 0 {\n\t\treturn nil\n\t}\n\t// 2.前序数组第一个元素为节点元素\n\trootValue := preorder[0]\n\troot := &TreeNode{\n\t\tVal:   rootValue,\n\t\tLeft:  nil,\n\t\tRight: nil,\n\t}\n\tif len(preorder) == 1 {\n\t\treturn root\n\t}\n\t// 3.寻找中序数组位置  作切割点\n\tindex := 0\n\tfor ; index < len(inorder); index++ {\n\t\tif inorder[index] == rootValue {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// 4.切中序数组\n\tleftInorder := inorder[:index]\n\trightInorder := inorder[index+1:]\n\t// 5.切前序数组\n\tleftPreorder := preorder[1 : len(leftInorder)+1]\n\trightPreorder := preorder[len(leftPreorder)+1:]\n\t// 6.递归处理左区间 右区间\n\troot.Left = buildTree2(leftPreorder, leftInorder)\n\troot.Right = buildTree2(rightPreorder, rightInorder)\n\treturn root\n}\n\n```\n\n","slug":"day18","published":1,"updated":"2023-10-12T14:39:30.845Z","_id":"clnlur4z20000n4z8e7m66upr","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码随想录算法训练营第十八天-513找树左下角的值、112-路径总和、113-路径总和II、106-从中序与后序遍历序列构造二叉树、105-从前序与中序遍历序列构造二叉树\"><a href=\"#代码随想录算法训练营第十八天-513找树左下角的值、112-路径总和、113-路径总和II、106-从中序与后序遍历序列构造二叉树、105-从前序与中序遍历序列构造二叉树\" class=\"headerlink\" title=\"代码随想录算法训练营第十八天  513找树左下角的值、112.路径总和、113.路径总和II、106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树\"></a>代码随想录算法训练营第十八天  513找树左下角的值、112.路径总和、113.路径总和II、106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树</h1><h2 id=\"513-找树左下角的值\"><a href=\"#513-找树左下角的值\" class=\"headerlink\" title=\"513. 找树左下角的值\"></a>513. 找树左下角的值</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/find-bottom-left-tree-value/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1424y1Z7pn\">怎么找二叉树的左下角？ 递归中又带回溯了，怎么办？| LeetCode：513.找二叉树左下角的值</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这道题对左下角的定义是：最后一行，最左面的元素，只需要层序遍历，输出最后一行的第一个元素即可。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findBottomLeftValue</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tqueue := arrayqueue.New()<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*TreeNode).Val)<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\tfmt.Println(result)<br>\t<span class=\"hljs-keyword\">return</span> result[<span class=\"hljs-built_in\">len</span>(result)<span class=\"hljs-number\">-1</span>][<span class=\"hljs-number\">0</span>]<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"112-路径总和、113-路径总和II\"><a href=\"#112-路径总和、113-路径总和II\" class=\"headerlink\" title=\"112. 路径总和、113. 路径总和II\"></a>112. 路径总和、113. 路径总和II</h2><blockquote>\n<p>  题目链接：</p>\n<ul>\n<li><a href=\"https://leetcode.cn/problems/path-sum/\">112.路径总和</a></li>\n<li><a href=\"https://leetcode.cn/problems/path-sum-ii/\">113.路径总和ii</a></li>\n</ul>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV19t4y1L7CR\">拿不准的遍历顺序，搞不清的回溯过程，我太难了！ | LeetCode：112. 路径总和</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>找到根节点到叶子节点的路径：这里使用先序遍历（深度搜索）</li>\n<li>将该路径所有节点求和，判断是否等于<code>targetSum</code>，有则保存至<code>result</code>中</li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 112题</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">hasPathSum</span><span class=\"hljs-params\">(root *TreeNode, targetSum <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">var</span> path []<span class=\"hljs-type\">int</span><br>\tgetResult(root, &amp;result, &amp;path)<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(result); i++ &#123;<br>\t\tsum := <span class=\"hljs-number\">0</span><br>\t\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> result[i] &#123;<br>\t\t\tsum += v<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> sum == targetSum &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getResult</span><span class=\"hljs-params\">(root *TreeNode, result *[][]<span class=\"hljs-type\">int</span>, path *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\ttemp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(*path))<br>\t\t<span class=\"hljs-built_in\">copy</span>(temp, *path)<br>\t\t*result = <span class=\"hljs-built_in\">append</span>(*result, temp)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tgetResult(root.Left, result, path)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tgetResult(root.Right, result, path)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 113题</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">pathSum</span><span class=\"hljs-params\">(root *TreeNode, targetSum <span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">var</span> path []<span class=\"hljs-type\">int</span><br>\tgetResult1(root, &amp;result, &amp;path, targetSum)<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getResult1</span><span class=\"hljs-params\">(root *TreeNode, result *[][]<span class=\"hljs-type\">int</span>, path *[]<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tsum := <span class=\"hljs-number\">0</span><br>\t\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> *path &#123;<br>\t\t\tsum += v<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> sum == target &#123;<br>\t\t\ttemp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(*path))<br>\t\t\t<span class=\"hljs-built_in\">copy</span>(temp, *path)<br>\t\t\t*result = <span class=\"hljs-built_in\">append</span>(*result, temp)<br>\t\t&#125;<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tgetResult1(root.Left, result, path, target)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tgetResult1(root.Right, result, path, target)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"106-从中序与后序遍历序列构造二叉树、105-从前序与中序遍历序列构造二叉树\"><a href=\"#106-从中序与后序遍历序列构造二叉树、105-从前序与中序遍历序列构造二叉树\" class=\"headerlink\" title=\"106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树\"></a>106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树</h2><blockquote>\n<p>  题目链接：</p>\n<ul>\n<li><a href=\"https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\">106.从中序与后序遍历序列构造二叉树</a></li>\n<li><a href=\"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">105.从前序与中序遍历序列构造二叉树</a></li>\n</ul>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1vW4y1i7dn\">坑很多！来看看你掉过几次坑 | LeetCode：106.从中序与后序遍历序列构造二叉树</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这道题自己最开始想的不是很明白，而且自己在考试时做这类题也没有固定的套路，看了下卡哥的讲解</p>\n<ul>\n<li>后序数组长度为0, 空节点</li>\n<li>后序数组最后一个元素为父节点元素</li>\n<li>寻找中序数组位置  作切割点</li>\n<li>切中序数组</li>\n<li>切后序数组</li>\n<li>递归处理左区间 右区间</li>\n</ul>\n<div style=\"position: relative; width: 100%; height: 0;padding-bottom: 100%;\"><iframe \nsrc=\"../images/day18/力扣106.mp4\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 中序后序建立二叉树</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">buildTree</span><span class=\"hljs-params\">(inorder []<span class=\"hljs-type\">int</span>, postorder []<span class=\"hljs-type\">int</span>)</span></span> *TreeNode &#123;<br>\t<span class=\"hljs-comment\">// 1.后序数组长度为0, 空节点</span><br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(postorder) == <span class=\"hljs-number\">0</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2.后序数组最后一个元素为父节点元素</span><br>\trootValue := postorder[<span class=\"hljs-built_in\">len</span>(postorder)<span class=\"hljs-number\">-1</span>]<br>\troot := &amp;TreeNode&#123;<br>\t\tVal:   rootValue,<br>\t\tLeft:  <span class=\"hljs-literal\">nil</span>,<br>\t\tRight: <span class=\"hljs-literal\">nil</span>,<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(postorder) == <span class=\"hljs-number\">1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> root<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3.寻找中序数组位置  作切割点</span><br>\tindex := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> ; index &lt; <span class=\"hljs-built_in\">len</span>(inorder); index++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> inorder[index] == rootValue &#123;<br>\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 4.切中序数组</span><br>\tleftInorder := inorder[:index]<br>\trightInorder := inorder[index+<span class=\"hljs-number\">1</span>:]<br>\t<span class=\"hljs-comment\">// 5.切后序数组</span><br>\tleftPostorder := postorder[:<span class=\"hljs-built_in\">len</span>(leftInorder)]<br>\trightPostorder := postorder[<span class=\"hljs-built_in\">len</span>(leftPostorder) : <span class=\"hljs-built_in\">len</span>(leftPostorder)+<span class=\"hljs-built_in\">len</span>(rightInorder)]<br>\t<span class=\"hljs-comment\">// 6.递归处理左区间 右区间</span><br>\troot.Left = buildTree(leftInorder, leftPostorder)<br>\troot.Right = buildTree(rightInorder, rightPostorder)<br>\t<span class=\"hljs-keyword\">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 前序中序建立二叉树</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">buildTree2</span><span class=\"hljs-params\">(preorder []<span class=\"hljs-type\">int</span>, inorder []<span class=\"hljs-type\">int</span>)</span></span> *TreeNode &#123;<br>\t<span class=\"hljs-comment\">// 1.前序数组为0, 空节点</span><br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(preorder) == <span class=\"hljs-number\">0</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2.前序数组第一个元素为节点元素</span><br>\trootValue := preorder[<span class=\"hljs-number\">0</span>]<br>\troot := &amp;TreeNode&#123;<br>\t\tVal:   rootValue,<br>\t\tLeft:  <span class=\"hljs-literal\">nil</span>,<br>\t\tRight: <span class=\"hljs-literal\">nil</span>,<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(preorder) == <span class=\"hljs-number\">1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> root<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3.寻找中序数组位置  作切割点</span><br>\tindex := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> ; index &lt; <span class=\"hljs-built_in\">len</span>(inorder); index++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> inorder[index] == rootValue &#123;<br>\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 4.切中序数组</span><br>\tleftInorder := inorder[:index]<br>\trightInorder := inorder[index+<span class=\"hljs-number\">1</span>:]<br>\t<span class=\"hljs-comment\">// 5.切前序数组</span><br>\tleftPreorder := preorder[<span class=\"hljs-number\">1</span> : <span class=\"hljs-built_in\">len</span>(leftInorder)+<span class=\"hljs-number\">1</span>]<br>\trightPreorder := preorder[<span class=\"hljs-built_in\">len</span>(leftPreorder)+<span class=\"hljs-number\">1</span>:]<br>\t<span class=\"hljs-comment\">// 6.递归处理左区间 右区间</span><br>\troot.Left = buildTree2(leftPreorder, leftInorder)<br>\troot.Right = buildTree2(rightPreorder, rightInorder)<br>\t<span class=\"hljs-keyword\">return</span> root<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码随想录算法训练营第十八天-513找树左下角的值、112-路径总和、113-路径总和II、106-从中序与后序遍历序列构造二叉树、105-从前序与中序遍历序列构造二叉树\"><a href=\"#代码随想录算法训练营第十八天-513找树左下角的值、112-路径总和、113-路径总和II、106-从中序与后序遍历序列构造二叉树、105-从前序与中序遍历序列构造二叉树\" class=\"headerlink\" title=\"代码随想录算法训练营第十八天  513找树左下角的值、112.路径总和、113.路径总和II、106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树\"></a>代码随想录算法训练营第十八天  513找树左下角的值、112.路径总和、113.路径总和II、106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树</h1><h2 id=\"513-找树左下角的值\"><a href=\"#513-找树左下角的值\" class=\"headerlink\" title=\"513. 找树左下角的值\"></a>513. 找树左下角的值</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/find-bottom-left-tree-value/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1424y1Z7pn\">怎么找二叉树的左下角？ 递归中又带回溯了，怎么办？| LeetCode：513.找二叉树左下角的值</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这道题对左下角的定义是：最后一行，最左面的元素，只需要层序遍历，输出最后一行的第一个元素即可。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findBottomLeftValue</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>\tqueue := arrayqueue.New()<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\tqueue.Enqueue(root)<br>\t<span class=\"hljs-keyword\">for</span> !queue.Empty() &#123;<br>\t\tsize := queue.Size()<br>\t\ttemp := []<span class=\"hljs-type\">int</span>&#123;&#125;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;<br>\t\t\tnode, _ := queue.Dequeue()<br>\t\t\ttemp = <span class=\"hljs-built_in\">append</span>(temp, node.(*TreeNode).Val)<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Left)<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> node.(*TreeNode).Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t\tqueue.Enqueue(node.(*TreeNode).Right)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tresult = <span class=\"hljs-built_in\">append</span>(result, temp)<br>\t&#125;<br>\tfmt.Println(result)<br>\t<span class=\"hljs-keyword\">return</span> result[<span class=\"hljs-built_in\">len</span>(result)<span class=\"hljs-number\">-1</span>][<span class=\"hljs-number\">0</span>]<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"112-路径总和、113-路径总和II\"><a href=\"#112-路径总和、113-路径总和II\" class=\"headerlink\" title=\"112. 路径总和、113. 路径总和II\"></a>112. 路径总和、113. 路径总和II</h2><blockquote>\n<p>  题目链接：</p>\n<ul>\n<li><a href=\"https://leetcode.cn/problems/path-sum/\">112.路径总和</a></li>\n<li><a href=\"https://leetcode.cn/problems/path-sum-ii/\">113.路径总和ii</a></li>\n</ul>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV19t4y1L7CR\">拿不准的遍历顺序，搞不清的回溯过程，我太难了！ | LeetCode：112. 路径总和</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>找到根节点到叶子节点的路径：这里使用先序遍历（深度搜索）</li>\n<li>将该路径所有节点求和，判断是否等于<code>targetSum</code>，有则保存至<code>result</code>中</li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 112题</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">hasPathSum</span><span class=\"hljs-params\">(root *TreeNode, targetSum <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">var</span> path []<span class=\"hljs-type\">int</span><br>\tgetResult(root, &amp;result, &amp;path)<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(result); i++ &#123;<br>\t\tsum := <span class=\"hljs-number\">0</span><br>\t\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> result[i] &#123;<br>\t\t\tsum += v<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> sum == targetSum &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getResult</span><span class=\"hljs-params\">(root *TreeNode, result *[][]<span class=\"hljs-type\">int</span>, path *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\ttemp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(*path))<br>\t\t<span class=\"hljs-built_in\">copy</span>(temp, *path)<br>\t\t*result = <span class=\"hljs-built_in\">append</span>(*result, temp)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tgetResult(root.Left, result, path)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tgetResult(root.Right, result, path)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 113题</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">pathSum</span><span class=\"hljs-params\">(root *TreeNode, targetSum <span class=\"hljs-type\">int</span>)</span></span> [][]<span class=\"hljs-type\">int</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> result [][]<span class=\"hljs-type\">int</span><br>\t<span class=\"hljs-keyword\">var</span> path []<span class=\"hljs-type\">int</span><br>\tgetResult1(root, &amp;result, &amp;path, targetSum)<br>\t<span class=\"hljs-keyword\">return</span> result<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getResult1</span><span class=\"hljs-params\">(root *TreeNode, result *[][]<span class=\"hljs-type\">int</span>, path *[]<span class=\"hljs-type\">int</span>, target <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tsum := <span class=\"hljs-number\">0</span><br>\t\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> *path &#123;<br>\t\t\tsum += v<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> sum == target &#123;<br>\t\t\ttemp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(*path))<br>\t\t\t<span class=\"hljs-built_in\">copy</span>(temp, *path)<br>\t\t\t*result = <span class=\"hljs-built_in\">append</span>(*result, temp)<br>\t\t&#125;<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tgetResult1(root.Left, result, path, target)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\t\tgetResult1(root.Right, result, path, target)<br>\t\t*path = (*path)[:<span class=\"hljs-built_in\">len</span>(*path)<span class=\"hljs-number\">-1</span>]<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"106-从中序与后序遍历序列构造二叉树、105-从前序与中序遍历序列构造二叉树\"><a href=\"#106-从中序与后序遍历序列构造二叉树、105-从前序与中序遍历序列构造二叉树\" class=\"headerlink\" title=\"106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树\"></a>106.从中序与后序遍历序列构造二叉树、105.从前序与中序遍历序列构造二叉树</h2><blockquote>\n<p>  题目链接：</p>\n<ul>\n<li><a href=\"https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\">106.从中序与后序遍历序列构造二叉树</a></li>\n<li><a href=\"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">105.从前序与中序遍历序列构造二叉树</a></li>\n</ul>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1vW4y1i7dn\">坑很多！来看看你掉过几次坑 | LeetCode：106.从中序与后序遍历序列构造二叉树</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这道题自己最开始想的不是很明白，而且自己在考试时做这类题也没有固定的套路，看了下卡哥的讲解</p>\n<ul>\n<li>后序数组长度为0, 空节点</li>\n<li>后序数组最后一个元素为父节点元素</li>\n<li>寻找中序数组位置  作切割点</li>\n<li>切中序数组</li>\n<li>切后序数组</li>\n<li>递归处理左区间 右区间</li>\n</ul>\n<div style=\"position: relative; width: 100%; height: 0;padding-bottom: 100%;\"><iframe \nsrc=\"../images/day18/力扣106.mp4\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 中序后序建立二叉树</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">buildTree</span><span class=\"hljs-params\">(inorder []<span class=\"hljs-type\">int</span>, postorder []<span class=\"hljs-type\">int</span>)</span></span> *TreeNode &#123;<br>\t<span class=\"hljs-comment\">// 1.后序数组长度为0, 空节点</span><br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(postorder) == <span class=\"hljs-number\">0</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2.后序数组最后一个元素为父节点元素</span><br>\trootValue := postorder[<span class=\"hljs-built_in\">len</span>(postorder)<span class=\"hljs-number\">-1</span>]<br>\troot := &amp;TreeNode&#123;<br>\t\tVal:   rootValue,<br>\t\tLeft:  <span class=\"hljs-literal\">nil</span>,<br>\t\tRight: <span class=\"hljs-literal\">nil</span>,<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(postorder) == <span class=\"hljs-number\">1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> root<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3.寻找中序数组位置  作切割点</span><br>\tindex := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> ; index &lt; <span class=\"hljs-built_in\">len</span>(inorder); index++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> inorder[index] == rootValue &#123;<br>\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 4.切中序数组</span><br>\tleftInorder := inorder[:index]<br>\trightInorder := inorder[index+<span class=\"hljs-number\">1</span>:]<br>\t<span class=\"hljs-comment\">// 5.切后序数组</span><br>\tleftPostorder := postorder[:<span class=\"hljs-built_in\">len</span>(leftInorder)]<br>\trightPostorder := postorder[<span class=\"hljs-built_in\">len</span>(leftPostorder) : <span class=\"hljs-built_in\">len</span>(leftPostorder)+<span class=\"hljs-built_in\">len</span>(rightInorder)]<br>\t<span class=\"hljs-comment\">// 6.递归处理左区间 右区间</span><br>\troot.Left = buildTree(leftInorder, leftPostorder)<br>\troot.Right = buildTree(rightInorder, rightPostorder)<br>\t<span class=\"hljs-keyword\">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 前序中序建立二叉树</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">buildTree2</span><span class=\"hljs-params\">(preorder []<span class=\"hljs-type\">int</span>, inorder []<span class=\"hljs-type\">int</span>)</span></span> *TreeNode &#123;<br>\t<span class=\"hljs-comment\">// 1.前序数组为0, 空节点</span><br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(preorder) == <span class=\"hljs-number\">0</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2.前序数组第一个元素为节点元素</span><br>\trootValue := preorder[<span class=\"hljs-number\">0</span>]<br>\troot := &amp;TreeNode&#123;<br>\t\tVal:   rootValue,<br>\t\tLeft:  <span class=\"hljs-literal\">nil</span>,<br>\t\tRight: <span class=\"hljs-literal\">nil</span>,<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(preorder) == <span class=\"hljs-number\">1</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> root<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3.寻找中序数组位置  作切割点</span><br>\tindex := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> ; index &lt; <span class=\"hljs-built_in\">len</span>(inorder); index++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> inorder[index] == rootValue &#123;<br>\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 4.切中序数组</span><br>\tleftInorder := inorder[:index]<br>\trightInorder := inorder[index+<span class=\"hljs-number\">1</span>:]<br>\t<span class=\"hljs-comment\">// 5.切前序数组</span><br>\tleftPreorder := preorder[<span class=\"hljs-number\">1</span> : <span class=\"hljs-built_in\">len</span>(leftInorder)+<span class=\"hljs-number\">1</span>]<br>\trightPreorder := preorder[<span class=\"hljs-built_in\">len</span>(leftPreorder)+<span class=\"hljs-number\">1</span>:]<br>\t<span class=\"hljs-comment\">// 6.递归处理左区间 右区间</span><br>\troot.Left = buildTree2(leftPreorder, leftInorder)<br>\troot.Right = buildTree2(rightPreorder, rightInorder)<br>\t<span class=\"hljs-keyword\">return</span> root<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n"},{"title":"代码随想录算法训练营第十九天  654.最大二叉树、617.合并二叉树、700.二叉搜索树中的搜索、98.验证二叉搜索树","date":"2023-10-12T14:38:04.000Z","_content":"\n# 代码随想录算法训练营第十九天 654.最大二叉树、617.合并二叉树、700.二叉搜索树中的搜索、98.验证二叉搜索树\n\n## 654.最大二叉树\n\n>   题目链接：[力扣题目地址](https://leetcode.cn/problems/maximum-binary-tree/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html)\n>\n>   视频讲解：[又是构造二叉树，又有很多坑！| LeetCode：654.最大二叉树](https://www.bilibili.com/video/BV1MG411G7ox)\n>\n>   状态：AC\n\n### 思路\n\n1.   找到当前数组最大值`max`以及所在位置`maxIndex`\n2.   新建一个节点，将`max`设为节点的值，判断此时的数组长度是否为0\n3.   切割左数组和右数组、并向左子树和右子树递归\n\n### 代码\n\n``` go\nfunc constructMaximumBinaryTree(nums []int) *TreeNode {\n\tmax := 0\n\tmaxIndex := 0\n\tfor i, v := range nums {\n\t\tif v > max {\n\t\t\tmax = v\n\t\t\tmaxIndex = i\n\t\t}\n\t}\n\troot := &TreeNode{\n\t\tVal:   max,\n\t\tLeft:  nil,\n\t\tRight: nil,\n\t}\n\tif len(nums) == 0 {\n\t\treturn root\n\t}\n\tleftNums := nums[:maxIndex]\n\trightNums := nums[maxIndex+1:]\n\tif len(leftNums) != 0 {\n\t\troot.Left = constructMaximumBinaryTree(leftNums)\n\t}\n\tif len(rightNums) != 0 {\n\t\troot.Right = constructMaximumBinaryTree(rightNums)\n\t}\n\treturn root\n}\n```\n\n## 617. 合并二叉树\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/merge-two-binary-trees/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html)\n>\n>   视频讲解：[一起操作两个二叉树？有点懵！| LeetCode：617.合并二叉树](https://www.bilibili.com/video/BV1m14y1Y7JK)\n>\n>   状态：AC\n\n### 思路\n\n合并二叉树首先以其中一棵树为基准，将另一棵树“移植”过来。这里以`root1`为准\n\n1.   如果`root1`是空节点，说明应该把`root2`的东西“移植过来”（如果没有也没事）\n2.   反之同理，如果`root2`是空节点，则`root1`继续向下遍历\n3.   `root1.Val += root2.Val`\n4.   `root1.Left`是两棵树向左节点遍历返回的结果。`root1.Right`是两棵树向左节点遍历返回的结果\n\n### 代码\n\n``` go\nfunc mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {\n\tif root1 == nil {\n\t\treturn root2\n\t}\n\tif root2 == nil {\n\t\treturn root1\n\t}\n\troot1.Val += root2.Val\n\troot1.Left = mergeTrees(root1.Left, root2.Left)\n\troot1.Right = mergeTrees(root1.Right, root2.Right)\n\treturn root1\n}\n```\n\n## 700.二叉搜索树中的搜索\n\n>   题目链接：[力扣题目地址](https://leetcode.cn/problems/search-in-a-binary-search-tree/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html)\n>\n>   视频讲解：[不愧是搜索树，这次搜索有方向了！| LeetCode：700.二叉搜索树中的搜索](https://www.bilibili.com/video/BV1wG411g7sF)\n>\n>   状态：AC\n\n### 思路\n\n这里的搜索并不是返回是否找到，而是要返回子树，总的思路是一样的\n\n1.   `val < root.Val`，向左找；`val > root.Val`，向右找；相等则返回当前结点（包含了子树）\n\n### 代码\n\n``` go\nfunc searchBST(root *TreeNode, val int) *TreeNode {\n\tif root == nil {\n\t\treturn nil\n\t}\n\tvar node *TreeNode\n\tif root.Val == val {\n\t\tnode = root\n\t\treturn node\n\t} else if val < root.Val {\n\t\tnode = searchBST(root.Left, val)\n\t} else {\n\t\tnode = searchBST(root.Right, val)\n\t}\n\treturn node\n}\n```\n\n## 98. 验证二叉搜索树\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/validate-binary-search-tree/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://leetcode.cn/problems/validate-binary-search-tree/)\n>\n>   视频讲解：[你对二叉搜索树了解的还不够！ | LeetCode：98.验证二叉搜索树](https://www.bilibili.com/video/BV18P411n7Q4)\n>\n>   状态：AC\n\n### 思路\n\n-   <font color=\"red\">错误思路</font>：顺序遍历每个节点，比较是否“左<根<右”，如果均满足返回true，否则是false\n\n    >   错误原因：如果树如下\n    >\n    >   ​            2\n    >\n    >   ​         /     \\\n    >\n    >   ​       1        3\n    >\n    >   ​         \\\n    >\n    >   ​           4\n    >\n    >   4比2大，但是出现在了2的左边\n    >\n    >   ``` go\n    >   // 错误的代码\n    >   func isValidBST(root *TreeNode) bool {\n    >   \tif root.Left == nil && root.Right != nil {\n    >   \t\tif root.Val < root.Right.Val {\n    >   \t\t\treturn isValidBST(root.Right)\n    >   \t\t} else {\n    >   \t\t\treturn false\n    >   \t\t}\n    >   \t} else if root.Left != nil && root.Right == nil {\n    >   \t\tif root.Left.Val < root.Val {\n    >   \t\t\treturn isValidBST(root.Left)\n    >   \t\t} else {\n    >   \t\t\treturn false\n    >   \t\t}\n    >   \t} else if root.Left != nil && root.Right != nil {\n    >   \t  if root.Left.Val < root.Val && root.Val < root.Right.Val {\n    >   \t\treturn isValidBST(root.Left) && isValidBST(root.Right)\n    >   \t} else {\n    >   \t\treturn false\n    >   \t\t}\n    >       } else {\n    >   \t\treturn true\n    >   \t}\n    >   }\n    >   ```\n    >\n    >   \n\n-   简单看了下卡哥的文档，知道了用中序遍历，中序遍历得到的结果如果是递增序列则为搜索树\n\n    >   如果树为如下，力扣的测试用例返回的是false，所以不能出现相等的情况\n    >\n    >   ​            2\n    >\n    >   ​         /     \\\n    >\n    >   ​       2        2\n\n### 代码\n\n``` go\nfunc isValidBST(root *TreeNode) bool {\n\tvar path []int\n\tinorder(root, &path)\n\tfor i := 1; i < len(path); i++ {\n\t\tif path[i-1] >= path[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\nfunc inorder(root *TreeNode, path *[]int) {\n\tif root == nil {\n\t\treturn\n\t}\n\tinorder(root.Left, path)\n\t*path = append(*path, root.Val)\n\tinorder(root.Right, path)\n}\n```\n\n","source":"_posts/day19.md","raw":"---\ntitle: 代码随想录算法训练营第十九天  654.最大二叉树、617.合并二叉树、700.二叉搜索树中的搜索、98.验证二叉搜索树\ndate: 2023-10-12 22:38:04\ntags:\n  - 算法\n  - 代码随想录\n  - LeetCode\ncategories: 刷题\n---\n\n# 代码随想录算法训练营第十九天 654.最大二叉树、617.合并二叉树、700.二叉搜索树中的搜索、98.验证二叉搜索树\n\n## 654.最大二叉树\n\n>   题目链接：[力扣题目地址](https://leetcode.cn/problems/maximum-binary-tree/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html)\n>\n>   视频讲解：[又是构造二叉树，又有很多坑！| LeetCode：654.最大二叉树](https://www.bilibili.com/video/BV1MG411G7ox)\n>\n>   状态：AC\n\n### 思路\n\n1.   找到当前数组最大值`max`以及所在位置`maxIndex`\n2.   新建一个节点，将`max`设为节点的值，判断此时的数组长度是否为0\n3.   切割左数组和右数组、并向左子树和右子树递归\n\n### 代码\n\n``` go\nfunc constructMaximumBinaryTree(nums []int) *TreeNode {\n\tmax := 0\n\tmaxIndex := 0\n\tfor i, v := range nums {\n\t\tif v > max {\n\t\t\tmax = v\n\t\t\tmaxIndex = i\n\t\t}\n\t}\n\troot := &TreeNode{\n\t\tVal:   max,\n\t\tLeft:  nil,\n\t\tRight: nil,\n\t}\n\tif len(nums) == 0 {\n\t\treturn root\n\t}\n\tleftNums := nums[:maxIndex]\n\trightNums := nums[maxIndex+1:]\n\tif len(leftNums) != 0 {\n\t\troot.Left = constructMaximumBinaryTree(leftNums)\n\t}\n\tif len(rightNums) != 0 {\n\t\troot.Right = constructMaximumBinaryTree(rightNums)\n\t}\n\treturn root\n}\n```\n\n## 617. 合并二叉树\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/merge-two-binary-trees/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html)\n>\n>   视频讲解：[一起操作两个二叉树？有点懵！| LeetCode：617.合并二叉树](https://www.bilibili.com/video/BV1m14y1Y7JK)\n>\n>   状态：AC\n\n### 思路\n\n合并二叉树首先以其中一棵树为基准，将另一棵树“移植”过来。这里以`root1`为准\n\n1.   如果`root1`是空节点，说明应该把`root2`的东西“移植过来”（如果没有也没事）\n2.   反之同理，如果`root2`是空节点，则`root1`继续向下遍历\n3.   `root1.Val += root2.Val`\n4.   `root1.Left`是两棵树向左节点遍历返回的结果。`root1.Right`是两棵树向左节点遍历返回的结果\n\n### 代码\n\n``` go\nfunc mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {\n\tif root1 == nil {\n\t\treturn root2\n\t}\n\tif root2 == nil {\n\t\treturn root1\n\t}\n\troot1.Val += root2.Val\n\troot1.Left = mergeTrees(root1.Left, root2.Left)\n\troot1.Right = mergeTrees(root1.Right, root2.Right)\n\treturn root1\n}\n```\n\n## 700.二叉搜索树中的搜索\n\n>   题目链接：[力扣题目地址](https://leetcode.cn/problems/search-in-a-binary-search-tree/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html)\n>\n>   视频讲解：[不愧是搜索树，这次搜索有方向了！| LeetCode：700.二叉搜索树中的搜索](https://www.bilibili.com/video/BV1wG411g7sF)\n>\n>   状态：AC\n\n### 思路\n\n这里的搜索并不是返回是否找到，而是要返回子树，总的思路是一样的\n\n1.   `val < root.Val`，向左找；`val > root.Val`，向右找；相等则返回当前结点（包含了子树）\n\n### 代码\n\n``` go\nfunc searchBST(root *TreeNode, val int) *TreeNode {\n\tif root == nil {\n\t\treturn nil\n\t}\n\tvar node *TreeNode\n\tif root.Val == val {\n\t\tnode = root\n\t\treturn node\n\t} else if val < root.Val {\n\t\tnode = searchBST(root.Left, val)\n\t} else {\n\t\tnode = searchBST(root.Right, val)\n\t}\n\treturn node\n}\n```\n\n## 98. 验证二叉搜索树\n\n>   题目链接：[力扣题目链接](https://leetcode.cn/problems/validate-binary-search-tree/)\n>\n>   文章讲解：[代码随想录(https://programmercarl.com)](https://leetcode.cn/problems/validate-binary-search-tree/)\n>\n>   视频讲解：[你对二叉搜索树了解的还不够！ | LeetCode：98.验证二叉搜索树](https://www.bilibili.com/video/BV18P411n7Q4)\n>\n>   状态：AC\n\n### 思路\n\n-   <font color=\"red\">错误思路</font>：顺序遍历每个节点，比较是否“左<根<右”，如果均满足返回true，否则是false\n\n    >   错误原因：如果树如下\n    >\n    >   ​            2\n    >\n    >   ​         /     \\\n    >\n    >   ​       1        3\n    >\n    >   ​         \\\n    >\n    >   ​           4\n    >\n    >   4比2大，但是出现在了2的左边\n    >\n    >   ``` go\n    >   // 错误的代码\n    >   func isValidBST(root *TreeNode) bool {\n    >   \tif root.Left == nil && root.Right != nil {\n    >   \t\tif root.Val < root.Right.Val {\n    >   \t\t\treturn isValidBST(root.Right)\n    >   \t\t} else {\n    >   \t\t\treturn false\n    >   \t\t}\n    >   \t} else if root.Left != nil && root.Right == nil {\n    >   \t\tif root.Left.Val < root.Val {\n    >   \t\t\treturn isValidBST(root.Left)\n    >   \t\t} else {\n    >   \t\t\treturn false\n    >   \t\t}\n    >   \t} else if root.Left != nil && root.Right != nil {\n    >   \t  if root.Left.Val < root.Val && root.Val < root.Right.Val {\n    >   \t\treturn isValidBST(root.Left) && isValidBST(root.Right)\n    >   \t} else {\n    >   \t\treturn false\n    >   \t\t}\n    >       } else {\n    >   \t\treturn true\n    >   \t}\n    >   }\n    >   ```\n    >\n    >   \n\n-   简单看了下卡哥的文档，知道了用中序遍历，中序遍历得到的结果如果是递增序列则为搜索树\n\n    >   如果树为如下，力扣的测试用例返回的是false，所以不能出现相等的情况\n    >\n    >   ​            2\n    >\n    >   ​         /     \\\n    >\n    >   ​       2        2\n\n### 代码\n\n``` go\nfunc isValidBST(root *TreeNode) bool {\n\tvar path []int\n\tinorder(root, &path)\n\tfor i := 1; i < len(path); i++ {\n\t\tif path[i-1] >= path[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\nfunc inorder(root *TreeNode, path *[]int) {\n\tif root == nil {\n\t\treturn\n\t}\n\tinorder(root.Left, path)\n\t*path = append(*path, root.Val)\n\tinorder(root.Right, path)\n}\n```\n\n","slug":"day19","published":1,"updated":"2023-10-12T14:59:22.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clnnb2tpy0000soz8djs5abxe","content":"<h1 id=\"代码随想录算法训练营第十九天-654-最大二叉树、617-合并二叉树、700-二叉搜索树中的搜索、98-验证二叉搜索树\"><a href=\"#代码随想录算法训练营第十九天-654-最大二叉树、617-合并二叉树、700-二叉搜索树中的搜索、98-验证二叉搜索树\" class=\"headerlink\" title=\"代码随想录算法训练营第十九天 654.最大二叉树、617.合并二叉树、700.二叉搜索树中的搜索、98.验证二叉搜索树\"></a>代码随想录算法训练营第十九天 654.最大二叉树、617.合并二叉树、700.二叉搜索树中的搜索、98.验证二叉搜索树</h1><h2 id=\"654-最大二叉树\"><a href=\"#654-最大二叉树\" class=\"headerlink\" title=\"654.最大二叉树\"></a>654.最大二叉树</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/maximum-binary-tree/\">力扣题目地址</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1MG411G7ox\">又是构造二叉树，又有很多坑！| LeetCode：654.最大二叉树</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>找到当前数组最大值<code>max</code>以及所在位置<code>maxIndex</code></li>\n<li>新建一个节点，将<code>max</code>设为节点的值，判断此时的数组长度是否为0</li>\n<li>切割左数组和右数组、并向左子树和右子树递归</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">constructMaximumBinaryTree</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> *TreeNode &#123;<br>\tmax := <span class=\"hljs-number\">0</span><br>\tmaxIndex := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v &gt; max &#123;<br>\t\t\tmax = v<br>\t\t\tmaxIndex = i<br>\t\t&#125;<br>\t&#125;<br>\troot := &amp;TreeNode&#123;<br>\t\tVal:   max,<br>\t\tLeft:  <span class=\"hljs-literal\">nil</span>,<br>\t\tRight: <span class=\"hljs-literal\">nil</span>,<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(nums) == <span class=\"hljs-number\">0</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> root<br>\t&#125;<br>\tleftNums := nums[:maxIndex]<br>\trightNums := nums[maxIndex+<span class=\"hljs-number\">1</span>:]<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(leftNums) != <span class=\"hljs-number\">0</span> &#123;<br>\t\troot.Left = constructMaximumBinaryTree(leftNums)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(rightNums) != <span class=\"hljs-number\">0</span> &#123;<br>\t\troot.Right = constructMaximumBinaryTree(rightNums)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"617-合并二叉树\"><a href=\"#617-合并二叉树\" class=\"headerlink\" title=\"617. 合并二叉树\"></a>617. 合并二叉树</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/merge-two-binary-trees/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1m14y1Y7JK\">一起操作两个二叉树？有点懵！| LeetCode：617.合并二叉树</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>合并二叉树首先以其中一棵树为基准，将另一棵树“移植”过来。这里以<code>root1</code>为准</p>\n<ol>\n<li>如果<code>root1</code>是空节点，说明应该把<code>root2</code>的东西“移植过来”（如果没有也没事）</li>\n<li>反之同理，如果<code>root2</code>是空节点，则<code>root1</code>继续向下遍历</li>\n<li><code>root1.Val += root2.Val</code></li>\n<li><code>root1.Left</code>是两棵树向左节点遍历返回的结果。<code>root1.Right</code>是两棵树向左节点遍历返回的结果</li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">mergeTrees</span><span class=\"hljs-params\">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;<br>\t<span class=\"hljs-keyword\">if</span> root1 == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> root2<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root2 == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> root1<br>\t&#125;<br>\troot1.Val += root2.Val<br>\troot1.Left = mergeTrees(root1.Left, root2.Left)<br>\troot1.Right = mergeTrees(root1.Right, root2.Right)<br>\t<span class=\"hljs-keyword\">return</span> root1<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"700-二叉搜索树中的搜索\"><a href=\"#700-二叉搜索树中的搜索\" class=\"headerlink\" title=\"700.二叉搜索树中的搜索\"></a>700.二叉搜索树中的搜索</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/search-in-a-binary-search-tree/\">力扣题目地址</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1wG411g7sF\">不愧是搜索树，这次搜索有方向了！| LeetCode：700.二叉搜索树中的搜索</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这里的搜索并不是返回是否找到，而是要返回子树，总的思路是一样的</p>\n<ol>\n<li><code>val &lt; root.Val</code>，向左找；<code>val &gt; root.Val</code>，向右找；相等则返回当前结点（包含了子树）</li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">searchBST</span><span class=\"hljs-params\">(root *TreeNode, val <span class=\"hljs-type\">int</span>)</span></span> *TreeNode &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">var</span> node *TreeNode<br>\t<span class=\"hljs-keyword\">if</span> root.Val == val &#123;<br>\t\tnode = root<br>\t\t<span class=\"hljs-keyword\">return</span> node<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> val &lt; root.Val &#123;<br>\t\tnode = searchBST(root.Left, val)<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\tnode = searchBST(root.Right, val)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> node<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"98-验证二叉搜索树\"><a href=\"#98-验证二叉搜索树\" class=\"headerlink\" title=\"98. 验证二叉搜索树\"></a>98. 验证二叉搜索树</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/validate-binary-search-tree/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://leetcode.cn/problems/validate-binary-search-tree/\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV18P411n7Q4\">你对二叉搜索树了解的还不够！ | LeetCode：98.验证二叉搜索树</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li><p><font color=\"red\">错误思路</font>：顺序遍历每个节点，比较是否“左&lt;根&lt;右”，如果均满足返回true，否则是false</p>\n<blockquote>\n<p>  错误原因：如果树如下</p>\n<p>  ​            2</p>\n<p>  ​         &#x2F;     \\</p>\n<p>  ​       1        3</p>\n<p>  ​         \\</p>\n<p>  ​           4</p>\n<p>  4比2大，但是出现在了2的左边</p>\n  <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 错误的代码</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isValidBST</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> root.Val &lt; root.Right.Val &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> isValidBST(root.Right)<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> root.Left.Val &lt; root.Val &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> isValidBST(root.Left)<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t  <span class=\"hljs-keyword\">if</span> root.Left.Val &lt; root.Val &amp;&amp; root.Val &lt; root.Right.Val &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> isValidBST(root.Left) &amp;&amp; isValidBST(root.Right)<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n</blockquote>\n</li>\n<li><p>简单看了下卡哥的文档，知道了用中序遍历，中序遍历得到的结果如果是递增序列则为搜索树</p>\n<blockquote>\n<p>  如果树为如下，力扣的测试用例返回的是false，所以不能出现相等的情况</p>\n<p>  ​            2</p>\n<p>  ​         &#x2F;     \\</p>\n<p>  ​       2        2</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isValidBST</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> path []<span class=\"hljs-type\">int</span><br>\tinorder(root, &amp;path)<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(path); i++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> path[i<span class=\"hljs-number\">-1</span>] &gt;= path[i] &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">inorder</span><span class=\"hljs-params\">(root *TreeNode, path *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\tinorder(root.Left, path)<br>\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\tinorder(root.Right, path)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"abbrlink":"38d5093a","excerpt":"","more":"<h1 id=\"代码随想录算法训练营第十九天-654-最大二叉树、617-合并二叉树、700-二叉搜索树中的搜索、98-验证二叉搜索树\"><a href=\"#代码随想录算法训练营第十九天-654-最大二叉树、617-合并二叉树、700-二叉搜索树中的搜索、98-验证二叉搜索树\" class=\"headerlink\" title=\"代码随想录算法训练营第十九天 654.最大二叉树、617.合并二叉树、700.二叉搜索树中的搜索、98.验证二叉搜索树\"></a>代码随想录算法训练营第十九天 654.最大二叉树、617.合并二叉树、700.二叉搜索树中的搜索、98.验证二叉搜索树</h1><h2 id=\"654-最大二叉树\"><a href=\"#654-最大二叉树\" class=\"headerlink\" title=\"654.最大二叉树\"></a>654.最大二叉树</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/maximum-binary-tree/\">力扣题目地址</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1MG411G7ox\">又是构造二叉树，又有很多坑！| LeetCode：654.最大二叉树</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>找到当前数组最大值<code>max</code>以及所在位置<code>maxIndex</code></li>\n<li>新建一个节点，将<code>max</code>设为节点的值，判断此时的数组长度是否为0</li>\n<li>切割左数组和右数组、并向左子树和右子树递归</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">constructMaximumBinaryTree</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>)</span></span> *TreeNode &#123;<br>\tmax := <span class=\"hljs-number\">0</span><br>\tmaxIndex := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> nums &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> v &gt; max &#123;<br>\t\t\tmax = v<br>\t\t\tmaxIndex = i<br>\t\t&#125;<br>\t&#125;<br>\troot := &amp;TreeNode&#123;<br>\t\tVal:   max,<br>\t\tLeft:  <span class=\"hljs-literal\">nil</span>,<br>\t\tRight: <span class=\"hljs-literal\">nil</span>,<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(nums) == <span class=\"hljs-number\">0</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> root<br>\t&#125;<br>\tleftNums := nums[:maxIndex]<br>\trightNums := nums[maxIndex+<span class=\"hljs-number\">1</span>:]<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(leftNums) != <span class=\"hljs-number\">0</span> &#123;<br>\t\troot.Left = constructMaximumBinaryTree(leftNums)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(rightNums) != <span class=\"hljs-number\">0</span> &#123;<br>\t\troot.Right = constructMaximumBinaryTree(rightNums)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"617-合并二叉树\"><a href=\"#617-合并二叉树\" class=\"headerlink\" title=\"617. 合并二叉树\"></a>617. 合并二叉树</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/merge-two-binary-trees/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1m14y1Y7JK\">一起操作两个二叉树？有点懵！| LeetCode：617.合并二叉树</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>合并二叉树首先以其中一棵树为基准，将另一棵树“移植”过来。这里以<code>root1</code>为准</p>\n<ol>\n<li>如果<code>root1</code>是空节点，说明应该把<code>root2</code>的东西“移植过来”（如果没有也没事）</li>\n<li>反之同理，如果<code>root2</code>是空节点，则<code>root1</code>继续向下遍历</li>\n<li><code>root1.Val += root2.Val</code></li>\n<li><code>root1.Left</code>是两棵树向左节点遍历返回的结果。<code>root1.Right</code>是两棵树向左节点遍历返回的结果</li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">mergeTrees</span><span class=\"hljs-params\">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;<br>\t<span class=\"hljs-keyword\">if</span> root1 == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> root2<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> root2 == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> root1<br>\t&#125;<br>\troot1.Val += root2.Val<br>\troot1.Left = mergeTrees(root1.Left, root2.Left)<br>\troot1.Right = mergeTrees(root1.Right, root2.Right)<br>\t<span class=\"hljs-keyword\">return</span> root1<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"700-二叉搜索树中的搜索\"><a href=\"#700-二叉搜索树中的搜索\" class=\"headerlink\" title=\"700.二叉搜索树中的搜索\"></a>700.二叉搜索树中的搜索</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/search-in-a-binary-search-tree/\">力扣题目地址</a></p>\n<p>  文章讲解：<a href=\"https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV1wG411g7sF\">不愧是搜索树，这次搜索有方向了！| LeetCode：700.二叉搜索树中的搜索</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这里的搜索并不是返回是否找到，而是要返回子树，总的思路是一样的</p>\n<ol>\n<li><code>val &lt; root.Val</code>，向左找；<code>val &gt; root.Val</code>，向右找；相等则返回当前结点（包含了子树）</li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">searchBST</span><span class=\"hljs-params\">(root *TreeNode, val <span class=\"hljs-type\">int</span>)</span></span> *TreeNode &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">var</span> node *TreeNode<br>\t<span class=\"hljs-keyword\">if</span> root.Val == val &#123;<br>\t\tnode = root<br>\t\t<span class=\"hljs-keyword\">return</span> node<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> val &lt; root.Val &#123;<br>\t\tnode = searchBST(root.Left, val)<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\tnode = searchBST(root.Right, val)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> node<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"98-验证二叉搜索树\"><a href=\"#98-验证二叉搜索树\" class=\"headerlink\" title=\"98. 验证二叉搜索树\"></a>98. 验证二叉搜索树</h2><blockquote>\n<p>  题目链接：<a href=\"https://leetcode.cn/problems/validate-binary-search-tree/\">力扣题目链接</a></p>\n<p>  文章讲解：<a href=\"https://leetcode.cn/problems/validate-binary-search-tree/\">代码随想录(https://programmercarl.com)</a></p>\n<p>  视频讲解：<a href=\"https://www.bilibili.com/video/BV18P411n7Q4\">你对二叉搜索树了解的还不够！ | LeetCode：98.验证二叉搜索树</a></p>\n<p>  状态：AC</p>\n</blockquote>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li><p><font color=\"red\">错误思路</font>：顺序遍历每个节点，比较是否“左&lt;根&lt;右”，如果均满足返回true，否则是false</p>\n<blockquote>\n<p>  错误原因：如果树如下</p>\n<p>  ​            2</p>\n<p>  ​         &#x2F;     \\</p>\n<p>  ​       1        3</p>\n<p>  ​         \\</p>\n<p>  ​           4</p>\n<p>  4比2大，但是出现在了2的左边</p>\n  <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 错误的代码</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isValidBST</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root.Left == <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> root.Val &lt; root.Right.Val &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> isValidBST(root.Right)<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> root.Left.Val &lt; root.Val &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> isValidBST(root.Left)<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> root.Left != <span class=\"hljs-literal\">nil</span> &amp;&amp; root.Right != <span class=\"hljs-literal\">nil</span> &#123;<br>\t  <span class=\"hljs-keyword\">if</span> root.Left.Val &lt; root.Val &amp;&amp; root.Val &lt; root.Right.Val &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> isValidBST(root.Left) &amp;&amp; isValidBST(root.Right)<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n</blockquote>\n</li>\n<li><p>简单看了下卡哥的文档，知道了用中序遍历，中序遍历得到的结果如果是递增序列则为搜索树</p>\n<blockquote>\n<p>  如果树为如下，力扣的测试用例返回的是false，所以不能出现相等的情况</p>\n<p>  ​            2</p>\n<p>  ​         &#x2F;     \\</p>\n<p>  ​       2        2</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">isValidBST</span><span class=\"hljs-params\">(root *TreeNode)</span></span> <span class=\"hljs-type\">bool</span> &#123;<br>\t<span class=\"hljs-keyword\">var</span> path []<span class=\"hljs-type\">int</span><br>\tinorder(root, &amp;path)<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(path); i++ &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> path[i<span class=\"hljs-number\">-1</span>] &gt;= path[i] &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">inorder</span><span class=\"hljs-params\">(root *TreeNode, path *[]<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span><br>\t&#125;<br>\tinorder(root.Left, path)<br>\t*path = <span class=\"hljs-built_in\">append</span>(*path, root.Val)<br>\tinorder(root.Right, path)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cln60vijt0000wvz8e7d7cupe","category_id":"cln60vijy0002wvz81lsohve1","_id":"cln60vik2000bwvz8abvrgx9z"},{"post_id":"cln60vik4000fwvz84nke6dw8","category_id":"cln60vik5000swvz8flt6ccdq","_id":"cln60vik6000ywvz8hggahjpm"},{"post_id":"cln7q7aln0000vswhdo94d4i6","category_id":"cln60vik10007wvz86q5h7fvk","_id":"cln7q7alu0006vswh2mlja9de"},{"post_id":"cln7q7als0001vswhejetbqe1","category_id":"cln60vik10007wvz86q5h7fvk","_id":"cln7q7alv0009vswhhr1rbj9n"},{"post_id":"cln7q7alt0003vswh2kd6gmmb","category_id":"cln60vik10007wvz86q5h7fvk","_id":"cln7q7alw000cvswh4lye72cz"},{"post_id":"cln7q7alu0005vswhctx76rch","category_id":"cln60vik10007wvz86q5h7fvk","_id":"cln7q7alw000fvswheot34zw2"},{"post_id":"cln7q7alv0008vswh1zq3fitx","category_id":"cln60vik10007wvz86q5h7fvk","_id":"cln7q7alx000ivswh7ab9dk93"},{"post_id":"cln7q7alv000bvswh5akb3kmg","category_id":"cln60vik10007wvz86q5h7fvk","_id":"cln7q7aly000lvswh9juoabj1"},{"post_id":"cln7q7alw000evswh5pqt7yew","category_id":"cln60vik10007wvz86q5h7fvk","_id":"cln7q7aly000nvswh0ut27eyl"},{"post_id":"cln7q7alw000hvswha1iihvvl","category_id":"cln60vik10007wvz86q5h7fvk","_id":"cln7q7aly000pvswhfl7bavdw"},{"post_id":"cln7q7alx000kvswh2zt2gd2z","category_id":"cln60vik10007wvz86q5h7fvk","_id":"cln7q7aly000rvswhf1pl7iqb"},{"post_id":"clnaa9ei20000fowh95tf648u","category_id":"cln60vik10007wvz86q5h7fvk","_id":"clnaa9ei80003fowh9sfo0xwj"},{"post_id":"clnaazf5b0000r4whg2w0by34","category_id":"clnaazf5i0001r4whe4qy94nz","_id":"clnaazf5l0004r4wh7ta930ev"},{"post_id":"clnbysihy0000zez810crdqln","category_id":"cln60vik10007wvz86q5h7fvk","_id":"clnbysihz0003zez84n9vfjnc"},{"post_id":"clneippor0000vez88eiyex1t","category_id":"cln60vik10007wvz86q5h7fvk","_id":"clneippot0003vez87yrw6cie"},{"post_id":"clng3wbhs0000t4whcaffbolr","category_id":"cln60vik10007wvz86q5h7fvk","_id":"clng3wbhx0004t4whdcek4dzq"},{"post_id":"clng3wbhv0001t4wh0pjq02ff","category_id":"cln60vik10007wvz86q5h7fvk","_id":"clng6duwk00021kwhfyo3bnh7"},{"post_id":"clnj3c70v0000puz86u7wb17m","category_id":"cln60vik10007wvz86q5h7fvk","_id":"clnj3c70w0003puz8a7rn3ggr"},{"post_id":"clnlur4z20000n4z8e7m66upr","category_id":"cln60vik10007wvz86q5h7fvk","_id":"clnlur4z50003n4z83sw92iek"},{"post_id":"clnnb2tpy0000soz8djs5abxe","category_id":"cln60vik10007wvz86q5h7fvk","_id":"clnnb2tpz0003soz84djrcww8"}],"PostTag":[{"post_id":"cln60vijt0000wvz8e7d7cupe","tag_id":"cln60vijz0003wvz83hs010u0","_id":"cln60vik5000kwvz84od00srs"},{"post_id":"cln60vijt0000wvz8e7d7cupe","tag_id":"cln60vik10008wvz89egq1d4m","_id":"cln60vik5000nwvz89g6e3uma"},{"post_id":"cln60vijt0000wvz8e7d7cupe","tag_id":"cln60vik2000dwvz86kondzp1","_id":"cln60vik5000qwvz83u6ycvof"},{"post_id":"cln60vik4000fwvz84nke6dw8","tag_id":"cln60vik8001uwvz82jld6gtq","_id":"cln60vik8001ywvz85c1ecnwv"},{"post_id":"cln7q7aln0000vswhdo94d4i6","tag_id":"cln60vik4000iwvz85am5d09t","_id":"cln7q7alt0002vswh5eodebzf"},{"post_id":"cln7q7aln0000vswhdo94d4i6","tag_id":"cln60vik5000owvz820bd6i7h","_id":"cln7q7alu0004vswh9czy35ce"},{"post_id":"cln7q7aln0000vswhdo94d4i6","tag_id":"cln60vik10008wvz89egq1d4m","_id":"cln7q7alv0007vswhd0qj4qnv"},{"post_id":"cln7q7als0001vswhejetbqe1","tag_id":"cln60vik4000iwvz85am5d09t","_id":"cln7q7alv000avswh46gmbkig"},{"post_id":"cln7q7als0001vswhejetbqe1","tag_id":"cln60vik5000owvz820bd6i7h","_id":"cln7q7alw000dvswhdlxa1pal"},{"post_id":"cln7q7als0001vswhejetbqe1","tag_id":"cln60vik10008wvz89egq1d4m","_id":"cln7q7alw000gvswh1bfydqgz"},{"post_id":"cln7q7alt0003vswh2kd6gmmb","tag_id":"cln60vik4000iwvz85am5d09t","_id":"cln7q7alx000jvswhbrhf8owb"},{"post_id":"cln7q7alt0003vswh2kd6gmmb","tag_id":"cln60vik5000owvz820bd6i7h","_id":"cln7q7aly000mvswh1znm56ts"},{"post_id":"cln7q7alt0003vswh2kd6gmmb","tag_id":"cln60vik10008wvz89egq1d4m","_id":"cln7q7aly000ovswhh44f9aow"},{"post_id":"cln7q7alu0005vswhctx76rch","tag_id":"cln60vik4000iwvz85am5d09t","_id":"cln7q7aly000qvswh6izfdv4v"},{"post_id":"cln7q7alu0005vswhctx76rch","tag_id":"cln60vik5000owvz820bd6i7h","_id":"cln7q7aly000svswheaxpadwx"},{"post_id":"cln7q7alu0005vswhctx76rch","tag_id":"cln60vik10008wvz89egq1d4m","_id":"cln7q7aly000tvswhcxze0emp"},{"post_id":"cln7q7alv0008vswh1zq3fitx","tag_id":"cln60vik4000iwvz85am5d09t","_id":"cln7q7aly000uvswh3cqihno5"},{"post_id":"cln7q7alv0008vswh1zq3fitx","tag_id":"cln60vik5000owvz820bd6i7h","_id":"cln7q7aly000vvswha0tz7638"},{"post_id":"cln7q7alv0008vswh1zq3fitx","tag_id":"cln60vik10008wvz89egq1d4m","_id":"cln7q7aly000wvswhdcekgws7"},{"post_id":"cln7q7alv000bvswh5akb3kmg","tag_id":"cln60vik4000iwvz85am5d09t","_id":"cln7q7aly000xvswh4w1ub4qn"},{"post_id":"cln7q7alv000bvswh5akb3kmg","tag_id":"cln60vik5000owvz820bd6i7h","_id":"cln7q7aly000yvswhf45xd8m4"},{"post_id":"cln7q7alv000bvswh5akb3kmg","tag_id":"cln60vik10008wvz89egq1d4m","_id":"cln7q7aly000zvswh50gxbcad"},{"post_id":"cln7q7alw000evswh5pqt7yew","tag_id":"cln60vik4000iwvz85am5d09t","_id":"cln7q7aly0010vswh6zwrgotd"},{"post_id":"cln7q7alw000evswh5pqt7yew","tag_id":"cln60vik5000owvz820bd6i7h","_id":"cln7q7aly0011vswh5pqw1hut"},{"post_id":"cln7q7alw000evswh5pqt7yew","tag_id":"cln60vik10008wvz89egq1d4m","_id":"cln7q7aly0012vswhhmwth4uq"},{"post_id":"cln7q7alw000hvswha1iihvvl","tag_id":"cln60vik4000iwvz85am5d09t","_id":"cln7q7aly0013vswh1zmbemn7"},{"post_id":"cln7q7alw000hvswha1iihvvl","tag_id":"cln60vik5000owvz820bd6i7h","_id":"cln7q7aly0014vswh5lxba3fi"},{"post_id":"cln7q7alw000hvswha1iihvvl","tag_id":"cln60vik10008wvz89egq1d4m","_id":"cln7q7aly0015vswhabxbhq86"},{"post_id":"cln7q7alx000kvswh2zt2gd2z","tag_id":"cln60vik4000iwvz85am5d09t","_id":"cln7q7aly0016vswh921fbhce"},{"post_id":"cln7q7alx000kvswh2zt2gd2z","tag_id":"cln60vik5000owvz820bd6i7h","_id":"cln7q7aly0017vswhbqrle1ba"},{"post_id":"cln7q7alx000kvswh2zt2gd2z","tag_id":"cln60vik10008wvz89egq1d4m","_id":"cln7q7aly0018vswhdg195bnw"},{"post_id":"clnaa9ei20000fowh95tf648u","tag_id":"cln60vik4000iwvz85am5d09t","_id":"clnaa9ei70001fowh6hlddr8c"},{"post_id":"clnaa9ei20000fowh95tf648u","tag_id":"cln60vik5000owvz820bd6i7h","_id":"clnaa9ei80002fowh6it3ds7k"},{"post_id":"clnaa9ei20000fowh95tf648u","tag_id":"cln60vik10008wvz89egq1d4m","_id":"clnaa9ei80004fowh2bcwdh4p"},{"post_id":"clnaazf5b0000r4whg2w0by34","tag_id":"clnaazf5k0002r4wh3xm8393l","_id":"clnaazf5l0005r4wh7jchceb7"},{"post_id":"clnaazf5b0000r4whg2w0by34","tag_id":"cln60vik10008wvz89egq1d4m","_id":"clnaazf5l0006r4whgc5wgkm2"},{"post_id":"clnaazf5b0000r4whg2w0by34","tag_id":"clnaazf5k0003r4wh62knftzl","_id":"clnaazf5m0007r4wh8k015ep3"},{"post_id":"clnbysihy0000zez810crdqln","tag_id":"cln60vik4000iwvz85am5d09t","_id":"clnbysihy0001zez8at3mahdm"},{"post_id":"clnbysihy0000zez810crdqln","tag_id":"cln60vik5000owvz820bd6i7h","_id":"clnbysihz0002zez88t8g3s5u"},{"post_id":"clnbysihy0000zez810crdqln","tag_id":"cln60vik10008wvz89egq1d4m","_id":"clnbysihz0004zez803sw1xqx"},{"post_id":"clneippor0000vez88eiyex1t","tag_id":"cln60vik4000iwvz85am5d09t","_id":"clneippot0001vez8fnum3tb9"},{"post_id":"clneippor0000vez88eiyex1t","tag_id":"cln60vik5000owvz820bd6i7h","_id":"clneippot0002vez8dgmq1psj"},{"post_id":"clneippor0000vez88eiyex1t","tag_id":"cln60vik10008wvz89egq1d4m","_id":"clneippot0004vez8e9oi1323"},{"post_id":"clng3wbhs0000t4whcaffbolr","tag_id":"cln60vik4000iwvz85am5d09t","_id":"clng3wbhw0002t4wh433cbf01"},{"post_id":"clng3wbhs0000t4whcaffbolr","tag_id":"cln60vik5000owvz820bd6i7h","_id":"clng3wbhw0003t4wh22296nsl"},{"post_id":"clng3wbhs0000t4whcaffbolr","tag_id":"cln60vik10008wvz89egq1d4m","_id":"clng3wbhx0005t4wh8zkxby60"},{"post_id":"clng3wbhv0001t4wh0pjq02ff","tag_id":"cln60vik4000iwvz85am5d09t","_id":"clng6duwj00001kwh2c977abf"},{"post_id":"clng3wbhv0001t4wh0pjq02ff","tag_id":"cln60vik5000owvz820bd6i7h","_id":"clng6duwk00011kwh7i6yc2aj"},{"post_id":"clng3wbhv0001t4wh0pjq02ff","tag_id":"cln60vik10008wvz89egq1d4m","_id":"clng6duwk00031kwh8a1v90ir"},{"post_id":"clnj3c70v0000puz86u7wb17m","tag_id":"cln60vik4000iwvz85am5d09t","_id":"clnj3c70w0001puz813hubt62"},{"post_id":"clnj3c70v0000puz86u7wb17m","tag_id":"cln60vik5000owvz820bd6i7h","_id":"clnj3c70w0002puz8fut16m5k"},{"post_id":"clnj3c70v0000puz86u7wb17m","tag_id":"cln60vik10008wvz89egq1d4m","_id":"clnj3c70w0004puz8h4afg6g8"},{"post_id":"clnlur4z20000n4z8e7m66upr","tag_id":"cln60vik4000iwvz85am5d09t","_id":"clnlur4z50001n4z82eigh35a"},{"post_id":"clnlur4z20000n4z8e7m66upr","tag_id":"cln60vik5000owvz820bd6i7h","_id":"clnlur4z50002n4z8b9z09h0v"},{"post_id":"clnlur4z20000n4z8e7m66upr","tag_id":"cln60vik10008wvz89egq1d4m","_id":"clnlur4z50004n4z89s17f0my"},{"post_id":"clnnb2tpy0000soz8djs5abxe","tag_id":"cln60vik4000iwvz85am5d09t","_id":"clnnb2tpz0001soz81dhk53pl"},{"post_id":"clnnb2tpy0000soz8djs5abxe","tag_id":"cln60vik5000owvz820bd6i7h","_id":"clnnb2tpz0002soz80o1z2tym"},{"post_id":"clnnb2tpy0000soz8djs5abxe","tag_id":"cln60vik10008wvz89egq1d4m","_id":"clnnb2tpz0004soz8039hbk69"}],"Tag":[{"name":"Debug","_id":"cln60vijz0003wvz83hs010u0"},{"name":"LeetCode","_id":"cln60vik10008wvz89egq1d4m"},{"name":"Java","_id":"cln60vik2000dwvz86kondzp1"},{"name":"算法","_id":"cln60vik4000iwvz85am5d09t"},{"name":"代码随想录","_id":"cln60vik5000owvz820bd6i7h"},{"name":"教程","_id":"cln60vik8001uwvz82jld6gtq"},{"name":"Study","_id":"clnaazf5k0002r4wh3xm8393l"},{"name":"Go","_id":"clnaazf5k0003r4wh62knftzl"}]}}