<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代码随想录算法训练营第十三天 144.二叉树的前序遍历、145.二叉树的后序遍历、94.二叉树的中序遍历</title>
    <link href="/post/5d0ef500.html"/>
    <url>/post/5d0ef500.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第十三天-144-二叉树的前序遍历、145-二叉树的后序遍历、94-二叉树的中序遍历"><a href="#代码随想录算法训练营第十三天-144-二叉树的前序遍历、145-二叉树的后序遍历、94-二叉树的中序遍历" class="headerlink" title="代码随想录算法训练营第十三天 144.二叉树的前序遍历、145.二叉树的后序遍历、94.二叉树的中序遍历"></a>代码随想录算法训练营第十三天 144.二叉树的前序遍历、145.二叉树的后序遍历、94.二叉树的中序遍历</h1><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><blockquote><p>  题目链接：</p><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></li></ul><p>  文章讲解：<a href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1Wh411S7xt">每次写递归都要靠直觉？ 这次带你学透二叉树的递归遍历！</a></p><p>  状态：AC</p></blockquote><h3 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h3><p>递归还是比较简单的，直接按照遍历规则写递归代码即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 递归前序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> result []<span class="hljs-type">int</span><br>getResultPreorder(root, &amp;result)<br><span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getResultPreorder</span><span class="hljs-params">(root *TreeNode, result *[]<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>*result = <span class="hljs-built_in">append</span>(*result, root.Val)<br>getResultPreorder(root.Left, result)<br>getResultPreorder(root.Right, result)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 递归后序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> result []<span class="hljs-type">int</span><br>getResultPostorder(root, &amp;result)<br><span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getResultPostorder</span><span class="hljs-params">(root *TreeNode, result *[]<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>getResultPostorder(root.Left, result)<br>getResultPostorder(root.Right, result)<br>*result = <span class="hljs-built_in">append</span>(*result, root.Val)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 递归中序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> result []<span class="hljs-type">int</span><br>getResultInorder(root, &amp;result)<br><span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getResultInorder</span><span class="hljs-params">(root *TreeNode, result *[]<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>getResultInorder(root.Left, result)<br>*result = <span class="hljs-built_in">append</span>(*result, root.Val)<br>getResultInorder(root.Right, result)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非递归思路"><a href="#非递归思路" class="headerlink" title="非递归思路"></a>非递归思路</h3><p>非递归需要借助栈来实现，每次存放树的左右节点（若存在），并判断根节点应该在什么时候存入结果数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 非递归前序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>stack := arraystack.New()<br>result := []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> result<br>&#125;<br>stack.Push(root)<br><span class="hljs-keyword">for</span> !stack.Empty() &#123;<br>value, _ := stack.Pop()<br>result = <span class="hljs-built_in">append</span>(result, value.(*TreeNode).Val)<br><span class="hljs-keyword">if</span> value.(*TreeNode).Right != <span class="hljs-literal">nil</span> &#123;<br>stack.Push(value.(*TreeNode).Right)<br>&#125;<br><span class="hljs-keyword">if</span> value.(*TreeNode).Left != <span class="hljs-literal">nil</span> &#123;<br>stack.Push(value.(*TreeNode).Left)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 非递归后序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>stack := arraystack.New()<br>result := []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> result<br>&#125;<br>stack.Push(root)<br><span class="hljs-keyword">for</span> !stack.Empty() &#123;<br>value, _ := stack.Pop()<br>result = <span class="hljs-built_in">append</span>(result, value.(*TreeNode).Val)<br><span class="hljs-keyword">if</span> value.(*TreeNode).Left != <span class="hljs-literal">nil</span> &#123;<br>stack.Push(value.(*TreeNode).Left)<br>&#125;<br><span class="hljs-keyword">if</span> value.(*TreeNode).Right != <span class="hljs-literal">nil</span> &#123;<br>stack.Push(value.(*TreeNode).Right)<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(result)/<span class="hljs-number">2</span>; i++ &#123;<br>result[i], result[<span class="hljs-built_in">len</span>(result)<span class="hljs-number">-1</span>-i] = result[<span class="hljs-built_in">len</span>(result)<span class="hljs-number">-1</span>-i], result[i]<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 非递归中序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InorderTraversal1</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>stack := arraystack.New()<br>result := []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> result<br>&#125;<br>p := root<br><span class="hljs-keyword">for</span> !stack.Empty() || p != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &#123;<br>stack.Push(p)<br>p = p.Left<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>node, _ := stack.Pop()<br>p = node.(*TreeNode)<br>result = <span class="hljs-built_in">append</span>(result, p.Val)<br>p = p.Right<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录算法训练营第十二天 239.滑动窗口最大值、347.前K个高频元素。</title>
    <link href="/post/9ab3b9d2.html"/>
    <url>/post/9ab3b9d2.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第十二天-239-滑动窗口最大值、347-前K个高频元素。"><a href="#代码随想录算法训练营第十二天-239-滑动窗口最大值、347-前K个高频元素。" class="headerlink" title="代码随想录算法训练营第十二天 239.滑动窗口最大值、347.前K个高频元素。"></a>代码随想录算法训练营第十二天 239.滑动窗口最大值、347.前K个高频元素。</h1><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/sliding-window-maximum/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1XS4y1p7qj">单调队列正式登场！| LeetCode：239. 滑动窗口最大值</a></p><p>  状态：TLE</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>遍历每个滑动窗口（看作一个队列），升序排序后取最大（复制一段新的数组，在新的里面排序）。时间复杂度为O(n^2log n)。超时</p><h4 id="方法二（卡哥讲解）"><a href="#方法二（卡哥讲解）" class="headerlink" title="方法二（卡哥讲解）"></a>方法二（卡哥讲解）</h4><ol><li>准备一个自定义的双向队列数据结构，让其中的<code>front</code>端保持最大值，并且重构<code>Pop()</code>和<code>Push()</code>操作。</li><li>先将前K的元素<code>Push()</code>入队，但是要进行判断。如果后入队的元素大于之前入队的元素，那么之前的元素<code>PopBack()</code>。可以保持<code>front</code>端一直为最大。</li><li><code>Pop()</code>除了最大值的所有元素</li><li><code>Push()</code>一个新的元素</li><li><code>GetMaxValue()</code>，并且加入到结果切片中</li><li>重复3~5直至<code>nums</code>结尾</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="重构两个函数，新增功能GetMaxValue"><a href="#重构两个函数，新增功能GetMaxValue" class="headerlink" title="重构两个函数，新增功能GetMaxValue()"></a>重构两个函数，新增功能GetMaxValue()</h4><ul><li><code>GetMaxValue()</code>：会保持在队列<code>front</code>的位置，可以使用<code>Front()</code>操作取代。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Deque)</span></span> Front() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> this.queue[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Pop()</code>：出队时，只有一种情况，旧的最大值不在新的滑动窗口内，旧的最大值出队（切片舍去第一个元素）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Deque)</span></span> Pop(value <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> !this.Empty() &amp;&amp; value == this.Front() &#123;<br>this.queue = this.queue[<span class="hljs-number">1</span>:]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Push()</code>：入队时，如果入队的值<code>value</code>大于队列<code>back</code>位置的元素，让该元素<code>PopBack()</code>（切片舍去最后一个元素）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Deque)</span></span> Push(value <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">for</span> !this.Empty() &amp;&amp; value &gt; this.Back() &#123;<br>this.queue = this.queue[:<span class="hljs-built_in">len</span>(this.queue)<span class="hljs-number">-1</span>]<br>&#125;<br>this.queue = <span class="hljs-built_in">append</span>(this.queue, value)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Deque <span class="hljs-keyword">struct</span> &#123;<br>queue []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> *Deque &#123;<br><span class="hljs-keyword">return</span> &amp;Deque&#123;queue: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Deque)</span></span> Front() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> this.queue[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Deque)</span></span> Back() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> this.queue[<span class="hljs-built_in">len</span>(this.queue)<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Deque)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(this.queue) == <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Deque)</span></span> Push(value <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">for</span> !this.Empty() &amp;&amp; value &gt; this.Back() &#123;<br>this.queue = this.queue[:<span class="hljs-built_in">len</span>(this.queue)<span class="hljs-number">-1</span>]<br>&#125;<br>this.queue = <span class="hljs-built_in">append</span>(this.queue, value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Deque)</span></span> Pop(value <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> !this.Empty() &amp;&amp; value == this.Front() &#123;<br>this.queue = this.queue[<span class="hljs-number">1</span>:]<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>deque := Constructor()<br><span class="hljs-keyword">var</span> result []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>deque.Push(nums[i])<br>&#125;<br>result = <span class="hljs-built_in">append</span>(result, deque.Front())<br><span class="hljs-keyword">for</span> i := k; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>deque.Pop(nums[i-k])<br>deque.Push(nums[i])<br>result = <span class="hljs-built_in">append</span>(result, deque.Front())<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="347-前K个高频元素"><a href="#347-前K个高频元素" class="headerlink" title="347. 前K个高频元素"></a>347. 前K个高频元素</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/top-k-frequent-elements/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1Xg41167Lz">优先级队列正式登场！大顶堆、小顶堆该怎么用？| LeetCode：347.前 K 个高频元素</a></p><p>  状态：AC</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>构建键值对&lt;key, value&gt;，<code>key</code>为数字，<code>value</code>为该数字出现的次数。</li><li>生成优先队列，优先级为<code>value</code></li><li>取优先队列的前K个元素</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 优先队列中的条目</span><br><span class="hljs-keyword">type</span> Element <span class="hljs-keyword">struct</span> &#123;<br>Num     <span class="hljs-type">int</span><br>Count   <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-comment">// 比较器函数，根据Count降序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">byPriority</span><span class="hljs-params">(a, b <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">int</span> &#123;<br>priorityA := a.(Element).Count<br>priorityB := b.(Element).Count<br><span class="hljs-keyword">return</span> -utils.IntComparator(priorityA, priorityB) <span class="hljs-comment">// &quot;-&quot; 代表降序</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 构建键值对</span><br>    maps := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>maps[v]++<br>&#125;<br>    <span class="hljs-comment">// 初始化优先队列</span><br>pq := priorityqueue.NewWith(byPriority)<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> maps &#123;<br>pq.Enqueue(Element&#123;<br>Num:     k,<br>Count: v,<br>&#125;)<br>&#125;<br><span class="hljs-keyword">var</span> result []<span class="hljs-type">int</span><br>    <span class="hljs-comment">// 取前k个元素保存到result中</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>value, _ := pq.Dequeue()<br>result = <span class="hljs-built_in">append</span>(result, value.(Element).Num)<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【study】Leetcode中Go语言第三方包</title>
    <link href="/post/2360e101.html"/>
    <url>/post/2360e101.html</url>
    
    <content type="html"><![CDATA[<h1 id="【study】Leetcode中Go语言第三方包"><a href="#【study】Leetcode中Go语言第三方包" class="headerlink" title="【study】Leetcode中Go语言第三方包"></a>【study】Leetcode中Go语言第三方包</h1><p>在刷Leetcode时，发现Go并不像其他语言有原生的栈、队列等等结构。虽然很多操作都可以用<strong>切片</strong>或<strong>数组</strong>代替，但还是想知道如果自己想使用这些数据结构应该怎么办。</p><p><img src="/../images/%E3%80%90study%E3%80%91Leetcode%E4%B8%ADGo%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/Leetcode%E4%B8%AD%E7%9A%84Go.png" alt="Leetcode中的Go"></p><p><img src="/../images/%E3%80%90study%E3%80%91Leetcode%E4%B8%ADGo%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/Leetcode%E6%94%AF%E6%8C%81Go%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93.png" alt="Leetcode支持Go的第三方库"></p><p><a href="https://github.com/emirpasic/gods/tree/v1.18.1">支持的库的连接</a></p><p>包含的数据结构如下</p><ul><li>Containers<ul><li>Lists<ul><li>ArrayList</li><li>SinglyLinkedList</li><li>DoublyLinkedList</li></ul></li><li>Sets<ul><li>HashSet</li><li>TreeSet</li><li>LinkedHashSet</li></ul></li><li>Stacks<ul><li>LinkedListStack</li><li>ArrayStack</li></ul></li><li>Maps<ul><li>HashMap</li><li>TreeMap</li><li>LinkedHashMap</li><li>HashBidiMap</li><li>TreeBidiMap</li></ul></li><li>Trees<ul><li>RedBlackTree</li><li>AVLTree</li><li>BTree</li><li>BinaryHeap</li></ul></li><li>Queues<ul><li>LinkedListQueue</li><li>ArrayQueue</li><li>CircularBuffer</li><li>PriorityQueue</li></ul></li></ul></li><li>Functions<ul><li>Comparator</li><li>Iterator<ul><li>IteratorWithIndex</li><li>IteratorWithKey</li><li>ReverseIteratorWithIndex</li><li>ReverseIteratorWithKey</li></ul></li><li>Enumerable<ul><li>EnumerableWithIndex</li><li>EnumerableWithKey</li></ul></li><li>Serialization<ul><li>JSONSerializer</li><li>JSONDeserializer</li></ul></li><li>Sort</li><li>Container</li></ul></li><li>Appendix</li></ul><p>所有数据结构都依赖<code>Container</code>接口，调用起来也很方便</p><h3 id="以栈举例"><a href="#以栈举例" class="headerlink" title="以栈举例"></a>以栈举例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/emirpasic/gods/stacks/arraystack&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    stack = arraystack.New()  <span class="hljs-comment">// 初始化一个栈</span><br>    stack.Push(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 入栈</span><br>    value, _ := stack.Peek()  <span class="hljs-comment">// 查看站定元素</span><br>    value, _ := stack.Pop()  <span class="hljs-comment">// 出栈</span><br>    size := stack.Size()  <span class="hljs-comment">// 栈的大小</span><br>    isEmpty := stack.Empty()  <span class="hljs-comment">// 是否为空栈</span><br>    stack.Clear()  <span class="hljs-comment">// 清空栈</span><br>&#125;<br></code></pre></td></tr></table></figure><p>更多操作可以看github中的<code>README.md</code>文件或者看源码</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Study</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录算法训练营第十一天 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值。</title>
    <link href="/post/bdbe1e6e.html"/>
    <url>/post/bdbe1e6e.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第十一天-20-有效的括号、1047-删除字符串中的所有相邻重复项、150-逆波兰表达式求值。"><a href="#代码随想录算法训练营第十一天-20-有效的括号、1047-删除字符串中的所有相邻重复项、150-逆波兰表达式求值。" class="headerlink" title="代码随想录算法训练营第十一天 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值。"></a>代码随想录算法训练营第十一天 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值。</h1><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><blockquote><p>题目链接：<a href="https://leetcode.cn/problems/valid-parentheses/">力扣题目链接</a></p><p>文章讲解：<a href="https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html">代码随想录(programmercarl.com)</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1AF411w78g">栈的拿手好戏！| LeetCode：20. 有效的括号</a></p><p>状态：AC</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目保证了输入的字符串只有括号。遇到左括号入栈，遇到右括号出栈，但是要比较出栈的元素和当前的右括号是否匹配，不匹配直接<code>return false</code>。最终判断栈是否为空即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>stack := arraystack.New()<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">switch</span> v &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>:<br>stack.Push(v)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>temp, _ := stack.Pop()<br><span class="hljs-keyword">if</span> temp == <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>:<br>temp, _ := stack.Pop()<br><span class="hljs-keyword">if</span> temp == <span class="hljs-string">&#x27;[&#x27;</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>:<br>temp, _ := stack.Pop()<br><span class="hljs-keyword">if</span> temp == <span class="hljs-string">&#x27;&#123;&#x27;</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> stack.Empty()<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047.删除字符串中的所有相邻重复项"></a>1047.删除字符串中的所有相邻重复项</h2><blockquote><p>题目链接：<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">力扣题目链接</a></p><p>文章讲解：<a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">代码随想录(programmercarl.com)</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV12a411P7mw">栈的好戏还要继续！| LeetCode：1047. 删除字符串中的所有相邻重复项</a></p><p>状态：AC</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>将每个元素与栈顶元素进行比较（前提是栈非空、如果空直接入栈即可），比较相等元素出栈。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br>byteString := []<span class="hljs-type">rune</span>(s)<br>stack := arraystack.New()<br>stack.Push(byteString[<span class="hljs-number">0</span>])<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(byteString); i++ &#123;<br>temp, _ := stack.Peek()<br><span class="hljs-keyword">if</span> temp == byteString[i] &#123;<br>stack.Pop()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>stack.Push(byteString[i])<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> newByte []<span class="hljs-type">rune</span><br>length := stack.Size()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br>temp, _ := stack.Pop()<br>temp1 := temp.(<span class="hljs-type">rune</span>)<br>newByte = <span class="hljs-built_in">append</span>(newByte, temp1)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(newByte)/<span class="hljs-number">2</span>; i++ &#123;<br>newByte[i], newByte[<span class="hljs-built_in">len</span>(newByte)<span class="hljs-number">-1</span>-i] = newByte[<span class="hljs-built_in">len</span>(newByte)<span class="hljs-number">-1</span>-i], newByte[i]<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(newByte)<br>&#125;<br></code></pre></td></tr></table></figure><p>此处用的是一个真正意义上的数据结构的栈，存储的是单个字符，写起来还是很长，看了题解之后发现只用字符数组即可，改正后代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> stack []<span class="hljs-type">rune</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &amp;&amp; stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] == v &#123;<br>stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>stack = <span class="hljs-built_in">append</span>(stack, v)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(stack)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="150-逆波兰表达式"><a href="#150-逆波兰表达式" class="headerlink" title="150.逆波兰表达式"></a>150.逆波兰表达式</h2><blockquote><p>题目链接：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">力扣题目链接</a></p><p>文章讲解：<a href="https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html">代码随想录(programmercarl.com)</a></p><p>视频讲解：栈的最后表演！ | LeetCode：150. 逆波兰表达式求值](<a href="https://www.bilibili.com/video/BV1kd4y1o7on">https://www.bilibili.com/video/BV1kd4y1o7on</a>)</p><p>状态：AC</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>明白题意之后，发现每次到运算符时候需要将前面两个数进行计算，如：<code>[&quot;a&quot;, &quot;b&quot;, &quot;+&quot;]</code>运算结果是<code>a+b</code>。不难想到要使用栈。</p><p>先将字符串数组转换为数字，可以成功转换则入栈，否则出栈两个元素，并且将两个元素相加之后再重新入栈。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EvalRPN</span><span class="hljs-params">(tokens []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>stack := arraystack.New()<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> tokens &#123;<br>num, err := strconv.Atoi(v)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// 如果成功转换数字</span><br>stack.Push(num)<br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 否则计算后重新入栈</span><br>b, _ := stack.Pop()<br>a, _ := stack.Pop()<br><span class="hljs-keyword">if</span> v == <span class="hljs-string">&quot;+&quot;</span> &#123;<br>stack.Push(a.(<span class="hljs-type">int</span>) + b.(<span class="hljs-type">int</span>))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v == <span class="hljs-string">&quot;-&quot;</span> &#123;<br>stack.Push(a.(<span class="hljs-type">int</span>) - b.(<span class="hljs-type">int</span>))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v == <span class="hljs-string">&quot;*&quot;</span> &#123;<br>stack.Push(a.(<span class="hljs-type">int</span>) * b.(<span class="hljs-type">int</span>))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v == <span class="hljs-string">&quot;/&quot;</span> &#123;<br>stack.Push(a.(<span class="hljs-type">int</span>) / b.(<span class="hljs-type">int</span>))<br>&#125;<br>&#125;<br>&#125;<br>result, _ := stack.Peek()  <span class="hljs-comment">// 此刻的栈顶为结果</span><br><span class="hljs-keyword">return</span> result.(<span class="hljs-type">int</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录算法训练营第十天 232.用栈实现队列、225. 用队列实现栈。</title>
    <link href="/post/a8d0ca77.html"/>
    <url>/post/a8d0ca77.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第十天-232-用栈实现队列、225-用队列实现栈。"><a href="#代码随想录算法训练营第十天-232-用栈实现队列、225-用队列实现栈。" class="headerlink" title="代码随想录算法训练营第十天 232.用栈实现队列、225. 用队列实现栈。"></a>代码随想录算法训练营第十天 232.用栈实现队列、225. 用队列实现栈。</h1><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h2><blockquote><p>题目链接：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">力扣题目链接</a></p><p>文章讲解：<a href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html">代码随想录(programmercarl.com)</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1nY4y1w7VC">栈的基本操作！ | LeetCode：232.用栈实现队列</a></p><p>状态：AC</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>初始化两个栈，一个作为主栈<code>Stack1</code>、一个作为副栈<code>Stack2</code></li><li>主栈存放数据、副栈临时放数据</li><li><code>Push</code>操作：将数据放入<code>Stack1</code>中</li><li><code>Pop</code>操作：<ul><li>将<code>Stack1</code>中所有元素退栈，并入栈<code>Stack2</code>。</li><li>将<code>Stack2</code>的栈顶元素出栈</li><li>将<code>Stack2</code>中所有元素退栈，并入栈<code>Stack1</code>。</li></ul></li><li><code>Peek</code>操作：<ul><li>将<code>Stack1</code>中所有元素退栈，并入栈<code>Stack2</code>。</li><li>取<code>Stack2</code>的栈顶元素</li><li>将<code>Stack2</code>中所有元素退栈，并入栈<code>Stack1</code>。</li></ul></li><li><code>Empty</code>操作：<ul><li>查看<code>Stack1</code>是否为空即可</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyQueue <span class="hljs-keyword">struct</span> &#123;<br>Stack1 arraystack.Stack<br>Stack2 arraystack.Stack<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyQueue &#123;<br><span class="hljs-keyword">return</span> MyQueue&#123;<br>Stack1: *arraystack.New(),<br>Stack2: *arraystack.New(),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>this.Stack1.Push(x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> !this.Stack1.Empty() &#123;<br><span class="hljs-keyword">if</span> v, ok := this.Stack1.Pop(); ok &#123;<br>this.Stack2.Push(v)<br>&#125;<br>&#125;<br>value, _ := this.Stack2.Pop()<br><span class="hljs-keyword">for</span> !this.Stack2.Empty() &#123;<br><span class="hljs-keyword">if</span> v, ok := this.Stack2.Pop(); ok &#123;<br>this.Stack1.Push(v)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> value.(<span class="hljs-type">int</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Peek() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> !this.Stack1.Empty() &#123;<br><span class="hljs-keyword">if</span> v, ok := this.Stack1.Pop(); ok &#123;<br>this.Stack2.Push(v)<br>&#125;<br>&#125;<br>value, _ := this.Stack2.Peek()<br><span class="hljs-keyword">for</span> !this.Stack2.Empty() &#123;<br><span class="hljs-keyword">if</span> v, ok := this.Stack2.Pop(); ok &#123;<br>this.Stack1.Push(v)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> value.(<span class="hljs-type">int</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> this.Stack1.Empty()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h2><blockquote><p>题目链接：<a href="https://leetcode.cn/problems/implement-stack-using-queues/">力扣题目链接</a></p><p>文章讲解：<a href="https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html">代码随想录(programmercarl.com)</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1Fd4y1K7sm">队列的基本操作！ | LeetCode：225. 用队列实现栈</a></p><p>状态：AC</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>初始化一个队列<code>Queue1</code></li><li>主栈存放数据、副栈临时放数据</li><li><code>Push</code>操作：将数据入队<code>Queue1</code></li><li><code>Pop</code>操作：<ul><li>将<code>Queue1</code>前<code>n-1</code>个元素出队，随后入队在队尾</li><li>最后一个元素出队，返回</li></ul></li><li><code>Top</code>操作：<ul><li>将<code>Queue</code>每个出队，随后入队在队尾</li><li>如果是最后一个元素出队，保存该值，并入队</li><li>返回那个值</li></ul></li><li><code>Empty</code>操作：<ul><li>查看<code>Queue1</code>是否为空即可</li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>Queue1 arrayqueue.Queue<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyStack &#123;<br><span class="hljs-keyword">return</span> MyStack&#123;<br>Queue1: *arrayqueue.New(),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>this.Queue1.Enqueue(x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; this.Queue1.Size()<span class="hljs-number">-1</span>; i++ &#123;<br>v, _ := this.Queue1.Dequeue()<br>value := v.(<span class="hljs-type">int</span>)<br>this.Queue1.Enqueue(value)<br>&#125;<br>v, _ := this.Queue1.Dequeue()<br>value := v.(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">return</span> value<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>top := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; this.Queue1.Size(); i++ &#123;<br>v, _ := this.Queue1.Dequeue()<br>value := v.(<span class="hljs-type">int</span>)<br>this.Queue1.Enqueue(value)<br><span class="hljs-keyword">if</span> i == this.Queue1.Size()<span class="hljs-number">-1</span> &#123;<br>top = value<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> this.Queue1.Empty()<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(x);</span><br><span class="hljs-comment"> * param_2 := obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.Empty();</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录算法训练营第九天 28. 实现 strStr()。459.重复的子字符串</title>
    <link href="/post/369230e4.html"/>
    <url>/post/369230e4.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第九天-28-实现-strStr-。459-重复的子字符串"><a href="#代码随想录算法训练营第九天-28-实现-strStr-。459-重复的子字符串" class="headerlink" title="代码随想录算法训练营第九天 28. 实现 strStr()。459.重复的子字符串"></a>代码随想录算法训练营第九天 28. 实现 strStr()。459.重复的子字符串</h1><h2 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：</p><ul><li><a href="https://www.bilibili.com/video/BV1PD4y1o7nd/">帮你把KMP算法学个通透！B站（理论篇）</a></li><li><a href="https://www.bilibili.com/video/BV1M5411j7Xx">帮你把KMP算法学个通透！（求next数组代码篇）</a></li></ul><p>  状态：看过视频之后AC</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>具体KMP算法原理看卡哥的视频，讲的很好。</p><h4 id="KMP中匹配的过程"><a href="#KMP中匹配的过程" class="headerlink" title="KMP中匹配的过程"></a>KMP中匹配的过程</h4><p>KMP算法，匹配过程放入到一个小视频当中，每个画面持续3秒。好多视频讲解都是“移动模式串”来讲，自己写代码时候有点蒙，所以自己做了个小动图，不使用“移动”来呈现。</p><div style="position: relative; width: 100%; height: 100%;padding-bottom: 100%;"><iframe src="../images/day09/匹配.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h4 id="Next数组构建过程"><a href="#Next数组构建过程" class="headerlink" title="Next数组构建过程"></a>Next数组构建过程</h4><div style="position: relative; width: 100%; height: 0;padding-bottom: 100%;"><iframe src="../images/day09/next数组构建.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h4 id="Next数组说明"><a href="#Next数组说明" class="headerlink" title="Next数组说明"></a>Next数组说明</h4><p>Next数组中，每个元素表示：</p><ul><li>截止到目前为止，最长相等前后缀的长度；</li><li>截止到目前为止，最长前缀的后一位。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getNext</span><span class="hljs-params">(next []<span class="hljs-type">int</span>, s <span class="hljs-type">string</span>)</span></span> &#123;<br>j := <span class="hljs-number">0</span><br>next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br><span class="hljs-keyword">for</span> s[i] != s[j] &amp;&amp; j &gt; <span class="hljs-number">0</span> &#123;<br>j = next[j<span class="hljs-number">-1</span>]<br>&#125;<br><span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>j++<br>&#125;<br>next[i] = j<br><span class="hljs-comment">//fmt.Printf(&quot;第%v次循环后的next数组结果为:%v\n&quot;, i, next)</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strStr</span><span class="hljs-params">(haystack <span class="hljs-type">string</span>, needle <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(needle) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>next := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(needle))<br>getNext(next, needle)<br>j := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> haystack &#123;<br><span class="hljs-keyword">for</span> j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j] &#123;<br>j = next[j<span class="hljs-number">-1</span>]<br>&#125;<br><span class="hljs-keyword">if</span> haystack[i] == needle[j] &#123;<br>j++<br>&#125;<br><span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(needle) &#123;<br><span class="hljs-keyword">return</span> i - <span class="hljs-built_in">len</span>(needle) + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="459-重复的字符串"><a href="#459-重复的字符串" class="headerlink" title="459. 重复的字符串"></a>459. 重复的字符串</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/repeated-substring-pattern/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1cg41127fw">字符串这么玩，可有点难度！ | LeetCode：459.重复的子字符串</a></p><p>  状态：AC</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如果不使用KMP算法还是比较简单的，有很多东西语言已经帮我们实现好了。看了卡哥的讲解感叹这个思路。</p><p>构建一个新字符串<code>newString</code>为两个旧串<code>s</code>的拼接，但是要掐头去尾一个元素。如果<code>newString</code>仍然包含<code>s</code>，说明存在子串构成原字符串。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>newString := s + s<br>newString = newString[<span class="hljs-number">1</span> : <span class="hljs-built_in">len</span>(newString)<span class="hljs-number">-2</span>]<br><span class="hljs-keyword">return</span> strings.Contains(newString, s)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录算法训练营第八天 344. 反转字符串、541. 反转字符串II、剑指Offer 05.替换空格、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串。</title>
    <link href="/post/6416b651.html"/>
    <url>/post/6416b651.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第八天-344-反转字符串、541-反转字符串II、剑指Offer-05-替换空格、151-翻转字符串里的单词、剑指Offer58-II-左旋转字符串。"><a href="#代码随想录算法训练营第八天-344-反转字符串、541-反转字符串II、剑指Offer-05-替换空格、151-翻转字符串里的单词、剑指Offer58-II-左旋转字符串。" class="headerlink" title="代码随想录算法训练营第八天| 344. 反转字符串、541. 反转字符串II、剑指Offer 05.替换空格、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串。"></a>代码随想录算法训练营第八天| 344. 反转字符串、541. 反转字符串II、剑指Offer 05.替换空格、151.翻转字符串里的单词、剑指Offer58-II.左旋转字符串。</h1><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1fV4y17748">字符串基础操作！ | LeetCode：344.反转字符串</a></p><p>  状态：AC</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="/../images/day08/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="截屏2023-09-28 14.28.20"></p><p>相同颜色的互换位置即可，即<code>i</code>与<code>len(s) - 1 - i</code>交换。<code>i</code>的范围到<code>len(s)/2</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s)/<span class="hljs-number">2</span>; i++ &#123;<br>temp := s[i]<br>s[i] = s[<span class="hljs-built_in">len</span>(s)-i<span class="hljs-number">-1</span>]<br>s[<span class="hljs-built_in">len</span>(s)-i<span class="hljs-number">-1</span>] = temp<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h2><blockquote><p>  题目链接：<a href="%5B%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%5D(https://leetcode.cn/problems/reverse-string-ii/)">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1dT411j7NN">字符串操作进阶！ | LeetCode：541. 反转字符串II</a></p><p>  状态：AC</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><img src="/../images/day08/%E5%8F%8D%E8%BD%AC2(1).png" alt="反转2(1)"></p><ol><li>如图，图中相同颜色的部分代表一个<code>2k</code>段，循环条件：<code>for i := 0; i &lt; len(s); i += 2 * k</code>。</li><li>相同颜色下，分为两段，前<code>k</code>段和后<code>k</code>段。前<code>k</code>段进行反转，后<code>k</code>段直接拼接。如果某一段到达了字符串<code>s</code>尾部，需要停止。</li><li>由于Go语言的字符串不可变，所以新建一个变量，一点点“组装”成最终结果。前<code>k</code>段翻转直接进行反向遍历。</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseStr</span><span class="hljs-params">(s <span class="hljs-type">string</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>newString := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i += <span class="hljs-number">2</span> * k &#123;<br><span class="hljs-keyword">for</span> j := min(<span class="hljs-built_in">len</span>(s), i+k) - <span class="hljs-number">1</span>; j &gt;= i; j-- &#123; <span class="hljs-comment">// 前k段</span><br>newString += <span class="hljs-type">string</span>(s[j])<br>&#125;<br><span class="hljs-keyword">for</span> j := i + k; j &lt; min(<span class="hljs-built_in">len</span>(s), i+<span class="hljs-number">2</span>*k); j++ &#123;  <span class="hljs-comment">// 后k段</span><br>newString += <span class="hljs-type">string</span>(s[j])<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> newString<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer-05-替换空格、LCR22-路径加密"><a href="#剑指Offer-05-替换空格、LCR22-路径加密" class="headerlink" title="剑指Offer 05.替换空格、LCR22.路径加密"></a>剑指Offer 05.替换空格、LCR22.路径加密</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html">代码随想录(programmercarl.com)</a></p><p>  状态：AC</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>直接投机取巧，新建一个字符串<code>newString</code>，遍历字符串<code>s</code>，如果<code>s[i] == &#39;.&#39;</code>，在<code>newString += &#39; &#39;</code>，否则<code>newString += s[i]</code></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathEncryption</span><span class="hljs-params">(path <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>newString := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> _, v:= <span class="hljs-keyword">range</span> path&#123;<br><span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>newString += <span class="hljs-string">&quot; &quot;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>newString += <span class="hljs-type">string</span>(v)<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> newString<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">代码随想录(programmercarl.com)</a></p><p>  视频链接：<a href="https://www.bilibili.com/video/BV1uT41177fX">字符串复杂操作拿捏了！ | LeetCode:151.翻转字符串里的单词</a></p><p>  状态：AC</p></blockquote><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>使用双指针，<code>left</code>指针指向的是单词的起始位置，遍历字符串用的<code>i</code>找到单词末尾。</li><li>新建一个字符串数组<code>words</code>，将每个单词加入到其中</li><li>定义新字符串<code>newString</code>，将<code>words</code>中每个单词拼接到<code>newString</code>中（反向遍历<code>words</code>），并且如果不是最后一个单词则再加一个空格。</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>words := []<span class="hljs-type">string</span>&#123;&#125;<br>left := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br><span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27; &#x27;</span> &#123;<br><span class="hljs-keyword">if</span> s[left:i] != <span class="hljs-string">&quot;&quot;</span> &#123;<br>words = <span class="hljs-built_in">append</span>(words, s[left:i])<br>&#125;<br>left = i + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span> &#123;<br>words = <span class="hljs-built_in">append</span>(words, s[left:])<br>&#125;<br>&#125;<br>newString := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(words) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>newString += words[i]<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>newString += <span class="hljs-string">&quot; &quot;</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> newString<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Offer58-II-左旋转字符串"><a href="#Offer58-II-左旋转字符串" class="headerlink" title="Offer58-II.左旋转字符串"></a>Offer58-II.左旋转字符串</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">代码随想录(programmercarl.com)</a></p><p>  状态：AC</p></blockquote><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>直接拼接</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><img src="/../images/day08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%BB%E4%BD%8D.png" alt="字符串移位"></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dynamicPassword</span><span class="hljs-params">(password <span class="hljs-type">string</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> password[target:] + password[:target]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法二</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(chars []<span class="hljs-type">byte</span>, left, right <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        temp := chars[left]<br>        chars[left] = chars[right]<br>        chars[right] = temp<br>        left++<br>        right--<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dynamicPassword</span><span class="hljs-params">(password <span class="hljs-type">string</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    chars := []<span class="hljs-type">byte</span>(s)<br>    reverse(chars, <span class="hljs-number">0</span>, target - <span class="hljs-number">1</span>)<br>    reverse(chars, target, <span class="hljs-built_in">len</span>(chars) - <span class="hljs-number">1</span>)<br>    reverse(chars, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(chars) - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(chars)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录算法训练营第七天| 454.四数相加II、383. 赎金信、15. 三数之和、18. 四数之和。</title>
    <link href="/post/bc862a56.html"/>
    <url>/post/bc862a56.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第七天-454-四数相加II、383-赎金信、15-三数之和、18-四数之和。"><a href="#代码随想录算法训练营第七天-454-四数相加II、383-赎金信、15-三数之和、18-四数之和。" class="headerlink" title="代码随想录算法训练营第七天| 454.四数相加II、383. 赎金信、15. 三数之和、18. 四数之和。"></a>代码随想录算法训练营第七天| 454.四数相加II、383. 赎金信、15. 三数之和、18. 四数之和。</h1><h2 id="454-两数相加"><a href="#454-两数相加" class="headerlink" title="454. 两数相加"></a>454. 两数相加</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/4sum-ii/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1Md4y1Q7Yh">学透哈希表，map使用有技巧！LeetCode：454.四数相加II</a></p><p>  状态：TLE</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="思路一：暴力算法"><a href="#思路一：暴力算法" class="headerlink" title="思路一：暴力算法"></a>思路一：暴力算法</h4><p>暴力算法就不用解释了，每个元素都遍历下。定义<code>count</code>记录满足条件情况的个数。满足条件<code>count++</code>就好。不出意外的也肯定会超时。</p><h4 id="思路二：使用map"><a href="#思路二：使用map" class="headerlink" title="思路二：使用map"></a>思路二：使用map</h4><p>将<code>num4</code>的值存入到<code>map4</code>中的<code>key</code>，值出现的次数存为<code>value</code>。三层循环后接一个判断，判断第四个数是否在<code>map4</code>中，如果存在则总数加<code>value</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>, nums3 []<span class="hljs-type">int</span>, nums4 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>count := <span class="hljs-number">0</span><br>map4 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums4 &#123;<br>map4[v]++<br>&#125;<br><span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> nums1 &#123;<br><span class="hljs-keyword">for</span> _, j := <span class="hljs-keyword">range</span> nums2 &#123;<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> nums3 &#123;<br><span class="hljs-keyword">if</span> v, ok := map4[<span class="hljs-number">0</span>-i-j-k]; ok &#123;<br>count += v<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure><p>结果你猜超时没有，肯定还是超时了。</p><h4 id="思路三：使用四个map"><a href="#思路三：使用四个map" class="headerlink" title="思路三：使用四个map"></a>思路三：使用四个map</h4><p>每个map中都存放<code>nums</code>中出现的数以及出现的次数。第一个map定义为<code>map1</code>，键是<code>k1</code>，值是<code>v1</code>，以此类推。</p><p>三层循环后判断<code>map4[0-k1-k2-k3]</code>是否存在，如果存在那么<code>count += v1 * v2 * v3 * v4</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go">count := <span class="hljs-number">0</span><br>map1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>map2 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>map3 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>map4 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums1); i++ &#123;<br>    map1[nums1[i]]++<br>    map2[nums2[i]]++<br>    map3[nums3[i]]++<br>    map4[nums4[i]]++<br>&#125;<br><span class="hljs-keyword">for</span> k1, v1 := <span class="hljs-keyword">range</span> map1 &#123;<br>    <span class="hljs-keyword">for</span> k2, v2 := <span class="hljs-keyword">range</span> map2 &#123;<br>        <span class="hljs-keyword">for</span> k3, v3 := <span class="hljs-keyword">range</span> map3 &#123;<br>            <span class="hljs-keyword">if</span> v4, ok := map4[<span class="hljs-number">0</span>-k1-k2-k3]; ok &#123;<br>                count += v1 * v2 * v3 * v4<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p>结果你猜超时没有，肯定还是超时了。</p><p>原因如下：如果数组中重复的数不多，或者没有，就会退化成思路二。</p><p>想了许久，想不出优化的方法了，看了卡哥的题解，我就用我的理解描述一下。</p><h4 id="卡哥题解"><a href="#卡哥题解" class="headerlink" title="卡哥题解"></a>卡哥题解</h4><p>先计算<code>nums1</code>与<code>nums2</code>和，将两数组所有和的情况保存到<code>mapAB</code>中。key保存的是和，value保存的是和的个数。</p><p>再计算<code>nums3</code>与<code>nums4</code>和，判断<code>mapAB[0-k3-k4]</code>是否存在，若存在<code>count+=mapAB[0-k3-k4]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>, nums3 []<span class="hljs-type">int</span>, nums4 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>count := <span class="hljs-number">0</span><br>mapAB := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> _, v1 := <span class="hljs-keyword">range</span> nums1 &#123;<br><span class="hljs-keyword">for</span> _, v2 := <span class="hljs-keyword">range</span> nums2 &#123;<br>mapAB[v1+v2]++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> _, v3 := <span class="hljs-keyword">range</span> nums3 &#123;<br><span class="hljs-keyword">for</span> _, v4 := <span class="hljs-keyword">range</span> nums4 &#123;<br><span class="hljs-keyword">if</span> v, ok := mapAB[<span class="hljs-number">0</span>-v3-v4]; ok &#123;<br>count += v<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>要判断<code>ransomNote</code>是否含于<code>magazine</code>，先构建一个数组，存放<code>magazine</code>的情况，索引代表字母：0代表<code>&#39;a&#39;</code>，1代表<code>&#39;b&#39;</code>等等；值代表字母出现的次数。构建好后再遍历<code>ransomNote</code>串，将对应的字母数量减少一，如果不存在直接<code>return false</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(ransomNote <span class="hljs-type">string</span>, magazine <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ransomNote) &gt; <span class="hljs-built_in">len</span>(magazine) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> magazine &#123;<br>arr[v-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> ransomNote &#123;<br>arr[v-<span class="hljs-string">&#x27;a&#x27;</span>]--<br><span class="hljs-keyword">if</span> arr[v-<span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/3sum/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1GW4y127qo">梦破碎的地方！| LeetCode：15.三数之和</a></p><p>  状态：TLE</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我投降了这道题，Go的底层现在有一个新的理解！</p><h4 id="方法一：回溯算法"><a href="#方法一：回溯算法" class="headerlink" title="方法一：回溯算法"></a>方法一：回溯算法</h4><p>首先先将<code>nums</code>排序，利用回溯算法得到所有的组合，选择排序的原因是因为这样得到的组合，即使是重复的也可以保证顺序一致，方便判断这个组合是否出现过。最终结果保存到变量<code>result</code>，得到的可能得组合保存到变量<code>path</code></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, index <span class="hljs-type">int</span>, result *[][]<span class="hljs-type">int</span>, path *[]<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(*path) == <span class="hljs-number">3</span> &#123;<br><span class="hljs-keyword">if</span> (*path)[<span class="hljs-number">0</span>]+(*path)[<span class="hljs-number">1</span>]+(*path)[<span class="hljs-number">2</span>] == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 后面的append()操作是深拷贝，所以这里使用temp保存path的值</span><br>            temp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(*path))  <br><span class="hljs-built_in">copy</span>(temp, *path)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> *result &#123;<br><span class="hljs-keyword">if</span> reflect.DeepEqual(temp, v) &#123;  <span class="hljs-comment">// 使用反射判断temp是否在result中</span><br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>*result = <span class="hljs-built_in">append</span>(*result, temp)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> i := index; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>*path = <span class="hljs-built_in">append</span>(*path, nums[i])<br>backTracking(nums, i+<span class="hljs-number">1</span>, result, path)<br>*path = (*path)[:<span class="hljs-built_in">len</span>(*path)<span class="hljs-number">-1</span>]<br><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> result [][]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br>sort.Ints(nums)<br>backTracking(nums, <span class="hljs-number">0</span>, &amp;result, &amp;path)<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>结果你猜超时没有，肯定还是超时了。</p><p>这里我遇到了好多问题，首先是发现了<code>result = append(result, temp)</code>，这里<code>append</code>方法实际上是浅拷贝！也就是说以后<code>temp</code>的值，<code>result</code>也会变化。这也是我为什么用一个临时变量<code>temp</code>来保存<code>path</code>，而且使用的是<code>copy()</code>。</p><p>要判断<code>temp</code>是否存在于<code>result</code>中，那么则需要使用反射，进行深度判断<code>reflect.DeepEqual(temp, v)</code>。</p><h5 id="遇到最头大的问题！！！！！！"><a href="#遇到最头大的问题！！！！！！" class="headerlink" title="遇到最头大的问题！！！！！！"></a>遇到最头大的问题！！！！！！</h5><p>以前用别的语言写回溯，很自然的使用了全局变量，结果在Go语言中发生了奇妙的事情。请看截图</p><img src="../images/day07/使用全局变量leetcode.png" alt="使用全局变量leetcode" style="zoom:80%;" /><p>明明输入的只有0和1，怎么会输出了2。而且这个测试用例这么眼熟呢，没错这就是给出的测试用例Case1的答案。放到Goland里面明明是正确答案！到这里就变了，说明全局变量出现了问题。解决这个问题有两个想法：</p><ul><li>查找有没有类似C++中的<code>delete</code>，使用完变量之后释放掉。发现并没有。而且使用完变量应该在<code>threeSum()</code>之外了，函数内释放就没有结果了。</li><li><code>threeSum()</code>定义变量，使用指针传值。</li></ul><p>当然，第二种才是正解。改完之后就是上面放出来的代码了，超时。</p><h4 id="方法二：使用哈希"><a href="#方法二：使用哈希" class="headerlink" title="方法二：使用哈希"></a>方法二：使用哈希</h4><p>将<code>nums</code>进行排序，并哈希处理，定义变量<code>map1</code>用作哈希表，<code>nums</code>中的每个元素做key，value则是每个元素出现的次数。</p><p>使用两层for循环之后，判断<code>0-nums[i]-nums[j]</code>是否存在。若存在还需要判断每个数字出现的次数是否合法（例如<code>nums = [-1,0,1,2,-1,-4]</code>，如果找到一个组合是<code>[2, -4, 2]</code>则需要舍弃。之所以会出现这样，是因为两层for会找到<code>2</code>和<code>-4</code>，而<code>0-nums[i]-nums[j]</code>会找到重复的2）</p><p>找到组合之后，对组合再排序，判断<code>path</code>是否在<code>result</code>中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Ints(nums)<br>map1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>map1[v]++<br>&#125;<br><span class="hljs-keyword">var</span> result [][]<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br><span class="hljs-keyword">if</span> v, ok := map1[-nums[i]-nums[j]]; ok &#123;<br>temp := []<span class="hljs-type">int</span>&#123;nums[i], nums[j], -nums[i] - nums[j]&#125;<br>sort.Ints(temp)<br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> nums[i] == nums[j] || nums[j] == -nums[i]-nums[j] || nums[i] == -nums[i]-nums[j] &#123;<br>count = <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">if</span> nums[i] == nums[j] &amp;&amp; nums[j] == -nums[i]-nums[j] &#123;<br>count = <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">if</span> v &gt;= count &#123;<br>flag := <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> result &#123;<br><span class="hljs-keyword">if</span> reflect.DeepEqual(value, temp) &#123;<br>flag = <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> flag &#123;<br>result = <span class="hljs-built_in">append</span>(result, temp)<br>&#125;<br><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>结果你猜超时没有，肯定还是超时了。</p><p>好了，我投降了，想不到好方法了。去看卡哥视频了。</p><h3 id="卡哥解法"><a href="#卡哥解法" class="headerlink" title="卡哥解法"></a>卡哥解法</h3><p><font color="red">这道题不适合用哈希表做</font>。双指针我想了一下也没有太想明白，主要还是去重操作。看了视频讲解很清楚了</p><ol><li><p>数组排序，方便后序操作</p></li><li><p>先找第一个数，使用一层<code>for</code>，指针为<code>i</code></p></li><li><p>找第二个、第三个数。分别用指针<code>left = i + 1</code>，<code>right = len(nums) - 1</code></p></li><li><p>剪枝：如果<code>i&gt;0</code>，那么直接<code>return</code>，说明后续不可能再有等于0的三元组了</p></li><li><p>判断<code>nums[i] + nums[left] + nums[right]</code>和0的情况</p><ul><li><code>nums[i] + nums[left] + nums[right] &gt; 0    right--</code></li><li><code>nums[i] + nums[left] + nums[right] &lt; 0    left++</code></li><li><code>nums[i] + nums[left] + nums[right] == 0</code> <ul><li>这个三元组放入到结果中，但是仍然要相向前进。对于<code>left</code>，如果如果一致前进得到的<code>nums[left]==nums[left+1]</code>，说明该三元组已经存在过了（<code>0, -1, -1, 1 ,1</code>）。<code>right</code>同理，<code>nums[right] == nums[right - 1]</code></li><li>找到各自不同的数<code>nums[left+1]</code>和<code>nums[right-1]</code>，再前进一个（<code>0, -1, -1, -2, 2, 1, 1</code>）</li></ul></li></ul></li><li><p><code>return result</code></p></li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Ints(nums)<br>result := [][]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br><span class="hljs-keyword">if</span> nums[i] &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>left := i + <span class="hljs-number">1</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> left &lt; right &#123;<br><span class="hljs-keyword">if</span> nums[i]+nums[left]+nums[right] &gt; <span class="hljs-number">0</span> &#123;<br>right--<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[i]+nums[left]+nums[right] &lt; <span class="hljs-number">0</span> &#123;<br>left++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>result = <span class="hljs-built_in">append</span>(result, []<span class="hljs-type">int</span>&#123;nums[i], nums[left], nums[right]&#125;)<br><span class="hljs-keyword">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>] &#123;<br>left++<br>&#125;<br><span class="hljs-keyword">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class="hljs-number">-1</span>] &#123;<br>right--<br>&#125;<br>left++<br>right--<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这个代码AC了，但是毫无成就感。现在是9月27日凌晨2:53，还有一道题。继续</p><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/4sum/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1DS4y147US">难在去重和剪枝！| LeetCode：18. 四数之和</a></p><p>  状态：AC</p></blockquote><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法同上题，只不过这次要先确定两个数，然后用<code>left</code>和<code>right</code>指针找第三个第四个数。有几点不同：</p><ul><li>这里不是与0作比较，而是<code>target</code>，不可以<code>nums[i] &gt; target</code>之后就<code>break</code>，因为如果有一堆负数相加一定出现越加越小，使得等于<code>target</code></li><li>数组长度可能小于4，需要额外判断</li><li>剪枝<code>i&gt;0</code>开始，<code>j&gt;i+1</code>开始，<code>j</code>永远在<code>i</code>后一位</li></ul><p>领悟了上一道题，这一题不难了</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fourSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> result [][]<span class="hljs-type">int</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">4</span> &#123;<br><span class="hljs-keyword">return</span> result<br>&#125;<br>sort.Ints(nums)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-3</span>; i++ &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j &gt; i+<span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>left := j + <span class="hljs-number">1</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> left &lt; right &#123;<br><span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[left]+nums[right] &lt; target &#123;<br>left++<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[left]+nums[right] &gt; target &#123;<br>right--<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>result = <span class="hljs-built_in">append</span>(result, []<span class="hljs-type">int</span>&#123;nums[i], nums[j], nums[left], nums[right]&#125;)<br><span class="hljs-keyword">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>] &#123;<br>left++<br>&#125;<br><span class="hljs-keyword">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class="hljs-number">-1</span>] &#123;<br>right--<br>&#125;<br>left++<br>right--<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>Go的底层有了很多认识，是以前做题或者写项目时候意识不到的。尤其是浅拷贝与深拷贝，大概找到规律了，几乎都是浅拷贝，如果想要深拷贝一定要用<code>copy()</code></li><li>由于Go的特性，Go的全局变量不可以在leetcode使用，需要指针传值</li><li>晚安，准备睡觉了，3:20了，一觉起来是新的题，字符串要学KMP算法什么的了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【debug】Java中的map比较</title>
    <link href="/post/ad5be9d7.html"/>
    <url>/post/ad5be9d7.html</url>
    
    <content type="html"><![CDATA[<h1 id="【debug】Java中的map比较"><a href="#【debug】Java中的map比较" class="headerlink" title="【debug】Java中的map比较"></a>【debug】Java中的map比较</h1><p>题目链接：<a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p><p>事情起因：（由于自己对Java了解不深、有表达错误的请指出，感谢！）</p><img src="../images/【debug】Java中的map比较/java_map_debug.jpg" alt="报错截图" style="zoom:100%;" /><p>群友发了一张代码截图，觉得自己写的代码并没有错，但是不能通过测试用例。</p><p>他的算法我简单说一下，有点麻烦，但算法不是这篇博客的重点。</p><ol><li>两个Map：<code>hashS</code>、<code>hashT</code>分别用于存放字符串<code>s</code>和<code>t</code>中字母出现的频率(19行之前)；</li><li>遍历长的字符串对应的Map，假设是<code>hashS</code>，判断<code>hashS</code>与<code>hashT</code>相同的字母频率是否一样，如果不一样则<code>return false</code></li></ol><p>当时我是在外面，看到了这段代码，理解了他的想法之后好像真的没什么问题。</p><h3 id="复现Bug与初步解决"><a href="#复现Bug与初步解决" class="headerlink" title="复现Bug与初步解决"></a>复现Bug与初步解决</h3><p>回来之后代码放到idea里面跑了一下，发现这个测试用例长度为50000位，而且每个字母出现的频率是一样的</p><img src="../images/【debug】Java中的map比较/hashST.png" alt="两个Map的内容" style="zoom:67%;" /><p>打上断点继续向下走，看看是哪一步出现了问题。</p><img src="../images/【debug】Java中的map比较/断点调试.png" alt="断点调试" style="zoom:67%;" /><p>没想到第一次循环就出错了，<code>hashT.get(c)</code>与<code>hashS.get(c)</code>的值都是1913，但是地址不一样，一个是<code>&#123;Integer@531&#125;</code>，一个是<code>&#123;Integer@587&#125;</code>。看来这里的<code>!=</code>判断的是地址而不是值，使用<code>equal()</code>方法即可，如下：</p><img src="../images/【debug】Java中的map比较/初步解决.png" alt="初步解决" style="zoom:67%;" /><h3 id="深层探索"><a href="#深层探索" class="headerlink" title="深层探索"></a>深层探索</h3><p>事情并没有真正的解决，既然群友能通过一些测试用例，说明了一些情况使用<code>!=</code>是可以用的，那几个测试用例都是用了很短的字符串，我也看下是什么情况，<code>s=&quot;anagram&quot;</code>，<code>t=&quot;nagaram&quot;</code>，这是个正确的用例，debug的结果是这样</p><img src="../images/【debug】Java中的map比较/短测试用例.png" alt="短测试用例" style="zoom:80%;" /><p>这可就是玄学了呀，短的数据不会出现问题，而长的会出现。</p><h4 id="猜想一：与Map的大小有关"><a href="#猜想一：与Map的大小有关" class="headerlink" title="猜想一：与Map的大小有关"></a>猜想一：与Map的大小有关</h4><p>因为长的测试用例有26个键值对（每个字母均出现），而短的只出现了5个字母。我设置测试用例<code>s = t = &quot;abcdefghijklmnopqrstuvwxyz&quot;</code>（以下简称字母表），让每个字母都出现一次。</p><img src="../images/【debug】Java中的map比较/26字母.png" alt="26字母" style="zoom:80%;" /><p>还是正常的，<font color="#ff0000">猜想错误</font></p><h4 id="猜想二：与测试用例的长度有关"><a href="#猜想二：与测试用例的长度有关" class="headerlink" title="猜想二：与测试用例的长度有关"></a>猜想二：与测试用例的长度有关</h4><p>接着我就多复制些字母表，出错误的是在50000的长度，我把字母表长度先放到3000多，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 扩增字符串代码代码</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br>    s += s;<br>    t += t;<br>&#125;<br></code></pre></td></tr></table></figure><img src="../images/【debug】Java中的map比较/3000多长度.png" alt="长度为3328" style="zoom:80%;" /><p>还是有错误，继续缩短长度，将扩增代码循环6次，减少一次再看看</p><img src="../images/【debug】Java中的map比较/6次扩增.png" alt="6次扩增" style="zoom:80%;" /><p>这次竟然又不出错了，玄学！妥妥的玄学！</p><p>我换了种思路，这次不用字母表了，只是用一个变量看看会不会触发这个BUG，如果依然触发，每次长度增加1，那么很快就会得到到底在多长的时候会出现。25行打上断点，被执行前一定会卡住。</p><img src="../images/【debug】Java中的map比较/展示代码.png" alt="展示代码" style="zoom:80%;" /><img src="../images/【debug】Java中的map比较/128卡住.png" alt="字母a出现了128次时候开始报错" style="zoom:80%;" /><p>最后做一次验证，是不是Map中，只要有val超过128就会发生地址改变的情况。这次的测试用例使用随机字母</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">26</span>) + <span class="hljs-number">97</span>;<br>    s += (<span class="hljs-type">char</span>)temp;<br>    t += (<span class="hljs-type">char</span>)temp;<br>    System.out.println(isAnagram(s, t));<br>&#125;<br></code></pre></td></tr></table></figure><img src="../images/【debug】Java中的map比较/26随机字母报错.png" alt="字母a出现了128次的时候开始报错" style="zoom:80%"/><p>很好！当字母w出现了超过128次时候地址发生了变化。128这个数字相信大家一定很敏感，那么这个范围很可能是[-128, 127]。那么则需要看看底层源码是怎么说的，去看看<code>Map.java</code>，搜索<code>127</code>，并没有发现相关说明。</p><img src="../images/【debug】Java中的map比较/map源码.png" alt="map源码" style="zoom:80%;" /><p><code>&#123;Integer@***&#125;</code>这里面经常变得数字就是星号部分，那么去<code>Ieteger.java</code>里面看看有什么发现。</p><img src="../images/【debug】Java中的map比较/第一个127.png" alt="搜索结果1" style="zoom:80%;" /><img src="../images/【debug】Java中的map比较/最后一个127.png" alt="搜索结果2" style="zoom:80%;" /><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>结合这两段我悟了，果然有这么个范围，在初始化值的时候，[-128, 127]这个范围的数是在缓存里面，所以当<code>Map</code>中的<code>value</code>小于128时候读取的是缓存中的数，所以他们地址是一样的，也就是<code>hashS.get(c)==hashT.get(c)</code>的原因。当超过这个范围，则会在新的地方存放一个值，尽管<code>hashS.get(c)</code>和<code>hashT.get(c)</code>均为128，但是使用<code>==</code>或<code>!=</code>判断的时候，判断的是<strong>地址</strong>，得到<code>hashS.get(c)!=hashT.get(c)</code>。</p><h4 id="所以一定要写equal-方法进行判断"><a href="#所以一定要写equal-方法进行判断" class="headerlink" title="所以一定要写equal()方法进行判断"></a>所以一定要写equal()方法进行判断</h4><h4 id="所以一定要写equal-方法进行判断-1"><a href="#所以一定要写equal-方法进行判断-1" class="headerlink" title="所以一定要写equal()方法进行判断"></a>所以一定要写equal()方法进行判断</h4><h4 id="所以一定要写equal-方法进行判断-2"><a href="#所以一定要写equal-方法进行判断-2" class="headerlink" title="所以一定要写equal()方法进行判断"></a>所以一定要写equal()方法进行判断</h4><p><code>hashS.get(c).equal(hashT.get(c))</code>，这样判断的才是值而不是地址</p>]]></content>
    
    
    <categories>
      
      <category>Debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Debug</tag>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录算法训练营第六天| 242.有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和 。</title>
    <link href="/post/20198d61.html"/>
    <url>/post/20198d61.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第六天-242-有效的字母异位词、349-两个数组的交集、202-快乐数、1-两数之和-。"><a href="#代码随想录算法训练营第六天-242-有效的字母异位词、349-两个数组的交集、202-快乐数、1-两数之和-。" class="headerlink" title="代码随想录算法训练营第六天| 242.有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和 。"></a>代码随想录算法训练营第六天| 242.有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和 。</h1><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/valid-anagram/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1YG411p7BA">学透哈希表，数组使用有技巧！Leetcode：242.有效的字母异位词</a></p><p>  状态：AC</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>方法一：使用<code>map</code>即可。键是字母的<code>ASCII</code>码、值为频率。分别用两个串构建两个<code>map</code>，再比较两个<code>map</code>是否相同。</p></li><li><p>方法二：看了卡哥给的代码发现优化空间还是很大的，使用一个<code>map</code>即可，存放<code>s</code>的情况。异位词满足两个条件：</p><ul><li>两个串等长。</li><li>两个串中字母出现的频率相同。这一点可以用<code>s</code>串的<code>map</code>的<code>value</code>自减。</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//麻烦的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>words1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>&#123;&#125;<br>words2 := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>_, ok := words1[s[i]]<br><span class="hljs-keyword">if</span> ok &#123;<br>words1[s[i]] += <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>words1[s[i]] = <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(t); i++ &#123;<br>_, ok := words2[t[i]]<br><span class="hljs-keyword">if</span> ok &#123;<br>words2[t[i]] += <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>words2[t[i]] = <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> reflect.DeepEqual(words1, words2)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 简单的代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(s, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) != <span class="hljs-built_in">len</span>(t) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>cnt := <span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> s &#123;<br>cnt[ch]++<br>&#125;<br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> t &#123;<br>cnt[ch]--<br><span class="hljs-keyword">if</span> cnt[ch] &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/intersection-of-two-arrays/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1ba411S7wu">学透哈希表，set使用有技巧！Leetcode：349. 两个数组的交集</a></p><p>  状态：AC</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>从求交集可以看出是要使用集合的结构，但是在Go语言中<font color="#ff0000">并没有</font>集合，所以我使用了<code>map</code>（并不是用map模拟set）。map中，键为<code>nums1</code>的每个元素，值只有三种状态：第一次出现是<code>0</code>，多次出现是<code>1</code>，在<code>nums2</code>也出现过是<code>2</code>，最后遍历map，找到值为2的key。</p><p>利用const和iota模拟枚举类型。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>NEW = <span class="hljs-literal">iota</span><br>EXIST1<br>EXIST2<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intersection</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>set := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;  <span class="hljs-comment">//类集合操作</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums1 &#123;<br><span class="hljs-keyword">if</span> _, ok := set[v]; !ok &#123;<br>set[v] = NEW  <span class="hljs-comment">// 第一个出现</span><br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 多次出现</span><br>set[v] = EXIST1<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums2 &#123;<br><span class="hljs-keyword">if</span> _, ok := set[v]; ok &#123;  <span class="hljs-comment">// nums2也出现</span><br>set[v] = EXIST2<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> result []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> set &#123;<br><span class="hljs-keyword">if</span> v == EXIST2 &#123;<br>result = <span class="hljs-built_in">append</span>(result, k)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/happy-number/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录(programmercarl.com)</a></p><p>  状态：AC</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>构造一个集合，用于存放每一次拆数求平方和的结果</li><li>拆数</li><li>判断结果是否是1，如果是<code>return true</code></li><li>如果不是1，判断结果是否在集合中，如果存在则说明出现了循环，<code>return false</code></li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>set := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;  <span class="hljs-comment">// 模拟集合</span><br><span class="hljs-keyword">for</span> &#123;<br>sum := <span class="hljs-number">0</span><br>        <span class="hljs-comment">//拆数求平方和</span><br><span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">0</span> &#123;<br>sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>)<br>n /= <span class="hljs-number">10</span><br>&#125;<br>        <span class="hljs-comment">//得到正确答案</span><br><span class="hljs-keyword">if</span> sum == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>        <br>        <span class="hljs-comment">//结果不在集合中则放入集合</span><br><span class="hljs-keyword">if</span> _, ok := set[sum]; !ok &#123;<br>set[sum] = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 否则退出循环 return false</span><br><span class="hljs-keyword">break</span><br>&#125;<br>n = sum <span class="hljs-comment">// 新一轮的数</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/two-sum/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1aT41177mK">梦开始的地方，Leetcode：1.两数之和</a></p><p>  状态：AC</p></blockquote><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>遍历<code>nums</code>将元素存为<code>map</code>的<code>key</code>，将元素的索引存放为<code>map</code>的<code>value</code>；</li><li>再遍历<code>nums</code>，查看<code>target - v</code>是否在<code>key</code>中，并返回两个值：<code>nums</code>元素的索引和<code>map[target-v]</code></li></ol><p>遍历两次还是思路上走弯路了，一次即可。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//遍历两次</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    mapNums := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>       mapNums[v] = i<br>    &#125;<br>    <span class="hljs-keyword">var</span> result []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>       <span class="hljs-keyword">if</span> _, ok := mapNums[target-v]; ok &amp;&amp; mapNums[target-v] != i &#123;<br>          result = <span class="hljs-built_in">append</span>(result, i)<br>          result = <span class="hljs-built_in">append</span>(result, mapNums[target-v])<br>          <span class="hljs-keyword">break</span><br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>mapNums := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br><span class="hljs-keyword">if</span> value, ok := mapNums[target-v]; ok &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;i, value&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mapNums[v] = i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>这次的题目不算很难，做起来就很快，算上写博客的时间不到两个小时</p></li><li><p>对Go语言的map有了新的理解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">test = <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">if</span> value, ok := test[key]; ok &#123;<br><span class="hljs-comment">// key存在的情况</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// key不存在的情况</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用反射来判断两个map是否相等</span><br><span class="hljs-keyword">import</span> reflect<br>reflect.DeepEqual(map1, map2)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">test = <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>test[<span class="hljs-number">1</span>]--  <span class="hljs-comment">// 即使不存在1，默认新增键值对&#123;1:0&#125;，然后再自减</span><br></code></pre></td></tr></table></figure></li><li><p>第一次使用Go模拟枚举</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>A <span class="hljs-literal">iota</span><br>    B<br>    C<br>)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录算法训练营第四天| 24.两两交换链表中的节点、19.删除链表的倒数第N个节点、面试题02.07.链表相交、142.环形链表II。</title>
    <link href="/post/b4e3c0b1.html"/>
    <url>/post/b4e3c0b1.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第四天-24-两两交换链表中的节点、19-删除链表的倒数第N个节点、面试题02-07-链表相交、142-环形链表II。"><a href="#代码随想录算法训练营第四天-24-两两交换链表中的节点、19-删除链表的倒数第N个节点、面试题02-07-链表相交、142-环形链表II。" class="headerlink" title="代码随想录算法训练营第四天| 24.两两交换链表中的节点、19.删除链表的倒数第N个节点、面试题02.07.链表相交、142.环形链表II。"></a>代码随想录算法训练营第四天| 24.两两交换链表中的节点、19.删除链表的倒数第N个节点、面试题02.07.链表相交、142.环形链表II。</h1><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1YT411g7br">帮你把链表细节学清楚！ | LeetCode：24. 两两交换链表中的节点</a></p><p>  状态：AC</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>定义新的头结点，定义指针<code>p = newHead</code>，定义两个新的结点<code>tempNode1.Val = 2</code>，<code>tempNode2.Val = 1</code>（这里的值<code>1</code>和<code>2</code>是为了简化描述）</li></ol><img src="../images/day04/IMG_1372.PNG" alt="链表相关指针（变量说明）" style="zoom:80%;" /><ol start="2"><li>使用新的结点重新进行连接，并且<code>p</code>前进到下一个位置（注意连接顺序，防止断链）<ul><li><code>tempNode2.Next = p.Next.Next.Next</code></li><li><code>tempNode1.Next = tempNode2</code></li><li><code>p.Next = tempNode1</code></li><li><code>p = p.Next.Next</code></li></ul></li></ol><img src="../images/day04/IMG_1373.PNG" alt="IMG_1373" style="zoom:80%;" /><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>newHead := &amp;ListNode&#123;<br>Val:  <span class="hljs-number">0</span>,<br>Next: head,<br>&#125;<br>p := newHead<br><span class="hljs-keyword">for</span> p.Next != <span class="hljs-literal">nil</span> &amp;&amp; p.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>tempNode1 := &amp;ListNode&#123;<br>Val:  p.Next.Next.Val,<br>Next: <span class="hljs-literal">nil</span>,<br>&#125;<br>tempNode2 := &amp;ListNode&#123;<br>Val:  p.Next.Val,<br>Next: p.Next.Next.Next,<br>&#125;<br>tempNode1.Next = tempNode2<br>p.Next = tempNode1<br>p = p.Next.Next<br>&#125;<br><span class="hljs-keyword">return</span> newHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html#%E6%80%9D%E8%B7%AF">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1vW4y1U7Gf">链表遍历学清楚！ | LeetCode：19.删除链表倒数第N个节点</a></p><p>  状态：AC</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>定义两个指针<code>p</code>和<code>q</code>，指针<code>p</code>先出发，指针<code>q</code>保持与<code>p</code>距离为<code>n</code>之后再出发，这样<code>q.Next</code>则是待删除的元素。</p><blockquote><p>  会不会出现<code>n</code>大于链表长度的情况（例如链表长度为5，删除倒数第8个元素）：不会，leetcode题解中给出。</p>  <img src="../images/day04/QQ20230923-221152.png" alt="题目说明" style="zoom:80%;" /></blockquote><img src="../images/day04/IMG_2D422EDB0DFC-1.jpeg" alt="图解" style="zoom:80%;" /><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> head<br>&#125;<br>newHead := &amp;ListNode&#123;<br>Val:  <span class="hljs-number">0</span>,<br>Next: head,<br>&#125;<br>p := newHead<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123;<br>p = p.Next<br>&#125;<br>q := newHead<br><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;<br>p = p.Next<br>q = q.Next<br>&#125;<br><span class="hljs-keyword">if</span> q.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>q.Next = q.Next.Next<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>q.Next = <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">return</span> newHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试题02-07-链表相交"><a href="#面试题02-07-链表相交" class="headerlink" title="面试题02.07.链表相交"></a>面试题02.07.链表相交</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">代码随想录(programmercarl.com)</a></p><p>  状态：AC</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>假设是两个一维数组（只是为了方便逻辑上描述），查看是否相交，那么需要“尾部对齐”。假设长的链表开始的索引为0，我们需要从短的数组的开始。大意如下图</p><img src="../images/day04/160_1.png" alt="判断第一组结点" style="zoom:80%;" /><img src="../images/day04/160_2.png" alt="判断第二组结点" style="zoom:80%;" /><img src="../images/day04/160_3.png" alt="判断第三组结点" style="zoom:80%;" /><p>走到末尾都没发现有相同地址的节点则不存在相交的情况。</p><ul><li>尾部对齐操作：遍历两个链表（一组指针<code>p = newHeadA.Next</code>和<code>q = newHeadB.Next</code>），求各自的长度。</li><li>重新定义一组指针（<code>p1 = newHeadA.Next</code>和<code>q1 = newHeadB.Next</code>），让其中更长的链表的指针移动到和短的同步位置<font color="#bdbdbd">（这里可能是Go语言的特性？C语言不需要此操作，不重新定义指针p和q回不到起始位置）</font></li><li>同时向前移动，判断是否地址相同</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 定义两个新的头，指向传参的头</span><br>    newHeadA := &amp;ListNode &#123;<br>        Val: <span class="hljs-number">0</span>,<br>        Next: headA,<br>    &#125;<br>    newHeadB := &amp;ListNode &#123;<br>        Val: <span class="hljs-number">0</span>,<br>        Next: headB,<br>    &#125;<br>    <span class="hljs-comment">// 求两个链表各自的长度</span><br>    p := newHeadA.Next<br>    lenA := <span class="hljs-number">0</span><br>    q := newHeadB.Next<br>    lenB := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;<br>        p = p.Next<br>        lenA++<br>    &#125;<br>    <span class="hljs-keyword">for</span> q != <span class="hljs-literal">nil</span> &#123;<br>        q = q.Next<br>        lenB++<br>    &#125;<br>    <br>    <span class="hljs-comment">// 定义两个新的指针，进行“对齐”操作</span><br>    p1 := newHeadA.Next<br>    q1 := newHeadB.Next<br>    <span class="hljs-keyword">if</span> lenA &lt; lenB &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; lenB - lenA; i++ &#123;<br>            q1 = q1.Next<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; lenA - lenB; i++ &#123;<br>            p1 = p1.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 对齐后向前查找，找到了返回结点，否则为nil</span><br>    <span class="hljs-keyword">for</span> p1 != <span class="hljs-literal">nil</span> &amp;&amp; q1 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> p1 == q1 &#123;<br>            <span class="hljs-keyword">return</span> p1<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p1 = p1.Next<br>            q1 = q1.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142. 环形链表II"></a>142. 环形链表II</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">力扣题目链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1if4y1d7ob">把环形链表讲清楚！| LeetCode:142.环形链表II</a></p><p>  状态：想不出思路后看了卡哥的讲解恍然大悟，AC！</p></blockquote><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><s><font color="#FF0000">最开始没有审题，当成了这道题是在问是否存在环，后来发现这只是第一问</font></s></p><p>这道题需要返回的是：如果链表有环，那么返回最后一个结点链接到了哪个结点上。</p><ol><li><p>首先要找到，链表是否有环，这里使用的是快慢指针的算法，快指针速度为2，慢指针速度为1。若快指针走到了终点说明没有环；如果两个指针相遇说明有环。</p><blockquote><p>  因为相对速度差1，所以二者必相遇</p></blockquote></li><li><p>找到入口：（卡哥视频讲的很好，如果有疑问一定<strong>看完视频</strong>再提问）</p></li></ol><img src="../images/day04/142_1.jpeg" alt="142_1" style="zoom:80%;" /><p>为什么一圈必定会追上：假设他们同时进入入口（整个链表就是个环），慢指针走一圈后，快指针走两圈。如果快指针先进入，那么追上慢指针必定走不到一圈。</p><p>最后推出来x&#x3D;z，意味着此时的快指针降速（速度变为1），同时新定义的指针从头开始运动，两者必定在入口处相遇</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    fast := head<br>    slow := head<br>    p := head<br>    <span class="hljs-comment">// 这层for寻找环</span><br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next<br>        <span class="hljs-keyword">if</span> fast != <span class="hljs-literal">nil</span> &#123;<br>            fast = fast.Next<br>            <span class="hljs-keyword">if</span> slow == fast &#123;  <span class="hljs-comment">// 两指针相遇说明有环</span><br>            <span class="hljs-keyword">for</span> p != fast &#123;  <span class="hljs-comment">// 这层for执行的是公式中x=z的一步</span><br>                p = p.Next<br>                fast = fast.Next<br>            &#125;<br>            <span class="hljs-keyword">return</span> p<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>今天重新写了下链表的实现（主要是vscode没有装调试leetcode插件），部分题都是自己在GoLand中自己写函数构造的链表，最后单独写了个文件保存这部分代码（主要就是新建链表和打印链表），新建链表是通过一个数组传要初始化的值。当然了，今天的也只有两道题可以用，后两道直接在leetcode的网页上写了，看起来挺复杂的还担心不好debug，理清思路之后写起来很快，也不会出错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> InitLinkList<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;<br>Val  <span class="hljs-type">int</span><br>Next *ListNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InsertElem</span><span class="hljs-params">(head *ListNode, nums []<span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>newHead := &amp;ListNode&#123;<br>Val:  <span class="hljs-number">0</span>,<br>Next: head,<br>&#125;<br>p := newHead<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>p.Next = &amp;ListNode&#123;<br>Val:  v,<br>Next: <span class="hljs-literal">nil</span>,<br>&#125;<br>p = p.Next<br>&#125;<br><span class="hljs-keyword">return</span> newHead.Next<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(head *ListNode)</span></span> &#123;<br>p := head<br><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t&quot;</span>, p.Val)<br>p = p.Next<br>&#125;<br>fmt.Println()<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>Go有些语法还不是很了解，今天发现了跨文件调用需要将<code>变量名</code>和<code>函数名</code>首字母大写，也叫作导出。从一些语法来看Go现在给我的感觉他就不想Java那种强面向对象编程。这点还挺好的（对我个人而言），很灵活，调用的时候也不需要实例化（也没这一种说法）。</p></li><li><p>后三道题（最后一道题指的求是否存在环的过程）考研复习408的时候已经见过，只不过这次的身份发生了变化，面对这道题状态也不同。考研复习时候遇到手撕代码的题首先想到的是如何拿分，没思路就暴力算法。有额外时间再考虑优化。如果再试卷上我可能会使用空间复杂度更大的算法，空间换时间。但是现在在求职中，要好好的理解每一道题，每一种优化的思路，题干加以限制：<code>空间复杂度为O(1)</code>。真的需要认真思考，链表相交没有想出来，看了卡哥的讲解理解了。</p></li><li><p>现在的刷题状态是这样的：多给自己思考的时间争取想到最优的解法。无论是否解出来再去看看卡哥的讲解和代码，看看别人写的和自己写的差距在哪。我的代码现在经常出现这种逻辑，对于个别情况需要单独判断，而别人的则不需要，因为自己在边界情况考虑的欠妥。明天周日休息一天。但是事情还是挺多的。</p></li></ul><p><font color="#3914a5">第一周打卡结束！4天结束！</font></p>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录算法训练营第三天| 203.移除链表元素、707.设计链表、206.反转链表。</title>
    <link href="/post/bd069431.html"/>
    <url>/post/bd069431.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第三天-203-移除链表元素、707-设计链表、206-反转链表。"><a href="#代码随想录算法训练营第三天-203-移除链表元素、707-设计链表、206-反转链表。" class="headerlink" title="代码随想录算法训练营第三天| 203.移除链表元素、707.设计链表、206.反转链表。"></a>代码随想录算法训练营第三天| 203.移除链表元素、707.设计链表、206.反转链表。</h1><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><blockquote><p>题目链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/">leetcode题目链接</a></p><p>文章讲解：<a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">代码随想录(programmercarl.com)</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV18B4y1s7R9">链表基础操作| LeetCode：203.移除链表元素</a></p><p>状态：AC</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>删除元素还是比较简单的，假设<code>q = p.Next</code>，如果删除<code>q</code>则是<code>p.Next = p.Next.Next</code>，考虑下<code>p.Next.Next</code>是否存在即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElements</span><span class="hljs-params">(head *ListNode, val <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>newHead := <span class="hljs-built_in">new</span>(ListNode)<br>newHead.Next = head<br>p := newHead<br><span class="hljs-keyword">for</span> p.Next != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> p.Next.Val == val &#123;<br>p.Next = p.Next.Next<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p = p.Next<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> newHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h2><blockquote><p>题目链接：<a href="https://leetcode.cn/problems/design-linked-list/">leetcode题目链接</a></p><p>文章讲解：<a href="https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html">代码随想录(programmercarl.com)</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1FU4y1X7WD">帮你把链表操作学个通透！LeetCode：707.设计链表</a></p><p>状态：半AC（AC了但是也没完全AC）</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li><code>(this *MyLinkedList)get(index int) int</code>: 先判断index是否合法，所以需要引入一个新的成员对象<code>size</code>在<code>MyLinkedList</code>中</li><li><code>(this *MyLinkedList)AddAtHead(val int)</code>: 头插法只需要在新的头之后接入一个新的节点，然后<code>size++</code></li><li><code>(this *MyLinkedList)AddAtTail(val int)</code>: 尾插法只需要在整个链表之后接入一个新的节点，然后<code>size++</code></li><li><code>(this *MyLinkedList)DeleteAtIndex(index int)</code>: 删除一个元素类似上一题，只不过要判断index是否合法</li><li><code>(this *MyLinkedList)AddAtIndex(index int, val)</code>: 先判断index是否合法，找到正确位置进行插入</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> LinkList <span class="hljs-keyword">struct</span> &#123;<br>Val  <span class="hljs-type">int</span><br>Next *LinkList<br>&#125;<br><br><span class="hljs-keyword">type</span> MyLinkedList <span class="hljs-keyword">struct</span> &#123;<br>size    <span class="hljs-type">int</span><br>newHead *LinkList<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyLinkedList &#123;<br><span class="hljs-comment">//return MyLinkedList&#123;&#125;</span><br>node := &amp;LinkList&#123;<br>Val:  <span class="hljs-number">0</span>,<br>Next: <span class="hljs-literal">nil</span>,<br>&#125;<br><span class="hljs-keyword">return</span> MyLinkedList&#123;<br>newHead: node,<br>size:    <span class="hljs-number">0</span>,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> Get(index <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> || index &gt;= this.size || this == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>p := this.newHead.Next<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index; i++ &#123;<br>p = p.Next<br>&#125;<br><span class="hljs-keyword">return</span> p.Val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtHead(val <span class="hljs-type">int</span>) &#123;<br>newNode := &amp;LinkList&#123;<br>Val:  val,<br>Next: this.newHead.Next,<br>&#125;<br>this.newHead.Next = newNode<br>this.size++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtTail(val <span class="hljs-type">int</span>) &#123;<br>newNode := &amp;LinkList&#123;<br>Val:  val,<br>Next: <span class="hljs-literal">nil</span>,<br>&#125;<br>p := this.newHead<br><span class="hljs-keyword">for</span> p.Next != <span class="hljs-literal">nil</span> &#123;<br>p = p.Next<br>&#125;<br>p.Next = newNode<br>this.size++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtIndex(index <span class="hljs-type">int</span>, val <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> &#123;<br>index = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> index &gt; this.size &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>newNode := &amp;LinkList&#123;<br>Val:  val,<br>Next: <span class="hljs-literal">nil</span>,<br>&#125;<br>p := this.newHead<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index; i++ &#123;<br>p = p.Next<br>&#125;<br>newNode.Next = p.Next<br>p.Next = newNode<br>this.size++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> || index &gt;= this.size &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>p := this.newHead<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index; i++ &#123;<br>p = p.Next<br>&#125;<br><span class="hljs-keyword">if</span> p.Next != <span class="hljs-literal">nil</span> &#123;<br>p.Next = p.Next.Next<br>&#125;<br>this.size--<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><blockquote><p>题目链接：<a href="https://leetcode.cn/problems/reverse-linked-list/">leetcode题目链接</a></p><p>文章讲解：<a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">代码随想录(programmercarl.com)</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1nB4y1i7eL">帮你拿下反转链表 | LeetCode：206.反转链表</a></p><p>状态：AC</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>建立新的头结点<code>newHead</code> ，使其<code>newHead.Next = head</code>。</li><li>定义指针<code>p = head.Next</code>(先判断head是否为单节点)，然后手动断链，<code>head.Next = nil</code></li><li>指针<code>p</code>不断向后，每遍历到一个元素，将这个元素保存到新的节点<code>newNode</code>，并且不断头插到<code>newHead</code></li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(head *ListNode, val <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>newHead := &amp;ListNode&#123;<br>Val:  <span class="hljs-number">0</span>,<br>Next: head,<br>&#125;<br>newNode := &amp;ListNode&#123;<br>Val:  val,<br>Next: newHead.Next,<br>&#125;<br>newHead.Next = newNode<br><span class="hljs-keyword">return</span> newHead.Next<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> head<br>&#125;<br>p := head.Next<br>head.Next = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;<br>head = addAtHead(head, p.Val)<br>p = p.Next<br>&#125;<br><span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>leetcode上的链表的题都是无头链表，所谓的 <code>head</code> 被叫做 <code>虚拟头</code>。我感觉还是叫做无头链表好一些，新建一个头先链接无头链表</p></li><li><p>以前写过的都是有头链表，换到了无头链表刚开始有点不知所措、插入时候感觉怪怪的，其实都一样</p></li><li><p><code>Go</code>的<code>new</code>相关或者初始化成员变量有了新的理解</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SSS <span class="hljs-keyword">struct</span> &#123;<br>    Val <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">//初始化的方式1</span><br>a := <span class="hljs-built_in">new</span> SSS(<span class="hljs-number">1</span>)<br>a.Val = <span class="hljs-number">1</span><br><br><span class="hljs-comment">//初始化的方式2</span><br>a := &amp;SSS&#123;<br>    Val: <span class="hljs-number">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><code>Go</code>的构造函数看起来还有点懵</p></li><li><p>最近事情太多了，周六上午招聘会、下午学校组织的求职训练营、晚上继续leetcode；周日上午训练营结课、下午再重写下链表、搞搞课题；周一还有个小活动。加油！</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。</title>
    <link href="/post/b79a1ea.html"/>
    <url>/post/b79a1ea.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第二天-977-有序数组的平方、209-长度最小的子数组、59-螺旋矩阵II。"><a href="#代码随想录算法训练营第二天-977-有序数组的平方、209-长度最小的子数组、59-螺旋矩阵II。" class="headerlink" title="代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。"></a>代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。</h1><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">leetcode链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1QB4y1D7ep">双指针法经典题目 | LeetCode：977.有序数组的平方</a></p><p>  状态：AC</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先想到的是暴力算法，将每个元素计算平方，之后再将数组进行排序，此时的时间复杂度为<code>O(nlog n)</code>。但是并不满足题目中要求的<code>O(n)</code>，因为有一个条件我们还没有用上：<strong>非递减顺序数组</strong>。看了题解之后才清楚更好的方法：<strong>双指针算法</strong>。</p><p>由于是非递减的数组，而且会有负数，那么在平方之后，得到的新数组的最后一位一定会在原数组的起始或者末尾位置。那么使用双指针算法相向遍历即可，得到最大的值放入到新数组的末尾。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedSquares</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(nums)<br>result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := right; i &gt;= <span class="hljs-number">0</span>; i-- &#123;  <span class="hljs-comment">// i为result的索引</span><br><span class="hljs-keyword">if</span> nums[left]*nums[left] &lt; nums[right]*nums[right] &#123;  <span class="hljs-comment">// right侧更大</span><br>result[i] = nums[right] * nums[right]<br>right--<br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// left侧更大</span><br>result[i] = nums[left] * nums[left]<br>left++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">leetcode链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1tZ4y1q7XE">拿下滑动窗口！ | LeetCode 209 长度最小的子数组</a></p><p>  状态：AC</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>此题需要找最短连续的一子数组，能想到的是 <strong>滑动窗口</strong> 算法。</p><ol><li>设最短子数组长度<code>minLength</code>为无穷大，题目规定长度最大为100000，<code>minLength=100001</code>即可。</li><li>右侧不断向前，直至这一子数组的和大于 <code>target</code></li><li>子序列和大于target之后，左侧也不断向前，直至子数组和小于 <code>target</code>，记录下此刻的序列长度，并与 <code>minLength</code> 进行比较。</li><li>循环条件：当右侧到头，并且此时的子数组的和小于<code>target</code></li><li>退出循环后，如果<code>minLength</code>依旧等于100001，说明不存在满足要求的子数组，则返回<code>0</code></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(target <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-number">0</span><br>sum := <span class="hljs-number">0</span><br>minLength := <span class="hljs-number">100001</span><br>length := <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">for</span> left &lt;= right &amp;&amp; right &lt;= length &#123;<br><span class="hljs-keyword">if</span> sum &lt; target &#123;<br><span class="hljs-keyword">if</span> right &lt; length &#123;<br>sum += nums[right]<br>right++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> minLength &gt; right-left &#123;<br>minLength = right - left<br>&#125;<br>sum -= nums[left]<br>left++<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> minLength == <span class="hljs-number">100001</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span> minLength<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><blockquote><p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">leetcode链接</a></p><p>文章讲解：<a href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">代码随想录(programmercarl.com)</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1SL4y1N7mV/">一入循环深似海 | LeetCode：59.螺旋矩阵II</a></p><p>状态：AC</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><img src="/../images/day02/image-20230921130326208.png" alt="image-20230921130326208"></p><ol><li><p>循环次数是<code>n/2</code></p></li><li><p>每次循环时候按照<font color="#4664b9">蓝色</font>、<font color="#4f7633">绿色</font>、<font color="#b0871e">黄色</font>、<font color="#622a93">紫色</font>的顺序填数字， 数字保持自增，保存结果的数组为<code>results</code></p></li><li><p>各个颜色的范围，注意是从大到小还是从小到大：</p><p><font color="#4664b9">蓝色的范围：results[top][left ~ right - 1]</font><br><font color="#4f7633">绿色的范围：results[top ~ bottom - 1][right]</font></p><p><font color="#b0871e">黄色的范围：results[bottom][right ~ left + 1]</font></p><p><font color="#622a93">紫色的范围：results[bottom ~ top + 1][left]</font></p></li><li><p>每一轮过后，<code>top++</code>、<code>bottom--</code>、<code>left++</code>、<code>right--</code></p></li><li><p>额外的，如果n为基数，最中心的数字是在循环条件之外的，需要额外加上。</p></li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateMatrix</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>top := <span class="hljs-number">0</span><br>bottom := n - <span class="hljs-number">1</span><br>left := <span class="hljs-number">0</span><br>right := n - <span class="hljs-number">1</span><br>result := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>result[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>&#125;<br>num := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n/<span class="hljs-number">2</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := left; j &lt; right; j++ &#123;<br>result[top][j] = num<br>num++<br>&#125;<br><br><span class="hljs-keyword">for</span> j := top; j &lt; bottom; j++ &#123;<br>result[j][right] = num<br>num++<br>&#125;<br><br><span class="hljs-keyword">for</span> j := right; j &gt; left; j-- &#123;<br>result[bottom][j] = num<br>num++<br>&#125;<br><span class="hljs-keyword">for</span> j := bottom; j &gt; top; j-- &#123;<br>result[j][left] = num<br>num++<br>&#125;<br>top++<br>left++<br>right--<br>bottom--<br>&#125;<br><span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>result[n/<span class="hljs-number">2</span>][n/<span class="hljs-number">2</span>] = num<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>帮助了群里一些录友解决了些问题，能看出来他们也比较萌新，想起了自己最开始大一学的时候，但是自己并没有坚持下去，很可惜。</p></li><li><p>Go语言在初始化数组时候还不是很熟练，写的时候一直在思考int类型二维数组怎么初始化，但是用切片写起来还是简单一些吧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">result := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>    result[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>今天还有点别的事情，先写这么多，扩展题先不写了</p></li><li><p>打卡第二天！</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。</title>
    <link href="/post/7b6fd36a.html"/>
    <url>/post/7b6fd36a.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第一天-704-二分查找、27-移除元素。"><a href="#代码随想录算法训练营第一天-704-二分查找、27-移除元素。" class="headerlink" title="代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。"></a>代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。</h1><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/binary-search/">leetcode链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1fA4y1o715">手把手带你撕出正确的二分法 | 二分查找法 | 二分搜索法 | LeetCode：704. 二分查找</a></p><p>  状态：AC</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看了卡哥的文档，才注意到二分查找也有两种写法。”要<strong>熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法</strong>“。回头看自己的代码是左闭右闭的写法，再改写成左闭右开也不难，只需要更改边界条件即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 左闭右闭写法</span><br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> mid <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br>mid = (left + right) / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>right = mid - <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> mid<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search1</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 左闭右开写法</span><br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">var</span> mid <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> left &lt; right &#123;<br>mid = (left + right) / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>right = mid<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> mid<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/remove-element/">leetcode链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV12A4y1Z7LP">数组中移除元素并不容易！ | LeetCode：27. 移除元素</a></p><p>  状态：AC</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>第一眼看到时，题目要求”不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong>原地修改输入数组</strong>“。能想到的就是将待删除的后面的元素向前移动达到删除效果，但是时间复杂度为<code>O(n^2)</code>。再向下看到了示例：</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [3,2,2,3], val &#x3D; 3<br>输出：2, nums &#x3D; [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2<br>输出：5, nums &#x3D; [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>看到这里大概理解了，想到的解法是双指针，方法也有两种。</p><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><ol><li>左右指针均从头开始，右指针每次向前一步</li><li>若右指针的值为<code>val</code>，那么跳过；否则将右指针的值给左指针，左指针++</li><li>返回左指针所在的索引</li></ol><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><ol><li>左指针从前开始，右指针从后开始，左指针找<code>val</code>，右指针找非<code>val</code></li><li>右指针的值给左指针</li><li>返回左指针所在的索引</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, val <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(nums)<br>left := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> right := <span class="hljs-number">0</span>; right &lt; n; right++ &#123;<br><span class="hljs-keyword">if</span> nums[right] != val &#123;<br>nums[left] = nums[right]<br>left++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法二</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, val <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br><span class="hljs-keyword">if</span> nums[left] == val &#123;<br><span class="hljs-keyword">break</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>left++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br><span class="hljs-keyword">if</span> nums[right] != val &#123;<br><span class="hljs-keyword">break</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right--<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> left &lt; right &#123;<br>nums[left] = nums[right]<br>left++<br>right--<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二还是的边界条件有点绕的，自己把自己绕进去了</p><p><img src="/../images/day01/image-20230920140818304.png" alt="绕晕了的边界"></p><h2 id="附加题-35-搜索插入位置"><a href="#附加题-35-搜索插入位置" class="headerlink" title="附加题 35. 搜索插入位置"></a>附加题 35. 搜索插入位置</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></p><p>  状态：AC</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>查找，而且是有序，不难想到二分查找。这不过这里不是匹配的情况，而是有可能不匹配。无论是否匹配，只需返回左边界即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> mid <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br>mid = (left + right) / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> nums[mid] == target &#123;<br><span class="hljs-keyword">return</span> mid<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right = mid - <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="附加题34-在排序数组中查找元素的第一个和最后一个位置"><a href="#附加题34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="附加题34.在排序数组中查找元素的第一个和最后一个位置"></a>附加题34.在排序数组中查找元素的第一个和最后一个位置</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34.在排序数组中查找元素的第一个和最后一个位置</a></p><p>  状态：AC</p></blockquote><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>通过两次二分查找找到<code>target</code>在数组中的起始和结束位置，实现了函数<code>binary</code>可以两次调用。但是判断起始位置和结束位置需要额外的判断条件：</p><ul><li>起始：需要判断<code>num[mid-1]&lt;target</code>，或者<code>mid==0</code>（第0个元素就是起始位置），为了保证不越界，需要先判断<code>mid==0</code>的情况</li><li>结束：需要判断<code>mid == len(nums)-1</code>（最后一个元素是结束位置），或者<code>nums[mid+1] &gt; target</code></li></ul><p>如果没有找到该元素，则返回<code>-1</code>。由于起始和介绍条件判断有些不同，<code>binary</code>函数中使用了<code>flag</code>来区分是进行起始元素查找还是结束元素查找的条件。若是<code>true</code>则为查找起始元素</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br>    temp = binary(nums, target, <span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">if</span> temp == <span class="hljs-number">-1</span> &#123;  <span class="hljs-comment">// 如果查找开始元素为-1，说明该数不存在，第二次二分不需要进行</span><br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>result = <span class="hljs-built_in">append</span>(result, temp)<br>        result = <span class="hljs-built_in">append</span>(result, binary(nums, target, <span class="hljs-literal">false</span>))<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binary</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>, flag <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br>mid := left + (right-left)/<span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> flag &#123;<br><span class="hljs-keyword">if</span> nums[mid] == target &amp;&amp; (mid == <span class="hljs-number">0</span> || nums[mid<span class="hljs-number">-1</span>] &lt; target) &#123;<br><span class="hljs-keyword">return</span> mid<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right = mid - <span class="hljs-number">1</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> nums[mid] == target &amp;&amp; (mid == <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> || nums[mid+<span class="hljs-number">1</span>] &gt; target) &#123;<br><span class="hljs-keyword">return</span> mid<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt;= target &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right = mid - <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/day01/image-20230920152650727.png" alt="AC！"></p><h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="Go语言版本"><a href="#Go语言版本" class="headerlink" title="Go语言版本"></a>Go语言版本</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    leftmost := sort.SearchInts(nums, target)<br>    <span class="hljs-keyword">if</span> leftmost == <span class="hljs-built_in">len</span>(nums) || nums[leftmost] != target &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>    &#125;<br>    rightmost := sort.SearchInts(nums, target + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;leftmost, rightmost&#125;<br>&#125;<br><br>作者：力扣官方题解<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p><code>sort.SearchInts()</code>函数没有接触过，看看源码</p><img src="../images/day01/image-20230920152855240.png" alt="sort.SearchInts()源码" style="zoom:67%;" /><blockquote><p>  SearchInts在整型数组的有序切片中搜索x，并返回由Search指定的索引。如果x不存在，返回值是插入x的索引(可以是len(a))。<br>  切片必须按升序排序。</p></blockquote><h4 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">bool</span> lower)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, ans = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                ans = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> leftIdx = <span class="hljs-built_in">binarySearch</span>(nums, target, <span class="hljs-literal">true</span>);<br>        <span class="hljs-type">int</span> rightIdx = <span class="hljs-built_in">binarySearch</span>(nums, target, <span class="hljs-literal">false</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;<br>            <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;leftIdx, rightIdx&#125;;<br>        &#125; <br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br><br>作者：力扣官方题解<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>官方题解在找结束元素是找到了下一位，可以通过减一操作得到正确答案。但是他们实现的二分函数的<code>true</code>和<code>false</code>对条件控制的很巧妙。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>在二分查找时又学到了一种思路，”左闭右开“</p></li><li><p>群里面有位同学说到了这个事情，之前从未注意过：</p><img src="../images/day01/image-20230920153829216.png" alt="群友聊天" style="zoom:80%;" /><p>看别人的二分确实发现了第一种写法，但是并不是很理解，也没有很在意。</p></li></ul><p>今天总用时三个小时多一些，做了四道题，感觉良好。第一天结束！！</p>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建博客</title>
    <link href="/post/5c83b0d3.html"/>
    <url>/post/5c83b0d3.html</url>
    
    <content type="html"><![CDATA[<h1 id="搭建Hexo博客"><a href="#搭建Hexo博客" class="headerlink" title="搭建Hexo博客"></a>搭建Hexo博客</h1><p>根据程序羊的视频搭建而成，整理下步骤和与当时不同之处</p><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/">https://www.bilibili.com/video/BV1Yb411a7ty/</a></p><h2 id="1-安装node-js与npm"><a href="#1-安装node-js与npm" class="headerlink" title="1. 安装node.js与npm"></a>1. 安装node.js与npm</h2><p>略。</p><p>有“魔法”的不需要下载<code>cnpm</code>包，此后以<code>npm</code>为例</p><h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h2><p><code>npm install -g hexo-cli</code></p><p><code>hexo -v </code>查看是否安装成功</p><h2 id="3-选址"><a href="#3-选址" class="headerlink" title="3. 选址"></a>3. 选址</h2><p>在合适的地方新建一个专门用于存放博客的文件夹（假设文件夹名为 <code>blog</code> ，并且看做根目录），在该路径下开始操作。</p><ul><li><p>执行 <code>hexo init</code> 初始化，<code>Linux\MacOS</code> 需要 <code>sudo</code>权限</p></li><li><p>生成一些文件与文件夹，一些配置在文件 <code>blog/_config.yml</code> 中</p></li></ul><h2 id="4-部署至GitHub的准备工作"><a href="#4-部署至GitHub的准备工作" class="headerlink" title="4. 部署至GitHub的准备工作"></a>4. 部署至GitHub的准备工作</h2><ol><li><p>在该路径下执行命令: <code>npm install --save-deployer-git</code> 安装相关工具</p></li><li><p>在GitHub新建仓库，仓库名必须为: <code>GitHub的用户名.github.io</code></p></li><li><p>更改<code>_config.yml</code>文件中的内容(在最后)：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git仓库地址</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure></li><li><p>GitHub更新了认证方式，具体操作可以参考这一篇<a href="https://blog.csdn.net/weixin_63031041/article/details/128731242">博客</a></p></li></ol><h2 id="5-相关命令"><a href="#5-相关命令" class="headerlink" title="5. 相关命令"></a>5. 相关命令</h2><ol><li><p>运行(本地预览): <code>hexo s</code></p></li><li><p>写新的博客: <code>hexo n &quot;文件名&quot;</code></p></li><li><p>写好之后生成静态网站: <code>hexo g</code></p></li><li><p>清空第三步生成的文件: <code>hexo clean</code></p></li><li><p>推送至GitHub(会有一定的延迟): <code>hexo d</code></p><p> 使用“魔法”后，GitHub需要设置代理</p><p> <code>git config --global http.proxy http://127.0.0.1:port</code></p><p> <code>git config --global https.proxy https://127.0.0.1:port</code></p></li></ol><h2 id="6-更换主题"><a href="#6-更换主题" class="headerlink" title="6. 更换主题"></a>6. 更换主题</h2><p>可以直接在搜索引擎搜索相关关键字，例如<code>hexo 主题</code>，以我现在使用的<code>Fluid</code>为例</p><p>GitHub地址: <a href="https://github.com/fluid-dev/hexo-theme-fluid/tree/master">https://github.com/fluid-dev/hexo-theme-fluid/tree/master</a></p><ol><li>在博客目录下克隆, 至<code>blog/themes</code>文件夹下: <code>git clone https://github.com/fluid-dev/hexo-theme-fluid/tree/master themes/fluid</code></li><li>更改<code>blog/_config.yml</code> 第100行，将<code>theme: </code>后改为<code>fluid</code></li><li>更多具体配置参考官方文档: <a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></li><li>大段文字需要换行需要使用<code>HTML</code>语法</li></ol><h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h2><p>这里面还有很多有意思的功能没探索、没开发。留给接下来的时间。也慢慢优化这个小网站。</p><p>参加“代码随想录”的训练营，虽然有点晚，但是还来得及。搭建了一个博客，主要还是写给自己，记录这一路的成长，当然也不单单的只这一路。</p><p>很喜欢郭帆导演的一句话，让我放在了首页开屏</p><p>&#x3D;&#x3D;如果你想再次拥有你从未有过的东西，那么你必须再次去做你从未做过的事情。这还不是结束，这是再次的开始！&#x3D;&#x3D;</p>]]></content>
    
    
    <categories>
      
      <category>搭建环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
