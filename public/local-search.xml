<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。</title>
    <link href="/post/b79a1ea.html"/>
    <url>/post/b79a1ea.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第二天-977-有序数组的平方、209-长度最小的子数组、59-螺旋矩阵II。"><a href="#代码随想录算法训练营第二天-977-有序数组的平方、209-长度最小的子数组、59-螺旋矩阵II。" class="headerlink" title="代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。"></a>代码随想录算法训练营第二天| 977.有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。</h1><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">leetcode链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1QB4y1D7ep">双指针法经典题目 | LeetCode：977.有序数组的平方</a></p><p>  状态：AC</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先想到的是暴力算法，将每个元素计算平方，之后再将数组进行排序，此时的时间复杂度为<code>O(nlog n)</code>。但是并不满足题目中要求的<code>O(n)</code>，因为有一个条件我们还没有用上：<strong>非递减顺序数组</strong>。看了题解之后才清楚更好的方法：<strong>双指针算法</strong>。</p><p>由于是非递减的数组，而且会有负数，那么在平方之后，得到的新数组的最后一位一定会在原数组的起始或者末尾位置。那么使用双指针算法相向遍历即可，得到最大的值放入到新数组的末尾。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedSquares</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(nums)<br>result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := right; i &gt;= <span class="hljs-number">0</span>; i-- &#123;  <span class="hljs-comment">// i为result的索引</span><br><span class="hljs-keyword">if</span> nums[left]*nums[left] &lt; nums[right]*nums[right] &#123;  <span class="hljs-comment">// right侧更大</span><br>result[i] = nums[right] * nums[right]<br>right--<br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// left侧更大</span><br>result[i] = nums[left] * nums[left]<br>left++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">leetcode链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1tZ4y1q7XE">拿下滑动窗口！ | LeetCode 209 长度最小的子数组</a></p><p>  状态：AC</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>此题需要找最短连续的一子数组，能想到的是 <strong>滑动窗口</strong> 算法。</p><ol><li>设最短子数组长度<code>minLength</code>为无穷大，题目规定长度最大为100000，<code>minLength=100001</code>即可。</li><li>右侧不断向前，直至这一子数组的和大于 <code>target</code></li><li>子序列和大于target之后，左侧也不断向前，直至子数组和小于 <code>target</code>，记录下此刻的序列长度，并与 <code>minLength</code> 进行比较。</li><li>循环条件：当右侧到头，并且此时的子数组的和小于<code>target</code></li><li>退出循环后，如果<code>minLength</code>依旧等于100001，说明不存在满足要求的子数组，则返回<code>0</code></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(target <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-number">0</span><br>sum := <span class="hljs-number">0</span><br>minLength := <span class="hljs-number">100001</span><br>length := <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">for</span> left &lt;= right &amp;&amp; right &lt;= length &#123;<br><span class="hljs-keyword">if</span> sum &lt; target &#123;<br><span class="hljs-keyword">if</span> right &lt; length &#123;<br>sum += nums[right]<br>right++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> minLength &gt; right-left &#123;<br>minLength = right - left<br>&#125;<br>sum -= nums[left]<br>left++<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> minLength == <span class="hljs-number">100001</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span> minLength<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><blockquote><p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">leetcode链接</a></p><p>文章讲解：<a href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">代码随想录(programmercarl.com)</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1SL4y1N7mV/">一入循环深似海 | LeetCode：59.螺旋矩阵II</a></p><p>状态：AC</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><img src="/../images/image-20230921130326208.png" alt="image-20230921130326208"></p><ol><li><p>循环次数是<code>n/2</code></p></li><li><p>每次循环时候按照<font color="#4664b9">蓝色</font>、<font color="#4f7633">绿色</font>、<font color="#b0871e">黄色</font>、<font color="#622a93">紫色</font>的顺序填数字， 数字保持自增，保存结果的数组为<code>results</code></p></li><li><p>各个颜色的范围，注意是从大到小还是从小到大：</p><p><font color="#4664b9">蓝色的范围：results[top][left ~ right - 1]</font><br><font color="#4f7633">绿色的范围：results[top ~ bottom - 1][right]</font></p><p><font color="#b0871e">黄色的范围：results[bottom][right ~ left + 1]</font></p><p><font color="#622a93">紫色的范围：results[bottom ~ top + 1][left]</font></p></li><li><p>每一轮过后，<code>top++</code>、<code>bottom--</code>、<code>left++</code>、<code>right--</code></p></li><li><p>额外的，如果n为基数，最中心的数字是在循环条件之外的，需要额外加上。</p></li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateMatrix</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>top := <span class="hljs-number">0</span><br>bottom := n - <span class="hljs-number">1</span><br>left := <span class="hljs-number">0</span><br>right := n - <span class="hljs-number">1</span><br>result := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>result[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>&#125;<br>num := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n/<span class="hljs-number">2</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := left; j &lt; right; j++ &#123;<br>result[top][j] = num<br>num++<br>&#125;<br><br><span class="hljs-keyword">for</span> j := top; j &lt; bottom; j++ &#123;<br>result[j][right] = num<br>num++<br>&#125;<br><br><span class="hljs-keyword">for</span> j := right; j &gt; left; j-- &#123;<br>result[bottom][j] = num<br>num++<br>&#125;<br><span class="hljs-keyword">for</span> j := bottom; j &gt; top; j-- &#123;<br>result[j][left] = num<br>num++<br>&#125;<br>top++<br>left++<br>right--<br>bottom--<br>&#125;<br><span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>result[n/<span class="hljs-number">2</span>][n/<span class="hljs-number">2</span>] = num<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>帮助了群里一些录友解决了些问题，能看出来他们也比较萌新，想起了自己最开始大一学的时候，但是自己并没有坚持下去，很可惜。</p></li><li><p>Go语言在初始化数组时候还不是很熟练，写的时候一直在思考int类型二维数组怎么初始化，但是用切片写起来还是简单一些吧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">result := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>    result[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>今天还有点别的事情，先写这么多，扩展题先不写了</p></li><li><p>打卡第二天！</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。</title>
    <link href="/post/7b6fd36a.html"/>
    <url>/post/7b6fd36a.html</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第一天-704-二分查找、27-移除元素。"><a href="#代码随想录算法训练营第一天-704-二分查找、27-移除元素。" class="headerlink" title="代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。"></a>代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。</h1><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/binary-search/">leetcode链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV1fA4y1o715">手把手带你撕出正确的二分法 | 二分查找法 | 二分搜索法 | LeetCode：704. 二分查找</a></p><p>  状态：AC</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看了卡哥的文档，才注意到二分查找也有两种写法。”要<strong>熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法</strong>“。回头看自己的代码是左闭右闭的写法，再改写成左闭右开也不难，只需要更改边界条件即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 左闭右闭写法</span><br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> mid <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br>mid = (left + right) / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>right = mid - <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> mid<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search1</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 左闭右开写法</span><br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">var</span> mid <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> left &lt; right &#123;<br>mid = (left + right) / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>right = mid<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> mid<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/remove-element/">leetcode链接</a></p><p>  文章讲解：<a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">代码随想录(programmercarl.com)</a></p><p>  视频讲解：<a href="https://www.bilibili.com/video/BV12A4y1Z7LP">数组中移除元素并不容易！ | LeetCode：27. 移除元素</a></p><p>  状态：AC</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>第一眼看到时，题目要求”不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong>原地修改输入数组</strong>“。能想到的就是将待删除的后面的元素向前移动达到删除效果，但是时间复杂度为<code>O(n^2)</code>。再向下看到了示例：</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [3,2,2,3], val &#x3D; 3<br>输出：2, nums &#x3D; [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2<br>输出：5, nums &#x3D; [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>看到这里大概理解了，想到的解法是双指针，方法也有两种。</p><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><ol><li>左右指针均从头开始，右指针每次向前一步</li><li>若右指针的值为<code>val</code>，那么跳过；否则将右指针的值给左指针，左指针++</li><li>返回左指针所在的索引</li></ol><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><ol><li>左指针从前开始，右指针从后开始，左指针找<code>val</code>，右指针找非<code>val</code></li><li>右指针的值给左指针</li><li>返回左指针所在的索引</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, val <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(nums)<br>left := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> right := <span class="hljs-number">0</span>; right &lt; n; right++ &#123;<br><span class="hljs-keyword">if</span> nums[right] != val &#123;<br>nums[left] = nums[right]<br>left++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法二</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, val <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br><span class="hljs-keyword">if</span> nums[left] == val &#123;<br><span class="hljs-keyword">break</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>left++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br><span class="hljs-keyword">if</span> nums[right] != val &#123;<br><span class="hljs-keyword">break</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right--<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> left &lt; right &#123;<br>nums[left] = nums[right]<br>left++<br>right--<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二还是的边界条件有点绕的，自己把自己绕进去了</p><p><img src="/../images/image-20230920140818304.png" alt="绕晕了的边界"></p><h2 id="附加题-35-搜索插入位置"><a href="#附加题-35-搜索插入位置" class="headerlink" title="附加题 35. 搜索插入位置"></a>附加题 35. 搜索插入位置</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></p><p>  状态：AC</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>查找，而且是有序，不难想到二分查找。这不过这里不是匹配的情况，而是有可能不匹配。无论是否匹配，只需返回左边界即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> mid <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br>mid = (left + right) / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> nums[mid] == target &#123;<br><span class="hljs-keyword">return</span> mid<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right = mid - <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="附加题34-在排序数组中查找元素的第一个和最后一个位置"><a href="#附加题34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="附加题34.在排序数组中查找元素的第一个和最后一个位置"></a>附加题34.在排序数组中查找元素的第一个和最后一个位置</h2><blockquote><p>  题目链接：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34.在排序数组中查找元素的第一个和最后一个位置</a></p><p>  状态：AC</p></blockquote><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>通过两次二分查找找到<code>target</code>在数组中的起始和结束位置，实现了函数<code>binary</code>可以两次调用。但是判断起始位置和结束位置需要额外的判断条件：</p><ul><li>起始：需要判断<code>num[mid-1]&lt;target</code>，或者<code>mid==0</code>（第0个元素就是起始位置），为了保证不越界，需要先判断<code>mid==0</code>的情况</li><li>结束：需要判断<code>mid == len(nums)-1</code>（最后一个元素是结束位置），或者<code>nums[mid+1] &gt; target</code></li></ul><p>如果没有找到该元素，则返回<code>-1</code>。由于起始和介绍条件判断有些不同，<code>binary</code>函数中使用了<code>flag</code>来区分是进行起始元素查找还是结束元素查找的条件。若是<code>true</code>则为查找起始元素</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>result := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br>    temp = binary(nums, target, <span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">if</span> temp == <span class="hljs-number">-1</span> &#123;  <span class="hljs-comment">// 如果查找开始元素为-1，说明该数不存在，第二次二分不需要进行</span><br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>result = <span class="hljs-built_in">append</span>(result, temp)<br>        result = <span class="hljs-built_in">append</span>(result, binary(nums, target, <span class="hljs-literal">false</span>))<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binary</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>, flag <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br>mid := left + (right-left)/<span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> flag &#123;<br><span class="hljs-keyword">if</span> nums[mid] == target &amp;&amp; (mid == <span class="hljs-number">0</span> || nums[mid<span class="hljs-number">-1</span>] &lt; target) &#123;<br><span class="hljs-keyword">return</span> mid<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right = mid - <span class="hljs-number">1</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> nums[mid] == target &amp;&amp; (mid == <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> || nums[mid+<span class="hljs-number">1</span>] &gt; target) &#123;<br><span class="hljs-keyword">return</span> mid<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt;= target &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right = mid - <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/image-20230920152650727.png" alt="AC！"></p><h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h3><h4 id="Go语言版本"><a href="#Go语言版本" class="headerlink" title="Go语言版本"></a>Go语言版本</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    leftmost := sort.SearchInts(nums, target)<br>    <span class="hljs-keyword">if</span> leftmost == <span class="hljs-built_in">len</span>(nums) || nums[leftmost] != target &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>    &#125;<br>    rightmost := sort.SearchInts(nums, target + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;leftmost, rightmost&#125;<br>&#125;<br><br>作者：力扣官方题解<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p><code>sort.SearchInts()</code>函数没有接触过，看看源码</p><img src="../images/image-20230920152855240.png" alt="sort.SearchInts()源码" style="zoom:67%;" /><blockquote><p>  SearchInts在整型数组的有序切片中搜索x，并返回由Search指定的索引。如果x不存在，返回值是插入x的索引(可以是len(a))。<br>  切片必须按升序排序。</p></blockquote><h4 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">bool</span> lower)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, ans = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                ans = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> leftIdx = <span class="hljs-built_in">binarySearch</span>(nums, target, <span class="hljs-literal">true</span>);<br>        <span class="hljs-type">int</span> rightIdx = <span class="hljs-built_in">binarySearch</span>(nums, target, <span class="hljs-literal">false</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;<br>            <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;leftIdx, rightIdx&#125;;<br>        &#125; <br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br><br>作者：力扣官方题解<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>官方题解在找结束元素是找到了下一位，可以通过减一操作得到正确答案。但是他们实现的二分函数的<code>true</code>和<code>false</code>对条件控制的很巧妙。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>在二分查找时又学到了一种思路，”左闭右开“</p></li><li><p>群里面有位同学说到了这个事情，之前从未注意过：</p><img src="../images/image-20230920153829216.png" alt="群友聊天" style="zoom:80%;" /><p>看别人的二分确实发现了第一种写法，但是并不是很理解，也没有很在意。</p></li></ul><p>今天总用时三个小时多一些，做了四道题，感觉良好。第一天结束！！</p>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>代码随想录</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建博客</title>
    <link href="/post/5c83b0d3.html"/>
    <url>/post/5c83b0d3.html</url>
    
    <content type="html"><![CDATA[<h1 id="搭建Hexo博客"><a href="#搭建Hexo博客" class="headerlink" title="搭建Hexo博客"></a>搭建Hexo博客</h1><p>根据程序羊的视频搭建而成，整理下步骤和与当时不同之处</p><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/">https://www.bilibili.com/video/BV1Yb411a7ty/</a></p><h2 id="1-安装node-js与npm"><a href="#1-安装node-js与npm" class="headerlink" title="1. 安装node.js与npm"></a>1. 安装node.js与npm</h2><p>略。</p><p>有“魔法”的不需要下载<code>cnpm</code>包，此后以<code>npm</code>为例</p><h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h2><p><code>npm install -g hexo-cli</code></p><p><code>hexo -v </code>查看是否安装成功</p><h2 id="3-选址"><a href="#3-选址" class="headerlink" title="3. 选址"></a>3. 选址</h2><p>在合适的地方新建一个专门用于存放博客的文件夹（假设文件夹名为 <code>blog</code> ，并且看做根目录），在该路径下开始操作。</p><ul><li><p>执行 <code>hexo init</code> 初始化，<code>Linux\MacOS</code> 需要 <code>sudo</code>权限</p></li><li><p>生成一些文件与文件夹，一些配置在文件 <code>blog/_config.yml</code> 中</p></li></ul><h2 id="4-部署至GitHub的准备工作"><a href="#4-部署至GitHub的准备工作" class="headerlink" title="4. 部署至GitHub的准备工作"></a>4. 部署至GitHub的准备工作</h2><ol><li><p>在该路径下执行命令: <code>npm install --save-deployer-git</code> 安装相关工具</p></li><li><p>在GitHub新建仓库，仓库名必须为: <code>GitHub的用户名.github.io</code></p></li><li><p>更改<code>_config.yml</code>文件中的内容(在最后)：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git仓库地址</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure></li><li><p>GitHub更新了认证方式，具体操作可以参考这一篇<a href="https://blog.csdn.net/weixin_63031041/article/details/128731242">博客</a></p></li></ol><h2 id="5-相关命令"><a href="#5-相关命令" class="headerlink" title="5. 相关命令"></a>5. 相关命令</h2><ol><li><p>运行(本地预览): <code>hexo s</code></p></li><li><p>写新的博客: <code>hexo n &quot;文件名&quot;</code></p></li><li><p>写好之后生成静态网站: <code>hexo g</code></p></li><li><p>清空第三步生成的文件: <code>hexo clean</code></p></li><li><p>推送至GitHub(会有一定的延迟): <code>hexo d</code></p><p> 使用“魔法”后，GitHub需要设置代理</p><p> <code>git config --global http.proxy http://127.0.0.1:port</code></p><p> <code>git config --global https.proxy https://127.0.0.1:port</code></p></li></ol><h2 id="6-更换主题"><a href="#6-更换主题" class="headerlink" title="6. 更换主题"></a>6. 更换主题</h2><p>可以直接在搜索引擎搜索相关关键字，例如<code>hexo 主题</code>，以我现在使用的<code>Fluid</code>为例</p><p>GitHub地址: <a href="https://github.com/fluid-dev/hexo-theme-fluid/tree/master">https://github.com/fluid-dev/hexo-theme-fluid/tree/master</a></p><ol><li>在博客目录下克隆, 至<code>blog/themes</code>文件夹下: <code>git clone https://github.com/fluid-dev/hexo-theme-fluid/tree/master themes/fluid</code></li><li>更改<code>blog/_config.yml</code> 第100行，将<code>theme: </code>后改为<code>fluid</code></li><li>更多具体配置参考官方文档: <a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></li><li>大段文字需要换行需要使用<code>HTML</code>语法</li></ol><h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h2><p>这里面还有很多有意思的功能没探索、没开发。留给接下来的时间。也慢慢优化这个小网站。</p><p>参加“代码随想录”的训练营，虽然有点晚，但是还来得及。搭建了一个博客，主要还是写给自己，记录这一路的成长，当然也不单单的只这一路。</p><p>很喜欢郭帆导演的一句话，让我放在了首页开屏</p><p>&#x3D;&#x3D;如果你想再次拥有你从未有过的东西，那么你必须再次去做你从未做过的事情。这还不是结束，这是再次的开始！&#x3D;&#x3D;</p>]]></content>
    
    
    <categories>
      
      <category>搭建环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
